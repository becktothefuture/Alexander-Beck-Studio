import{g as t,ao as h,aV as s,e as i}from"./shared.js";let a=0;class M{constructor(h,s,i,M){const e=t();this.x=h,this.y=s,this.vx=200*(2*Math.random()-1),this.vy=200*-Math.random(),this.r=i,this.rBase=i,this.m=e.ballMassKg,this.color=M,this.t=0,this.age=0,this.driftAx=0,this.driftTime=0,this.omega=0,this.squash=1,this.squashDirX=1,this.squashDirY=0,this.theta=0,this.squashAmount=0,this.squashNormalAngle=0,this.alpha=1,this.z=1,this.isSleeping=!1,this.sleepTimer=0,this.isGrounded=!1,this.hasSupport=!1,this.h="ball-"+a++}step(i,a){const M=t(),{currentMode:e,G:o,gravityScale:c,FRICTION:n,MASS_BASELINE_KG:r}=M;if(this.t+=i,this.age+=i,this.isSleeping){const t=(M.repelRadius||710)*M.DPR*1.2,h=this.x-M.mouseX,s=this.y-M.mouseY;t*t>h*h+s*s&&this.wake()}if(this.isSleeping&&!1!==M.physicsSkipSleepingSteps)return;const l=M.DPR||1,u=this.isGrounded,S=this.hasSupport;this.isGrounded=!1,this.hasSupport=!1,e!==h.WEIGHTLESS&&(!u&&!S||-8*l>this.vy)&&(this.vy+=o*c*i);const f=Math.max(.25,this.m/r),d=Math.max(0,1-(e===h.WEIGHTLESS?0:n)*(1+1*Math.max(0,Math.min(1,1-Math.sqrt(this.vx*this.vx+this.vy*this.vy)/(100*l))))/f);this.vx*=d,this.vy*=d;const p=2*l;p>Math.abs(this.vx)&&(this.vx=0),p>Math.abs(this.vy)&&e===h.WEIGHTLESS&&(this.vy=0),0!==this.driftAx&&this.driftTime>this.age?this.vx+=this.driftAx*i/f:0!==this.driftAx&&(this.driftAx=0),a&&a(this,i),this.x+=this.vx*i,this.y+=this.vy*i,this.omega*=Math.max(0,1-s.SPIN_DAMP_PER_S*(1+.5*Math.max(0,Math.min(1,1-Math.abs(this.omega)/2)))*i),this.theta+=this.omega*i,.01>Math.abs(this.omega)&&(this.omega=0),this.i?(this.squashAmount=0,this.squash=1):(this.squashAmount+=(0-this.squashAmount)*Math.min(1,s.SQUASH_DECAY_PER_S*i),this.squash=1-this.squashAmount)}updateSleepState(t,h){const i=Math.sqrt(this.vx*this.vx+this.vy*this.vy),a=Math.abs(this.omega),M=h.DPR||1,e=(Number.isFinite(h.sleepVelocityThreshold)?h.sleepVelocityThreshold:s.SLEEP_VELOCITY_THRESHOLD)*M,o=Number.isFinite(h.sleepAngularThreshold)?h.sleepAngularThreshold:s.SLEEP_ANGULAR_THRESHOLD,c=Number.isFinite(h.timeToSleep)?h.timeToSleep:s.TIME_TO_SLEEP;(this.isGrounded||this.hasSupport)&&e>i&&o>a?(this.sleepTimer+=t,c>this.sleepTimer||(this.vx=0,this.vy=0,this.omega=0,this.isSleeping=!0)):this.sleepTimer=0}wake(){this.isSleeping=!1,this.sleepTimer=0}walls(a,M,e,o,c={}){const n=!1!==c.registerEffects&&!this.M,r=t(),{REST:l,MASS_BASELINE_KG:u,currentMode:S,DPR:f}=r,d=void 0!==o?o:l,p=this.r*(1+(r.ballSpacing||0)),N="function"==typeof r.getCanvasCornerRadius?r.getCanvasCornerRadius():r.cornerRadius??r.wallRadius??0,m=Math.max(0,+N||0)*(f||1),E=Math.max(0,(r.wallThickness??0)*(f||1)),b=Math.max(0,r.wallInset??3)*(f||1),A=Math.max(1,a-2*E),I=Math.max(1,M-2*E);let R=!1;const _=S===h.PIT,g=.5*A,w=.5*I,y=Math.max(0,Math.min(m,.5*A,.5*I)),B=this.x-(E+g),G=this.y-(E+w),v=Math.abs(B)-(g-y),D=Math.abs(G)-(w-y),K=Math.hypot(Math.max(v,0),Math.max(D,0))+Math.min(Math.max(v,D),0)-y;let L=0,T=0;if(v>0&&D>0){const t=Math.hypot(v,D);t>1e-6&&(L=v/t,T=D/t)}else v>D?(L=1,T=0):(L=0,T=1);L*=0>B?-1:1,T*=0>G?-1:1;const j=K+(p+b);if(!(0>=j||_&&-.5>T||S===h.BUBBLES&&-.5>T)){R=!0;const t=this.vx*L+this.vy*T;this.x-=L*j,this.y-=T*j,t>0&&(this.vx-=(1+d)*t*L,this.vy-=(1+d)*t*T);const h=T>.7,M=Math.min(1,Math.abs(t)/(80*this.r));if(h){this.isGrounded=!0;const t=Math.max(.25,this.m/u);this.vx*=Math.max(0,1-s.ROLL_FRICTION_PER_S*(1+Math.max(0,Math.min(1,1-Math.abs(this.vx)/(80*f))))*e/t),3*f>Math.abs(this.vx)&&(this.vx=0),this.omega+=(this.vx-this.omega*this.r)/this.r*s.SPIN_GAIN/t,this.omega+=(this.vx/this.r-this.omega)*Math.min(1,s.GROUND_COUPLING_PER_S*e),.05>Math.abs(this.omega)&&(this.omega=0)}this.i||(this.squashAmount=Math.min(r.getSquashMax(),.8*M),this.squashNormalAngle=Math.atan2(-T,-L)),n&&i(this.r,.65*M,this.x/Math.max(1,a),this.h)}R&&(this.isSleeping||!0===this.isMeteor)&&this.wake()}getDisplayRadius(){return this.r*(this.filterSizeMultiplier??1)}draw(t){const h=this.squashAmount>.01,s=this.alpha*(this.filterOpacity??1),i=1>s,a=this.getDisplayRadius();h||i?(t.save(),(h||i)&&(t.translate(this.x,this.y),h?(t.rotate(this.theta+this.squashNormalAngle),t.scale(1-.3*this.squashAmount,1+.3*this.squashAmount),t.rotate(-this.squashNormalAngle)):t.rotate(this.theta),i&&(t.globalAlpha=s),t.beginPath(),t.arc(0,0,a,0,2*Math.PI),t.fillStyle=this.color,t.fill()),t.restore()):(t.fillStyle=this.color,t.beginPath(),t.arc(this.x,this.y,a,0,2*Math.PI),t.fill())}}export{M as B};