function t(t,a){const n=Math.cos(a),o=Math.sin(a),s=1-n,r=t.x,e=t.y,h=t.z;return[s*r*r+n,s*r*e-o*h,s*r*h+o*e,s*r*e+o*h,s*e*e+n,s*e*h-o*r,s*r*h-o*e,s*e*h+o*r,s*h*h+n]}function a(t,a){return[t[0]*a[0]+t[1]*a[3]+t[2]*a[6],t[0]*a[1]+t[1]*a[4]+t[2]*a[7],t[0]*a[2]+t[1]*a[5]+t[2]*a[8],t[3]*a[0]+t[4]*a[3]+t[5]*a[6],t[3]*a[1]+t[4]*a[4]+t[5]*a[7],t[3]*a[2]+t[4]*a[5]+t[5]*a[8],t[6]*a[0]+t[7]*a[3]+t[8]*a[6],t[6]*a[1]+t[7]*a[4]+t[8]*a[7],t[6]*a[2]+t[7]*a[5]+t[8]*a[8]]}function n(){const t=r(),a=t.canvas;if(!a)return;s();const n=h(Math.max(10,Math.round(t.sphere3dDensity??350)));if(0>=n)return;const o=.6*(t.R_MED||20)*(t.DPR||1);t.sphere3dState={cx:.5*a.width,cy:.5*a.height,radiusPx:Math.max(10,(t.sphere3dRadiusVw??18)/100*Math.min(a.width,a.height)),rotationMatrix:[1,0,0,0,1,0,0,0,1],dotSizeMul:1.5,prevTrackballPoint:null,currentAngularVelX:0,currentAngularVelY:0,currentAngularVelZ:0,idleRotationTime:0,smoothMouseX:t.mouseX,smoothMouseY:t.mouseY,lastMouseX:t.mouseX,lastMouseY:t.mouseY};const M=(t=>{const a=[];for(let n=0;t>n;n++)a.push({theta:2*Math.PI*n/1.618033988749895,phi:Math.acos(1-2*(n+.5)/t)});return a})(n);for(let s=0;M.length>s;s++){const a=c(0,0);a&&(a.vx=0,a.vy=0,a.omega=0,a.r=e(t,1.5*o),a.t=o,a.o={theta:M[s].theta,phi:M[s].phi},a.h="sphere",a.isSleeping=!1)}}function o(n,o){const s=r(),h=s.canvas,c=s.sphere3dState;if(!(h&&c&&n&&n.o))return;const M=s.sphere3dIdleSpeed??.15,i=s.sphere3dTumbleSpeed??8,l=Math.max(0,Math.min(.999,s.sphere3dTumbleDamping??.94));if(n===s.balls[0]){c.cx=.5*h.width,c.cy=.5*h.height,c.radiusPx=Math.max(10,(s.sphere3dRadiusVw??18)/100*Math.min(h.width,h.height));const n=c.cx,r=c.cy;if(s.mouseInCanvas){const e=Math.max(.01,Math.min(1,s.sphere3dMouseDamping??.15));void 0===c.smoothMouseX&&(c.smoothMouseX=s.mouseX,c.smoothMouseY=s.mouseY),c.smoothMouseX+=(s.mouseX-c.smoothMouseX)*e,c.smoothMouseY+=(s.mouseY-c.smoothMouseY)*e;const h=c.smoothMouseX-n,M=c.smoothMouseY-r;if(1.3*c.radiusPx>Math.sqrt(h*h+M*M)){const n=((t,a,n)=>{const o=t/n,s=a/n,r=o*o+s*s;if(r>1){const t=Math.sqrt(r);return{x:o/t,y:s/t,z:.5/t}}return{x:o,y:s,z:Math.sqrt(1-r)}})(h,M,c.radiusPx);if(c.prevTrackballPoint){const s=((t,a)=>{const n=t.y*a.z-t.z*a.y,o=t.z*a.x-t.x*a.z,s=t.x*a.y-t.y*a.x,r=Math.sqrt(n*n+o*o+s*s);return 1e-4>r?{axis:{x:0,y:1,z:0},angle:0}:{axis:{x:n/r,y:o/r,z:s/r},angle:2*Math.acos(Math.max(-1,Math.min(1,t.x*a.x+t.y*a.y+t.z*a.z)))}})(c.prevTrackballPoint,n);if(s.angle>1e-4){const n=s.angle/o;if(n>.05){const o=i,r=t(s.axis,s.angle*o);c.rotationMatrix=a(r,c.rotationMatrix);const e=.5;c.currentAngularVelX=c.currentAngularVelX*e+s.axis.x*n*o*(1-e),c.currentAngularVelY=c.currentAngularVelY*e+s.axis.y*n*o*(1-e),c.currentAngularVelZ=c.currentAngularVelZ*e+s.axis.z*n*o*(1-e)}}}c.prevTrackballPoint=n}else c.prevTrackballPoint=null}else c.prevTrackballPoint=null;const e=l;c.currentAngularVelX*=e,c.currentAngularVelY*=e,c.currentAngularVelZ*=e;const u=Math.sqrt(c.currentAngularVelX*c.currentAngularVelX+c.currentAngularVelY*c.currentAngularVelY+c.currentAngularVelZ*c.currentAngularVelZ);if(u>.001){const n=t({x:c.currentAngularVelX/u,y:c.currentAngularVelY/u,z:c.currentAngularVelZ/u},u*o);c.rotationMatrix=a(n,c.rotationMatrix)}else c.currentAngularVelX=0,c.currentAngularVelY=0,c.currentAngularVelZ=0;if(.2>u){const n=t({x:0,y:1,z:0},M*o*(1-u/.2));c.rotationMatrix=a(n,c.rotationMatrix)}}const{theta:u,phi:f}=n.o,x=c.radiusPx,p=(g=c.rotationMatrix)[0]*(z={x:x*Math.sin(f)*Math.cos(u),y:x*Math.cos(f),z:x*Math.sin(f)*Math.sin(u)}).x+g[1]*z.y+g[2]*z.z,m=g[3]*z.x+g[4]*z.y+g[5]*z.z,y=g[6]*z.x+g[7]*z.y+g[8]*z.z;var z,g;const d=Math.max(80,s.sphere3dFocalLength??600),j=d/(d+(x-y)),v=c.cx+p*j,A=c.cy+m*j;n.r=e(s,1.5*n.t*j*(.6+.8*n.z)),n.x=v,n.y=A,n.vx=0,n.vy=0,n.omega=0,n.isSleeping=!1,n.z=(y+x)/(2*x)}import{al as s,g as r,am as e,aO as h}from"./shared.js";import{s as c}from"./spawn.js";import"./Ball.js";export{o as apply3DSphereForces,n as initialize3DSphere};