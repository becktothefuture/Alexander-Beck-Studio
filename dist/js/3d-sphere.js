function t(t,n){const a=Math.cos(n),o=Math.sin(n),s=1-a,r=t.x,e=t.y,h=t.z;return[s*r*r+a,s*r*e-o*h,s*r*h+o*e,s*r*e+o*h,s*e*e+a,s*e*h-o*r,s*r*h-o*e,s*e*h+o*r,s*h*h+a]}function n(t,n){return[t[0]*n[0]+t[1]*n[3]+t[2]*n[6],t[0]*n[1]+t[1]*n[4]+t[2]*n[7],t[0]*n[2]+t[1]*n[5]+t[2]*n[8],t[3]*n[0]+t[4]*n[3]+t[5]*n[6],t[3]*n[1]+t[4]*n[4]+t[5]*n[7],t[3]*n[2]+t[4]*n[5]+t[5]*n[8],t[6]*n[0]+t[7]*n[3]+t[8]*n[6],t[6]*n[1]+t[7]*n[4]+t[8]*n[7],t[6]*n[2]+t[7]*n[5]+t[8]*n[8]]}function a(){const t=r(),n=t.canvas;if(!n)return;s();const a=h(Math.max(10,Math.round(t.sphere3dDensity??350)));if(0>=a)return;const o=.6*(t.R_MED||20)*(t.DPR||1);t.sphere3dState={cx:.5*n.width,cy:.5*n.height,radiusPx:Math.max(10,(t.sphere3dRadiusVw??18)/100*Math.min(n.width,n.height)),rotationMatrix:[1,0,0,0,1,0,0,0,1],dotSizeMul:1.5,prevTrackballPoint:null,currentAngularVelX:0,currentAngularVelY:0,currentAngularVelZ:0,idleRotationTime:0,smoothMouseX:t.mouseX,smoothMouseY:t.mouseY,lastMouseX:t.mouseX,lastMouseY:t.mouseY};const M=(t=>{const n=[];for(let a=0;t>a;a++)n.push({theta:2*Math.PI*a/1.618033988749895,phi:Math.acos(1-2*(a+.5)/t)});return n})(a);for(let s=0;M.length>s;s++){const n=c(0,0);n&&(n.vx=0,n.vy=0,n.omega=0,n.r=e(t,1.5*o),n.t=o,n.o={theta:M[s].theta,phi:M[s].phi},n.h="sphere",n.isSleeping=!1)}}function o(a,o){const s=r(),h=s.canvas,c=s.sphere3dState;if(!(h&&c&&a&&a.o))return;const M=s.sphere3dIdleSpeed??.15,i=s.sphere3dTumbleSpeed??8,u=Math.max(0,Math.min(.999,s.sphere3dTumbleDamping??.94));if(a===s.balls[0]){c.cx=.5*h.width,c.cy=.5*h.height,c.radiusPx=Math.max(10,(s.sphere3dRadiusVw??18)/100*Math.min(h.width,h.height));const a=c.cx,r=c.cy;if(s.mouseInCanvas){const e=Math.max(.01,Math.min(1,s.sphere3dMouseDamping??.15));void 0===c.smoothMouseX&&(c.smoothMouseX=s.mouseX,c.smoothMouseY=s.mouseY),c.smoothMouseX+=(s.mouseX-c.smoothMouseX)*e,c.smoothMouseY+=(s.mouseY-c.smoothMouseY)*e;const h=c.smoothMouseX-a,M=c.smoothMouseY-r;if(1.3*c.radiusPx>Math.sqrt(h*h+M*M)){const a=((t,n,a)=>{const o=t/a,s=n/a,r=o*o+s*s;if(r>1){const t=Math.sqrt(r);return{x:o/t,y:s/t,z:.5/t}}return{x:o,y:s,z:Math.sqrt(1-r)}})(h,M,c.radiusPx);if(c.prevTrackballPoint){const s=((t,n)=>{const a=t.y*n.z-t.z*n.y,o=t.z*n.x-t.x*n.z,s=t.x*n.y-t.y*n.x,r=Math.sqrt(a*a+o*o+s*s);return 1e-4>r?{axis:{x:0,y:1,z:0},angle:0}:{axis:{x:a/r,y:o/r,z:s/r},angle:2*Math.acos(Math.max(-1,Math.min(1,t.x*n.x+t.y*n.y+t.z*n.z)))}})(c.prevTrackballPoint,a);if(s.angle>1e-4){const a=s.angle/o;if(a>.05){const o=i,r=t(s.axis,s.angle*o);c.rotationMatrix=n(r,c.rotationMatrix);const e=.5;c.currentAngularVelX=c.currentAngularVelX*e+s.axis.x*a*o*(1-e),c.currentAngularVelY=c.currentAngularVelY*e+s.axis.y*a*o*(1-e),c.currentAngularVelZ=c.currentAngularVelZ*e+s.axis.z*a*o*(1-e)}}}c.prevTrackballPoint=a}else c.prevTrackballPoint=null}else c.prevTrackballPoint=null;const e=u;c.currentAngularVelX*=e,c.currentAngularVelY*=e,c.currentAngularVelZ*=e;const l=Math.sqrt(c.currentAngularVelX*c.currentAngularVelX+c.currentAngularVelY*c.currentAngularVelY+c.currentAngularVelZ*c.currentAngularVelZ);if(l>.001){const a=t({x:c.currentAngularVelX/l,y:c.currentAngularVelY/l,z:c.currentAngularVelZ/l},l*o);c.rotationMatrix=n(a,c.rotationMatrix)}else c.currentAngularVelX=0,c.currentAngularVelY=0,c.currentAngularVelZ=0;if(.2>l){const a=t({x:0,y:1,z:0},M*o*(1-l/.2));c.rotationMatrix=n(a,c.rotationMatrix)}}const{theta:l,phi:f}=a.o,x=c.radiusPx,p=(g=c.rotationMatrix)[0]*(z={x:x*Math.sin(f)*Math.cos(l),y:x*Math.cos(f),z:x*Math.sin(f)*Math.sin(l)}).x+g[1]*z.y+g[2]*z.z,m=g[3]*z.x+g[4]*z.y+g[5]*z.z,y=g[6]*z.x+g[7]*z.y+g[8]*z.z;var z,g;const d=Math.max(80,s.sphere3dFocalLength??600),j=d/(d+(x-y)),v=c.cx+p*j,A=c.cy+m*j;a.r=e(s,1.5*a.t*j*(.6+.8*a.z)),a.x=v,a.y=A,a.vx=0,a.vy=0,a.omega=0,a.isSleeping=!1,a.z=(y+x)/(2*x)}import{am as s,g as r,an as e,aP as h}from"./shared.js";import{s as c}from"./spawn.js";import"./Ball.js";export{o as apply3DSphereForces,a as initialize3DSphere};