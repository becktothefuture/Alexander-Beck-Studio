<!DOCTYPE html><!--  This site was created in Webflow. https://webflow.com  --><!--  Last Published: Wed Oct 01 2025 07:06:55 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="68cee53d847dda2fd5c39cf1" data-wf-site="68cee53c847dda2fd5c39ce4">
<head>
  <meta charset="utf-8">
  <title>Alexander Beck Studio :: Al Creative :: User Experience :: Product Design</title>
  <meta content="c366" name="description">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="css/normalize.css" rel="stylesheet" type="text/css">
  <link href="css/webflow.css" rel="stylesheet" type="text/css">
  <link href="css/alexander-beck-studio-staging.webflow.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com" rel="preconnect">
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js" type="text/javascript"></script>
  <script type="text/javascript">WebFont.load({  google: {    families: ["Geist Mono:100,regular,800","Geist:200,regular,600,800"]  }});</script>
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="images/webclip.png" rel="apple-touch-icon">
  <style>
/* ═══════════════════════════════════════════════════════════════════════════ */
/* COMPACT SIDEBAR STYLES (Production Build)                                    */
/* ═══════════════════════════════════════════════════════════════════════════ */

#bravia-balls .panel {
  position: fixed;
  top: 20px;
  right: 20px;
  color: #fff;
  font: 9px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
  background: rgba(0,0,0,0.7);
  padding: 6px;
  border-radius: 6px;
  user-select: none;
  display: flex;
  flex-direction: column;
  gap: 4px;
  max-width: 280px;
  max-height: 85vh;
  overflow-y: auto;
  backdrop-filter: blur(10px);
  border: 1px solid rgba(255,255,255,0.1);
  box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  z-index: 10000;
  cursor: move;
  transition: opacity 0.2s ease;
}

#bravia-balls .panel.hidden {
  opacity: 0;
  pointer-events: none;
}

#bravia-balls .panel-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 4px 6px;
  background: rgba(255,255,255,0.1);
  border-radius: 4px;
  font-size: 10px;
  font-weight: 600;
  cursor: grab;
}

#bravia-balls .panel-header:active {
  cursor: grabbing;
}

#bravia-balls .drag-handle {
  opacity: 0.5;
  margin-right: 6px;
  font-size: 8px;
}

#bravia-balls .panel details {
  margin: 2px 0;
}

#bravia-balls .panel summary {
  font-size: 9px;
  font-weight: 600;
  padding: 3px 0;
  cursor: pointer;
  opacity: 0.9;
}

#bravia-balls .panel .group {
  display: flex;
  flex-direction: column;
  gap: 3px;
  padding: 2px 0;
}

#bravia-balls .panel label {
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 8px;
  gap: 6px;
}

#bravia-balls .panel input[type="range"] {
  width: 60px;
  height: 12px;
  cursor: pointer;
}

#bravia-balls .panel input[type="checkbox"] {
  width: 12px;
  height: 12px;
  cursor: pointer;
}

#bravia-balls .panel input[type="color"] {
  width: 20px;
  height: 12px;
  border: none;
  border-radius: 2px;
  cursor: pointer;
}

#bravia-balls .panel select {
  font-size: 8px;
  padding: 2px;
  background: rgba(255,255,255,0.1);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 3px;
  cursor: pointer;
}

#bravia-balls .panel .val,
#bravia-balls .panel .hex-val {
  font-size: 8px;
  opacity: 0.8;
  min-width: 35px;
  text-align: right;
  font-family: monospace;
}

#bravia-balls .panel .hex-val {
  cursor: pointer;
  min-width: 50px;
}

#bravia-balls .panel .mode-switcher {
  display: flex;
  gap: 2px;
  margin: 4px 0;
}

#bravia-balls .panel .mode-button {
  flex: 1;
  padding: 4px 6px;
  font-size: 8px;
  background: rgba(255,255,255,0.1);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 3px;
  cursor: pointer;
  transition: all 0.2s ease;
}

#bravia-balls .panel .mode-button.active {
  background: rgba(255,255,255,0.3);
  border-color: rgba(255,255,255,0.5);
}

#bravia-balls .panel button {
  font-size: 8px;
  padding: 3px 8px;
  background: #4CAF50;
  color: white;
  border: none;
  border-radius: 3px;
  cursor: pointer;
  font-weight: 600;
}

#bravia-balls .panel button:hover {
  background: #45a049;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  #bravia-balls .panel {
    max-width: 240px;
    font-size: 8px;
    top: 10px;
    right: 10px;
  }
  
  #bravia-balls .panel input[type="range"] {
    width: 50px;
  }
}
</style>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@7.3.2/dist/pixi.min.js"></script>
</head>
<body class="body">
  <div class="noise"></div>
  <div id="bravia-balls" class="ball-simulation w-embed">
    <canvas id="c" aria-label="Bouncy balls" role="img" draggable="false"></canvas>
    
    <!-- Compact Control Panel -->
    <div class="panel" id="controlPanel">
      <div class="panel-header" id="panelHeader">
        <span><span class="drag-handle">⋮⋮</span>Controls</span>
        <span id="minimizePanel" title="Toggle panel (/)">−</span>
      </div>
      
      <!-- WebGL Toggle -->
      <div style="margin-bottom: 6px; padding: 4px; background: rgba(255,165,0,0.15); border-radius: 3px;">
        <label style="display: flex; align-items: center; gap: 4px;">
          <input type="checkbox" id="useWebGLToggle">
          <span>⚡ WebGL</span>
        </label>
        <div id="rendererStatus" style="font-size: 7px; margin-top: 2px; opacity: 0.7;">Canvas2D Active</div>
      </div>
      
      <!-- Global Settings -->
      <details open>
        <summary>🌐 Global</summary>
        <div class="group">
          <label title="Ball size"><span>Size</span><input type="range" id="sizeSliderGlobal" min="0.1" max="6.0" step="0.05" value="0.7"><span class="val" id="sizeValGlobal">0.7</span></label>
          <label title="Size variation"><span>Variation</span><input type="range" id="sizeVariationSliderGlobal" min="0.0" max="1.0" step="0.05" value="0.15"><span class="val" id="sizeVariationValGlobal">0.15</span></label>
          <label title="Ball softness"><span>Softness</span><input type="range" id="ballSoftnessSliderGlobal" min="0" max="100" step="1" value="40"><span class="val" id="ballSoftnessValGlobal">40</span></label>
        </div>
      </details>
      
      <!-- Glass Morphism -->
      <details>
        <summary>🔮 Glass Effects</summary>
        <div class="group">
          <label><span>Enable</span><input type="checkbox" id="glassMorphismEnabled" checked></label>
          <label title="Illumination preset"><span>Template</span><select id="illuminationSelect">
            <option value="classicRaised">Classic Raised</option>
            <option value="pressedInset">Pressed/Inset</option>
            <option value="softGlow">Soft Glow</option>
            <option value="sharpGlass">Sharp Glass</option>
            <option value="dramaticDepth">Dramatic Depth</option>
          </select></label>
        </div>
      </details>
      
      <!-- Colors -->
      <details>
        <summary>🎨 Colors</summary>
        <div class="group">
          <label><span>Template</span><select id="colorSelect"></select></label>
          <label><span>Color 1</span><input type="color" id="color1" value="#b7bcb7"><span class="hex-val" id="color1Val">#B7BCB7</span></label>
          <label><span>Color 2</span><input type="color" id="color2" value="#e4e9e4"><span class="hex-val" id="color2Val">#E4E9E4</span></label>
        </div>
      </details>
      
      <!-- Mode Switcher -->
      <div style="margin: 6px 0;">
        <div class="mode-switcher">
          <button class="mode-button active" data-mode="pit">🎯 Pit</button>
          <button class="mode-button" data-mode="flies">🕊️ Flies</button>
          <button class="mode-button" data-mode="weightless">🌌 Zero-G</button>
        </div>
      </div>
      
      <!-- Physics -->
      <details>
        <summary>⚡ Physics</summary>
        <div class="group">
          <label><span>Max balls</span><input type="range" id="maxBallsSlider" min="50" max="800" step="25" value="350"><span class="val" id="maxBallsVal">350</span></label>
          <label><span>Gravity</span><input type="range" id="gravityPitSlider" min="0.0" max="2.0" step="0.05" value="0.0"><span class="val" id="gravityPitVal">0.0</span></label>
          <label><span>Bounce</span><input type="range" id="restitutionSlider" min="0.00" max="1.00" step="0.01" value="0.88"><span class="val" id="restitutionVal">0.88</span></label>
        </div>
      </details>
      
      <!-- Build Controls -->
      <div style="margin-top: 8px; text-align: center;">
        <button id="saveConfigBtn">💾 Export Config</button>
      </div>
    </div>
  </div>
  <header class="viewport viewport--content">
    <div id="w-node-e6a615f7-c7b2-8768-3157-95ffa1ec0a09-d5c39cf1" class="legend">
      <div class="w-layout-hflex legend__item">
        <div class="circle bg-ball-1"></div>
        <div>Creative Strategy</div>
      </div>
      <div class="w-layout-hflex legend__item">
        <div class="circle bg-ball-3"></div>
        <div>Visual Design</div>
      </div>
      <div class="w-layout-hflex legend__item">
        <div class="circle bg-ball-5"></div>
        <div>Precision Typography</div>
      </div>
      <div class="w-layout-hflex legend__item">
        <div class="circle bg-ball-2"></div>
        <div>Design Strategy</div>
      </div>
      <div class="w-layout-hflex legend__item">
        <div class="circle bg-ball-4"></div>
        <div>Brand &amp; Experience</div>
      </div>
      <div class="w-layout-hflex legend__item">
        <div class="circle bg-ball-6"></div>
        <div>AI Technologist</div>
      </div>
    </div>
    <div id="w-node-_38b28c23-04bb-05c7-72ee-2ae65152e2c6-d5c39cf1" class="header is-align-center">
      <div class="hero__text w-embed"><svg viewbox="0 0 921 123" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M1.76 93L24.288 30.52H34.496L57.024 93H48.752L42.504 75.224H16.28L10.032 93H1.76ZM18.832 67.832H39.952L29.392 37.12L18.832 67.832ZM72.3333 93C69.6346 93 67.4346 92.296 65.7333 90.888C64.0319 89.48 63.1813 87.2507 63.1813 84.2V30.52H70.5733V83.584C70.5733 84.5227 70.8079 85.256 71.2773 85.784C71.8053 86.2533 72.5386 86.488 73.4773 86.488H77.5253V93H72.3333ZM102.218 94.056C97.8182 94.056 94.0049 93.0587 90.7782 91.064C87.6102 89.0693 85.1462 86.2533 83.3862 82.616C81.6849 78.92 80.8342 74.608 80.8342 69.68C80.8342 64.752 81.6849 60.4693 83.3862 56.832C85.1462 53.1947 87.5809 50.3787 90.6902 48.384C93.8582 46.3307 97.5835 45.304 101.866 45.304C105.914 45.304 109.493 46.272 112.602 48.208C115.712 50.0853 118.117 52.8427 119.818 56.48C121.578 60.1173 122.458 64.5467 122.458 69.768V71.968H88.5782C88.8715 76.9547 90.1915 80.7093 92.5382 83.232C94.9435 85.7547 98.1702 87.016 102.218 87.016C105.269 87.016 107.762 86.312 109.698 84.904C111.693 83.4373 113.072 81.5307 113.834 79.184L121.754 79.8C120.522 83.9653 118.176 87.3973 114.714 90.096C111.312 92.736 107.146 94.056 102.218 94.056ZM88.5782 65.456H114.362C114.01 60.9387 112.69 57.624 110.402 55.512C108.173 53.4 105.328 52.344 101.866 52.344C98.2875 52.344 95.3249 53.4587 92.9782 55.688C90.6902 57.8587 89.2235 61.1147 88.5782 65.456ZM126.906 93L144.066 69.064L127.786 46.36H136.41L148.642 63.96L160.522 46.36H169.322L153.218 69.24L170.114 93H161.49L148.642 74.168L135.706 93H126.906ZM192.551 94.056C188.092 94.056 184.396 92.9413 181.463 90.712C178.588 88.4827 176.418 85.52 174.951 81.824C173.543 78.128 172.839 74.08 172.839 69.68C172.839 65.3387 173.543 61.32 174.951 57.624C176.359 53.928 178.5 50.9653 181.375 48.736C184.308 46.448 188.004 45.304 192.463 45.304C195.924 45.304 198.858 45.9787 201.263 47.328C203.727 48.6773 205.604 50.5253 206.895 52.872V46.36H214.287V93H207.599L207.247 82.44L208.303 83.32C207.658 85.4907 206.602 87.3973 205.135 89.04C203.727 90.624 201.967 91.856 199.855 92.736C197.743 93.616 195.308 94.056 192.551 94.056ZM194.047 87.016C197.274 87.016 199.796 86.1947 201.615 84.552C203.492 82.8507 204.842 80.68 205.663 78.04C206.484 75.3413 206.895 72.5547 206.895 69.68C206.895 66.6293 206.484 63.8133 205.663 61.232C204.842 58.592 203.492 56.4507 201.615 54.808C199.796 53.1653 197.274 52.344 194.047 52.344C190.938 52.344 188.386 53.1653 186.391 54.808C184.396 56.392 182.93 58.504 181.991 61.144C181.052 63.7253 180.583 66.5707 180.583 69.68C180.583 72.6133 181.023 75.4293 181.903 78.128C182.842 80.768 184.308 82.9093 186.303 84.552C188.298 86.1947 190.879 87.016 194.047 87.016ZM225.703 93V46.36H232.479L232.743 58.24L231.863 57.448C232.449 54.6907 233.476 52.432 234.943 50.672C236.409 48.8533 238.169 47.504 240.223 46.624C242.335 45.744 244.593 45.304 246.999 45.304C250.577 45.304 253.511 46.096 255.799 47.68C258.145 49.264 259.876 51.4053 260.991 54.104C262.164 56.744 262.751 59.7067 262.751 62.992V93H255.359V65.104C255.359 62.2293 255.007 59.824 254.303 57.888C253.657 55.8933 252.601 54.3973 251.135 53.4C249.668 52.344 247.761 51.816 245.415 51.816C241.836 51.816 238.873 52.96 236.527 55.248C234.239 57.4773 233.095 60.7627 233.095 65.104V93H225.703ZM290.74 94.056C286.692 94.056 283.172 93.0587 280.18 91.064C277.246 89.0693 274.988 86.2533 273.404 82.616C271.82 78.9787 271.028 74.6667 271.028 69.68C271.028 64.6933 271.82 60.3813 273.404 56.744C274.988 53.1067 277.246 50.2907 280.18 48.296C283.172 46.3013 286.692 45.304 290.74 45.304C293.849 45.304 296.694 45.9787 299.276 47.328C301.857 48.6187 303.793 50.4667 305.084 52.872V30.52H312.476V93H305.788L305.524 85.96C304.233 88.4827 302.268 90.4773 299.628 91.944C296.988 93.352 294.025 94.056 290.74 94.056ZM292.236 87.016C294.993 87.016 297.31 86.312 299.188 84.904C301.124 83.496 302.59 81.5013 303.588 78.92C304.585 76.28 305.084 73.2 305.084 69.68C305.084 66.0427 304.585 62.9333 303.588 60.352C302.59 57.7707 301.124 55.8053 299.188 54.456C297.31 53.048 294.993 52.344 292.236 52.344C288.129 52.344 284.844 53.8987 282.38 57.008C279.974 60.0587 278.772 64.2827 278.772 69.68C278.772 75.0187 279.974 79.2427 282.38 82.352C284.844 85.4613 288.129 87.016 292.236 87.016ZM342.108 94.056C337.708 94.056 333.894 93.0587 330.668 91.064C327.5 89.0693 325.036 86.2533 323.276 82.616C321.574 78.92 320.724 74.608 320.724 69.68C320.724 64.752 321.574 60.4693 323.276 56.832C325.036 53.1947 327.47 50.3787 330.58 48.384C333.748 46.3307 337.473 45.304 341.756 45.304C345.804 45.304 349.382 46.272 352.492 48.208C355.601 50.0853 358.006 52.8427 359.708 56.48C361.468 60.1173 362.348 64.5467 362.348 69.768V71.968H328.468C328.761 76.9547 330.081 80.7093 332.428 83.232C334.833 85.7547 338.06 87.016 342.108 87.016C345.158 87.016 347.652 86.312 349.588 84.904C351.582 83.4373 352.961 81.5307 353.724 79.184L361.644 79.8C360.412 83.9653 358.065 87.3973 354.604 90.096C351.201 92.736 347.036 94.056 342.108 94.056ZM328.468 65.456H354.252C353.9 60.9387 352.58 57.624 350.292 55.512C348.062 53.4 345.217 52.344 341.756 52.344C338.177 52.344 335.214 53.4587 332.868 55.688C330.58 57.8587 329.113 61.1147 328.468 65.456ZM370.58 93V46.36H377.092L377.444 58.152L376.74 57.888C377.326 53.8987 378.588 50.9947 380.524 49.176C382.518 47.2987 385.158 46.36 388.444 46.36H393.02V53.4H388.532C386.185 53.4 384.22 53.84 382.636 54.72C381.11 55.5413 379.937 56.8027 379.116 58.504C378.353 60.1467 377.972 62.2587 377.972 64.84V93H370.58ZM419.059 93V30.52H440.531C447.923 30.52 453.467 31.8693 457.163 34.568C460.859 37.2667 462.707 41.52 462.707 47.328C462.707 50.0267 462.121 52.4027 460.947 54.456C459.774 56.5093 458.102 58.1227 455.931 59.296C453.761 60.4107 451.179 60.968 448.187 60.968L448.099 60.44C453.438 60.44 457.633 61.8773 460.683 64.752C463.793 67.568 465.347 71.264 465.347 75.84C465.347 81.5307 463.499 85.8133 459.803 88.688C456.107 91.5627 450.857 93 444.051 93H419.059ZM426.627 85.608H444.051C448.334 85.608 451.619 84.728 453.907 82.968C456.254 81.208 457.427 78.6853 457.427 75.4C457.427 72.1147 456.254 69.5627 453.907 67.744C451.619 65.8667 448.334 64.928 444.051 64.928H426.627V85.608ZM426.627 57.536H440.531C445.107 57.536 448.627 56.6853 451.091 54.984C453.555 53.224 454.787 50.7893 454.787 47.68C454.787 44.3947 453.585 41.96 451.179 40.376C448.833 38.7333 445.283 37.912 440.531 37.912H426.627V57.536ZM492.512 94.056C488.112 94.056 484.299 93.0587 481.072 91.064C477.904 89.0693 475.44 86.2533 473.68 82.616C471.979 78.92 471.128 74.608 471.128 69.68C471.128 64.752 471.979 60.4693 473.68 56.832C475.44 53.1947 477.875 50.3787 480.984 48.384C484.152 46.3307 487.877 45.304 492.16 45.304C496.208 45.304 499.787 46.272 502.896 48.208C506.005 50.0853 508.411 52.8427 510.112 56.48C511.872 60.1173 512.752 64.5467 512.752 69.768V71.968H478.872C479.165 76.9547 480.485 80.7093 482.832 83.232C485.237 85.7547 488.464 87.016 492.512 87.016C495.563 87.016 498.056 86.312 499.992 84.904C501.987 83.4373 503.365 81.5307 504.128 79.184L512.048 79.8C510.816 83.9653 508.469 87.3973 505.008 90.096C501.605 92.736 497.44 94.056 492.512 94.056ZM478.872 65.456H504.656C504.304 60.9387 502.984 57.624 500.696 55.512C498.467 53.4 495.621 52.344 492.16 52.344C488.581 52.344 485.619 53.4587 483.272 55.688C480.984 57.8587 479.517 61.1147 478.872 65.456ZM540.08 94.056C535.739 94.056 531.955 93.0587 528.728 91.064C525.56 89.0693 523.096 86.2533 521.336 82.616C519.576 78.92 518.696 74.608 518.696 69.68C518.696 64.752 519.576 60.4693 521.336 56.832C523.096 53.1947 525.56 50.3787 528.728 48.384C531.955 46.3307 535.739 45.304 540.08 45.304C543.659 45.304 546.827 45.9493 549.584 47.24C552.4 48.472 554.688 50.2907 556.448 52.696C558.208 55.1013 559.352 58.0347 559.88 61.496L552.136 62.024C551.608 58.9147 550.259 56.5387 548.088 54.896C545.917 53.1947 543.248 52.344 540.08 52.344C535.797 52.344 532.453 53.8987 530.048 57.008C527.643 60.0587 526.44 64.2827 526.44 69.68C526.44 75.0773 527.643 79.3307 530.048 82.44C532.453 85.4907 535.797 87.016 540.08 87.016C543.248 87.016 545.917 86.136 548.088 84.376C550.259 82.616 551.608 79.976 552.136 76.456L559.88 76.984C559.352 80.4453 558.208 83.4667 556.448 86.048C554.688 88.5707 552.4 90.536 549.584 91.944C546.827 93.352 543.659 94.056 540.08 94.056ZM567.263 93V30.52H574.655V71.44L597.359 46.36H607.215L588.823 66.16L608.007 93H599.031L583.807 71.176L574.655 80.856V93H567.263ZM655.777 94.408C650.967 94.408 646.772 93.4987 643.193 91.68C639.615 89.8613 636.769 87.368 634.657 84.2C632.604 80.9733 631.401 77.248 631.049 73.024L638.969 72.496C639.38 75.6053 640.289 78.2453 641.697 80.416C643.105 82.5867 644.983 84.2293 647.329 85.344C649.735 86.4587 652.609 87.016 655.953 87.016C658.887 87.016 661.38 86.6347 663.433 85.872C665.487 85.1093 667.041 83.9947 668.097 82.528C669.212 81.0613 669.769 79.272 669.769 77.16C669.769 75.224 669.3 73.5227 668.361 72.056C667.481 70.5307 665.751 69.152 663.169 67.92C660.647 66.6293 656.892 65.368 651.905 64.136C647.095 62.904 643.252 61.5547 640.377 60.088C637.561 58.6213 635.508 56.832 634.217 54.72C632.985 52.608 632.369 49.9973 632.369 46.888C632.369 43.368 633.191 40.288 634.833 37.648C636.535 34.9493 638.94 32.8667 642.049 31.4C645.159 29.8747 648.855 29.112 653.137 29.112C657.713 29.112 661.644 29.992 664.929 31.752C668.215 33.4533 670.825 35.8 672.761 38.792C674.697 41.784 675.9 45.1867 676.369 49L668.449 49.528C668.097 47.0053 667.276 44.776 665.985 42.84C664.753 40.8453 663.052 39.2907 660.881 38.176C658.711 37.0613 656.071 36.504 652.961 36.504C649.089 36.504 646.009 37.4427 643.721 39.32C641.433 41.1387 640.289 43.544 640.289 46.536C640.289 48.472 640.729 50.0853 641.609 51.376C642.548 52.608 644.191 53.7227 646.537 54.72C648.884 55.6587 652.257 56.6853 656.657 57.8C661.879 59.0907 666.015 60.6453 669.065 62.464C672.175 64.224 674.375 66.2773 675.665 68.624C677.015 70.9707 677.689 73.64 677.689 76.632C677.689 80.2693 676.751 83.4373 674.873 86.136C672.996 88.776 670.415 90.8293 667.129 92.296C663.844 93.704 660.06 94.408 655.777 94.408ZM702.21 93C697.986 93 694.848 92.032 692.794 90.096C690.8 88.16 689.802 85.1387 689.802 81.032V35.448H697.194V80.856C697.194 82.968 697.664 84.4347 698.602 85.256C699.541 86.0773 700.978 86.488 702.914 86.488H709.602V93H702.21ZM682.938 52.872V46.36H709.602V52.872H682.938ZM732.271 94.056C727.637 94.056 723.911 92.5013 721.095 89.392C718.338 86.224 716.959 81.8827 716.959 76.368V46.36H724.351V74.344C724.351 78.8613 725.143 82.2053 726.727 84.376C728.37 86.488 730.863 87.544 734.207 87.544C737.903 87.544 740.807 86.3707 742.919 84.024C745.031 81.6187 746.087 78.3333 746.087 74.168V46.36H753.479V93H746.439V81.472L747.583 82.088C746.645 85.9013 744.855 88.864 742.215 90.976C739.575 93.0293 736.261 94.056 732.271 94.056ZM781.481 94.056C777.433 94.056 773.913 93.0587 770.921 91.064C767.987 89.0693 765.729 86.2533 764.145 82.616C762.561 78.9787 761.769 74.6667 761.769 69.68C761.769 64.6933 762.561 60.3813 764.145 56.744C765.729 53.1067 767.987 50.2907 770.921 48.296C773.913 46.3013 777.433 45.304 781.481 45.304C784.59 45.304 787.435 45.9787 790.017 47.328C792.598 48.6187 794.534 50.4667 795.825 52.872V30.52H803.217V93H796.529L796.265 85.96C794.974 88.4827 793.009 90.4773 790.369 91.944C787.729 93.352 784.766 94.056 781.481 94.056ZM782.977 87.016C785.734 87.016 788.051 86.312 789.929 84.904C791.865 83.496 793.331 81.5013 794.329 78.92C795.326 76.28 795.825 73.2 795.825 69.68C795.825 66.0427 795.326 62.9333 794.329 60.352C793.331 57.7707 791.865 55.8053 789.929 54.456C788.051 53.048 785.734 52.344 782.977 52.344C778.87 52.344 775.585 53.8987 773.121 57.008C770.715 60.0587 769.513 64.2827 769.513 69.68C769.513 75.0187 770.715 79.2427 773.121 82.352C775.585 85.4613 778.87 87.016 782.977 87.016ZM814.632 93V46.36H822.024V93H814.632ZM818.416 39.32C817.184 39.32 816.158 38.9387 815.336 38.176C814.574 37.3547 814.192 36.2693 814.192 34.92C814.192 33.6293 814.574 32.5733 815.336 31.752C816.158 30.9307 817.184 30.52 818.416 30.52C819.648 30.52 820.646 30.9307 821.408 31.752C822.23 32.5733 822.64 33.6293 822.64 34.92C822.64 36.2693 822.23 37.3547 821.408 38.176C820.646 38.9387 819.648 39.32 818.416 39.32ZM851.693 94.056C847.41 94.056 843.656 93.0587 840.429 91.064C837.202 89.0693 834.709 86.2533 832.949 82.616C831.189 78.92 830.309 74.608 830.309 69.68C830.309 64.6933 831.189 60.3813 832.949 56.744C834.709 53.1067 837.202 50.2907 840.429 48.296C843.656 46.3013 847.41 45.304 851.693 45.304C855.976 45.304 859.701 46.3013 862.869 48.296C866.096 50.2907 868.589 53.1067 870.349 56.744C872.109 60.3813 872.989 64.6933 872.989 69.68C872.989 74.608 872.109 78.92 870.349 82.616C868.589 86.2533 866.096 89.0693 862.869 91.064C859.701 93.0587 855.976 94.056 851.693 94.056ZM851.693 87.016C855.976 87.016 859.29 85.4907 861.637 82.44C864.042 79.3307 865.245 75.0773 865.245 69.68C865.245 64.2827 864.042 60.0587 861.637 57.008C859.29 53.8987 855.976 52.344 851.693 52.344C847.41 52.344 844.066 53.8987 841.661 57.008C839.256 60.0587 838.053 64.2827 838.053 69.68C838.053 75.0773 839.256 79.3307 841.661 82.44C844.066 85.4907 847.41 87.016 851.693 87.016Z" fill="#161616"></path>
          <ellipse cx="904" cy="50.9883" rx="16" ry="16" stroke="black" style="stroke:black;stroke-opacity:1;" stroke-width="1.5"></ellipse>
          <path d="M909.046 44.9121C910.191 44.9121 911.157 45.2424 911.837 45.8262C912.518 46.4108 912.908 47.2457 912.908 48.2432C912.908 49.4861 912.309 50.4595 911.38 50.7969C912.714 51.1016 913.594 52.194 913.594 53.6748C913.594 55.6619 911.973 57.0575 909.731 57.0576H905.715V44.9121H909.046ZM907.116 55.6562H909.731C910.436 55.6562 911.031 55.4466 911.447 55.0898C911.863 54.7337 912.106 54.2277 912.106 53.624C912.106 53.0203 911.863 52.5144 911.447 52.1582C911.031 51.8013 910.436 51.5909 909.731 51.5908H907.116V55.6562ZM907.116 50.1904H909.046C909.76 50.1904 910.355 49.9887 910.77 49.6465C911.183 49.3052 911.421 48.8204 911.421 48.2432C911.421 47.6656 911.187 47.1854 910.776 46.8486C910.364 46.5108 909.77 46.3135 909.046 46.3135H907.116V50.1904Z" fill="black" stroke="black" style="fill:black;fill-opacity:1;stroke:black;stroke-opacity:1;" stroke-width="0.15"></path>
          <path d="M900.007 44.9121L900.024 44.9629L904.154 56.958L904.188 57.0576H902.677L902.659 57.0068L901.34 53.1846H896.632L895.312 57.0068L895.295 57.0576H893.782L893.816 56.958L897.946 44.9629L897.964 44.9121H900.007ZM897.111 51.7842H900.859L898.993 46.3486L897.111 51.7842Z" fill="black" stroke="black" style="fill:black;fill-opacity:1;stroke:black;stroke-opacity:1;" stroke-width="0.15"></path>
        </svg></div>
    </div>
    <ul role="list" aria-label="Social media links" id="w-node-a3bdcba3-22cc-d78c-cb19-91003b154f3e-d5c39cf1" class="footer_icon-group w-list-unstyled">
      <li class="margin-bottom_none">
        <a href="#" class="footer_icon-link w-inline-block"><svg width="100%" height="100%" viewbox="0 0 16 16">
            <path d="M16,8.048a8,8,0,1,0-9.25,7.9V10.36H4.719V8.048H6.75V6.285A2.822,2.822,0,0,1,9.771,3.173a12.2,12.2,0,0,1,1.791.156V5.3H10.554a1.155,1.155,0,0,0-1.3,1.25v1.5h2.219l-.355,2.312H9.25v5.591A8,8,0,0,0,16,8.048Z" fill="currentColor"></path>
          </svg>
          <div class="screen-reader">Facebook</div>
        </a>
      </li>
      <li class="margin-bottom_none">
        <a href="#" class="footer_icon-link w-inline-block"><svg width="100%" height="100%" viewbox="0 0 16 16">
            <path d="M8,1.441c2.136,0,2.389.009,3.233.047a4.419,4.419,0,0,1,1.485.276,2.472,2.472,0,0,1,.92.6,2.472,2.472,0,0,1,.6.92,4.419,4.419,0,0,1,.276,1.485c.038.844.047,1.1.047,3.233s-.009,2.389-.047,3.233a4.419,4.419,0,0,1-.276,1.485,2.644,2.644,0,0,1-1.518,1.518,4.419,4.419,0,0,1-1.485.276c-.844.038-1.1.047-3.233.047s-2.389-.009-3.233-.047a4.419,4.419,0,0,1-1.485-.276,2.472,2.472,0,0,1-.92-.6,2.472,2.472,0,0,1-.6-.92,4.419,4.419,0,0,1-.276-1.485c-.038-.844-.047-1.1-.047-3.233s.009-2.389.047-3.233a4.419,4.419,0,0,1,.276-1.485,2.472,2.472,0,0,1,.6-.92,2.472,2.472,0,0,1,.92-.6,4.419,4.419,0,0,1,1.485-.276c.844-.038,1.1-.047,3.233-.047M8,0C5.827,0,5.555.009,4.7.048A5.868,5.868,0,0,0,2.76.42a3.908,3.908,0,0,0-1.417.923A3.908,3.908,0,0,0,.42,2.76,5.868,5.868,0,0,0,.048,4.7C.009,5.555,0,5.827,0,8s.009,2.445.048,3.3A5.868,5.868,0,0,0,.42,13.24a3.908,3.908,0,0,0,.923,1.417,3.908,3.908,0,0,0,1.417.923,5.868,5.868,0,0,0,1.942.372C5.555,15.991,5.827,16,8,16s2.445-.009,3.3-.048a5.868,5.868,0,0,0,1.942-.372,4.094,4.094,0,0,0,2.34-2.34,5.868,5.868,0,0,0,.372-1.942c.039-.853.048-1.125.048-3.3s-.009-2.445-.048-3.3A5.868,5.868,0,0,0,15.58,2.76a3.908,3.908,0,0,0-.923-1.417A3.908,3.908,0,0,0,13.24.42,5.868,5.868,0,0,0,11.3.048C10.445.009,10.173,0,8,0Z" fill="currentColor"></path>
            <path d="M8,3.892A4.108,4.108,0,1,0,12.108,8,4.108,4.108,0,0,0,8,3.892Zm0,6.775A2.667,2.667,0,1,1,10.667,8,2.667,2.667,0,0,1,8,10.667Z" fill="currentColor"></path>
            <circle cx="12.27" cy="3.73" r="0.96" fill="currentColor"></circle>
          </svg>
          <div class="screen-reader">Instagram<br></div>
        </a>
      </li>
      <li class="margin-bottom_none">
        <a href="#" class="footer_icon-link w-inline-block"><svg width="100%" height="100%" viewbox="0 0 16 16">
            <path d="M15.3,0H0.7C0.3,0,0,0.3,0,0.7v14.7C0,15.7,0.3,16,0.7,16h14.7c0.4,0,0.7-0.3,0.7-0.7V0.7 C16,0.3,15.7,0,15.3,0z M4.7,13.6H2.4V6h2.4V13.6z M3.6,5C2.8,5,2.2,4.3,2.2,3.6c0-0.8,0.6-1.4,1.4-1.4c0.8,0,1.4,0.6,1.4,1.4 C4.9,4.3,4.3,5,3.6,5z M13.6,13.6h-2.4V9.9c0-0.9,0-2-1.2-2c-1.2,0-1.4,1-1.4,2v3.8H6.2V6h2.3v1h0c0.3-0.6,1.1-1.2,2.2-1.2 c2.4,0,2.8,1.6,2.8,3.6V13.6z" fill="currentColor"></path>
          </svg>
          <div class="screen-reader">LinkedIn</div>
        </a>
      </li>
    </ul>
    <a id="w-node-a3bdcba3-22cc-d78c-cb19-91003b154f55-d5c39cf1" href="mailto:alexander@beck.fyi?subject=Hello!" class="footer_link">Get in touch</a>
    <a id="w-node-a3bdcba3-22cc-d78c-cb19-91003b154f57-d5c39cf1" href="mailto:alexander@beck.fyi?subject=Hello!" class="footer_link">Portfolio [offline]</a>
    <div id="w-node-a3bdcba3-22cc-d78c-cb19-91003b154f59-d5c39cf1" class="w-layout-hflex caption">
      <div>Est. 2025</div>
    </div>
  </header>
  <header class="viewport viewport--corners">
    <div class="corner corner--tr w-embed"><svg viewbox="0 0 92 92" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M92 0C54.5089 0 35.7631 -3.62396e-05 22.4248 9.21864C17.2615 12.7872 12.7872 17.2615 9.21864 22.4248C-3.62396e-05 35.7631 0 54.5089 0 92V0H92Z" fill="currentColor"></path>
      </svg></div>
    <div class="corner corner--bl w-embed"><svg viewbox="0 0 92 92" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M92 0C54.5089 0 35.7631 -3.62396e-05 22.4248 9.21864C17.2615 12.7872 12.7872 17.2615 9.21864 22.4248C-3.62396e-05 35.7631 0 54.5089 0 92V0H92Z" fill="currentColor"></path>
      </svg></div>
    <div class="corner corner--br w-embed"><svg viewbox="0 0 92 92" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M92 0C54.5089 0 35.7631 -3.62396e-05 22.4248 9.21864C17.2615 12.7872 12.7872 17.2615 9.21864 22.4248C-3.62396e-05 35.7631 0 54.5089 0 92V0H92Z" fill="currentColor"></path>
      </svg></div>
    <div class="corner corner--tl w-embed"><svg viewbox="0 0 92 92" fill="none" xmlns="http://www.w3.org/2000/svg">
        <path d="M92 0C54.5089 0 35.7631 -3.62396e-05 22.4248 9.21864C17.2615 12.7872 12.7872 17.2615 9.21864 22.4248C-3.62396e-05 35.7631 0 54.5089 0 92V0H92Z" fill="currentColor"></path>
      </svg></div>
  </header>
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=68cee53c847dda2fd5c39ce4" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="js/webflow.js" type="text/javascript"></script>
  <script>
// ═══════════════════════════════════════════════════════════════════════════
// BOUNCY BALLS SIMULATION (Production Build)
// ═══════════════════════════════════════════════════════════════════════════

// Version: 2024-10-01 - 4-mode system (Ball Pit, Flies, Zero-G, Pulse Grid)
(() => {
  // Behavior modes with device availability
  const MODES = {
    PIT: 'pit',          // Ball Pit: gravity + repeller
    FLIES: 'flies',      // Flies to Light: attraction to mouse, no gravity
    WEIGHTLESS: 'weightless',  // Weightless Bounce: zero-G bouncing balls
    PULSE_GRID: 'pulse-grid'   // Pulse Grid: rhythmic grid-based movement
  };
  
  // Mode availability by device type
  const MODE_AVAILABILITY = {
    [MODES.PIT]: { desktop: true, mobile: true },
    [MODES.FLIES]: { desktop: true, mobile: true },
    [MODES.WEIGHTLESS]: { desktop: true, mobile: true },
    [MODES.PULSE_GRID]: { desktop: true, mobile: true }
  };
  
  let currentMode = MODES.PIT;
  
  // ═══════════════════════════════════════════════════════════════════════════
  // GLOBAL PARAMETERS (apply to all modes)
  // ═══════════════════════════════════════════════════════════════════════════
  let ballSoftness = 40; // 0-100: controls squash/stretch on collision (0=hard, 100=very squishy)
  
  // Mode-specific parameters
  // Ball Pit mode parameters - REALISTIC RUBBER BALL PHYSICS
  let gravityMultiplierPit = 1.15; // Slightly heavier feel for realism
  let repellerEnabledPit = true;
  
  // Flies mode parameters - REALISTIC INSECT FLIGHT (mosquitoes/gnats)
  let attractionPower = 5000; // Much faster: insects dart quickly toward light
  let orbitRadius = 180; // Wider: insects don't cluster tightly
  let swarmSpeed = 3.5; // 3.5x faster: insects are quick and erratic
  
  // Weightless mode parameters - REALISTIC SPACE PHYSICS
  let weightlessCount = 80; // fixed number of balls
  let weightlessInitialSpeed = 250; // Slightly faster for visible motion in zero-g
  let weightlessBounce = 0.97; // Very elastic but not perfect (micro-imperfections)
  let weightlessRepellerPower = 300; // subtle mouse repeller strength
  let weightlessRepellerRadius = 150; // repeller radius (px)
  
  // Pulse Grid mode parameters - RHYTHMIC GRID-BASED MOVEMENT
  let gridColumns = 40; // Number of columns in the grid (width)
  let gridCellAspect = 1.0; // Cell aspect ratio (1.0 = square cells)
  let pulseInterval = 0.8; // Time between movements (seconds) - the "beat"
  let pulseSpeed = 0.25; // Duration of jump animation (seconds)
  let pulseSynchronicity = 0.3; // How synchronized movements are (0=all sync, 1=random)
  let pulseRandomness = 0.4; // Movement variation and jitter (0=uniform, 1=chaotic)
  let pulseMinSteps = 1; // Minimum grid cells to move per pulse
  let pulseMaxSteps = 3; // Maximum grid cells to move per pulse
  let gridBallCount = 120; // Number of balls in grid mode
  let pulseBounceIntensity = 0.15; // Bounce-back effect strength (0=none, 1=extreme)
  let pulseEasingStyle = 'snap'; // Easing style: 'linear', 'snap', 'bounce'
  let pulseOvershoot = 1.08; // Overshoot multiplier for robotic feel (1.0=none, 1.2=20% overshoot)
  
  let cursorBallVisible = true;       // Show cursor ball on desktop
  
  // Canvas shadow filter parameters
  let canvasShadowEnabled = false;
  let shadowOffsetX = 0;
  let shadowOffsetY = 4;
  let shadowBlur = 12;
  let shadowOpacity = 0.15;
  let shadowColor = '#000000';
  let shadow2Enabled = false;
  let shadow2Blur = 4;
  let shadow2Opacity = 0.10;
  
  // Mass constants (needed before CONSTANTS object)
  const MASS_BASELINE_KG = 1.0; // reference mass for scaling drag/forces
  
  // Configuration validation schema
  const CONFIG_SCHEMA = {
    gridColumns: { min: 20, max: 80, type: 'integer', default: 40 },
    gridBallCount: { min: 40, max: 200, type: 'integer', default: 120 },
    pulseInterval: { min: 0.2, max: 2.0, type: 'number', default: 0.8 },
    pulseSpeed: { min: 0.1, max: 1.0, type: 'number', default: 0.25 },
    pulseSynchronicity: { min: 0, max: 1, type: 'number', default: 0.3 },
    pulseRandomness: { min: 0, max: 1, type: 'number', default: 0.4 },
    pulseMinSteps: { min: 1, max: 3, type: 'integer', default: 1 },
    pulseMaxSteps: { min: 1, max: 5, type: 'integer', default: 3 },
    pulseOvershoot: { min: 1.0, max: 1.3, type: 'number', default: 1.08 },
    pulseBounceIntensity: { min: 0, max: 0.5, type: 'number', default: 0.15 },
    shadowOffsetX: { min: -20, max: 20, type: 'integer', default: 0 },
    shadowOffsetY: { min: -20, max: 20, type: 'integer', default: 4 },
    shadowBlur: { min: 0, max: 30, type: 'integer', default: 12 },
    shadowOpacity: { min: 0, max: 1, type: 'number', default: 0.15 },
    shadow2Blur: { min: 0, max: 20, type: 'integer', default: 4 },
    shadow2Opacity: { min: 0, max: 1, type: 'number', default: 0.10 }
  };
  
  /**
   * Validate and clamp configuration value
   * @param {string} key - Configuration parameter name
   * @param {*} value - Value to validate
   * @returns {*} Validated and clamped value
   */
  function validateConfigValue(key, value) {
    const schema = CONFIG_SCHEMA[key];
    if (!schema) return value; // Unknown key, pass through
    
    let validated = value;
    
    // Type conversion
    if (schema.type === 'integer') {
      validated = Math.round(Number(validated));
      if (!Number.isFinite(validated)) {
        console.warn(`${key} must be a number, using default ${schema.default}`);
        return schema.default;
      }
    } else if (schema.type === 'number') {
      validated = Number(validated);
      if (!Number.isFinite(validated)) {
        console.warn(`${key} must be a number, using default ${schema.default}`);
        return schema.default;
      }
    }
    
    // Range validation
    if (schema.min !== undefined && validated < schema.min) {
      console.warn(`${key} (${validated}) below minimum (${schema.min}), clamping`);
      validated = schema.min;
    }
    
    if (schema.max !== undefined && validated > schema.max) {
      console.warn(`${key} (${validated}) above maximum (${schema.max}), clamping`);
      validated = schema.max;
    }
    
    return validated;
  }
  
  // Constants for magic numbers
  const CONSTANTS = {
    CANVAS_HEIGHT_VH_PIT: 1.5,    // 150vh for Ball Pit (spawning above viewport)
    CANVAS_HEIGHT_VH_DEFAULT: 1.0, // 100vh for other modes
    OFFSCREEN_MOUSE: -1e9,        // Offscreen mouse position
    MIN_DISTANCE_EPSILON: 1e-6,   // Minimum distance for collision calculations
    MIN_REPEL_DISTANCE: 1e-4,     // Minimum repeller distance
    ACCUMULATOR_RESET_THRESHOLD: 3, // Reset accumulator if behind by this many frames
    INITIAL_SEED_BALLS: 200,      // Initial balls to seed
    BALL_SPAWN_OFFSET: 2,         // Offset for ball spawning
    BALL_CLUSTER_SPACING: 8,      // Spacing between clustered balls
    BALL_CLUSTER_Y_OFFSET: 12,    // Y offset for clustered balls
    MAX_PHYSICS_STEPS: 2,         // Maximum physics steps per frame
    FPS_UPDATE_INTERVAL: 1.0,     // FPS counter update interval in seconds
    // Spin & squash tuning
    SPIN_DAMP_PER_S: 2.0,         // angular damping per second
    SPIN_GAIN: 0.25,              // how strongly tangential slip converts to spin
    SPIN_GAIN_TANGENT: 0.18,      // ball–ball tangential slip to spin
    ROLL_FRICTION_PER_S: 1.5,     // rolling friction for horizontal speed per second when grounded
    SQUASH_MAX_BASE: 0.20,        // base maximum squash at softness=40 (moderate)
    SQUASH_DECAY_PER_S: 18.0,     // faster relaxation for snappy feel
    WALL_REST_VEL_THRESHOLD: 70,  // below this, wall bounce becomes inelastic (settles)
    GROUND_COUPLING_PER_S: 8.0    // match roll (vx) to spin (omega) when grounded
  };
  
  // Dynamic squash calculation based on ball softness (0-100)
  // 0 = completely hard (no deformation)
  // 40 = normal/default (0.20 squash)
  // 100 = very squishy (0.50 squash)
  function getSquashMax() {
    if (ballSoftness === 0) return 0; // Completely hard - no squash
    // Linear interpolation: softness 40 = base value (0.20)
    // softness 100 = 2.5× base (0.50)
    return CONSTANTS.SQUASH_MAX_BASE * (ballSoftness / 40.0);
  }

  const canvas = document.getElementById('c');
  const container = document.getElementById('bravia-balls');
  
  // Validate canvas context availability
  let ctx;
  try {
    ctx = canvas.getContext('2d', { alpha: true });
    if (!ctx) {
      throw new Error('Canvas 2D context not available');
    }
  } catch (error) {
    console.error('❌ Failed to initialize canvas:', error);
    container.innerHTML = `
      <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #1a1a1a; color: white; font-family: system-ui, -apple-system, sans-serif;">
        <div style="text-align: center; padding: 40px; background: rgba(255,50,50,0.1); border: 2px solid rgba(255,50,50,0.3); border-radius: 12px; max-width: 480px;">
          <div style="font-size: 72px; margin-bottom: 20px; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));">⚠️</div>
          <h2 style="margin: 0 0 16px 0; font-size: 24px; font-weight: 600;">Canvas Not Supported</h2>
          <p style="margin: 0 0 12px 0; opacity: 0.9; line-height: 1.6; font-size: 15px;">Your browser doesn't support the HTML5 Canvas 2D features required for this interactive simulation.</p>
          <p style="margin: 0; opacity: 0.7; font-size: 13px;">Please try a modern browser like Chrome, Firefox, Safari, or Edge.</p>
        </div>
      </div>
    `;
    throw error; // Stop execution
  }
  
  const panel = document.getElementById('controlPanel');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  
  /**
   * Update canvas drop-shadow filter based on current shadow settings
   * @description Applies CSS filter to canvas element with dynamic shadow parameters
   * @returns {void}
   */
  function updateCanvasShadow() {
    if (!canvasShadowEnabled) {
      canvas.style.filter = 'none';
      return;
    }
    
    // Parse shadow color to rgba with opacity
    const hexToRgba = (hex, opacity) => {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    };
    
    const shadow1 = `drop-shadow(${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${hexToRgba(shadowColor, shadowOpacity)})`;
    const shadow2 = shadow2Enabled 
      ? ` drop-shadow(${shadowOffsetX}px ${Math.round(shadowOffsetY * 0.5)}px ${shadow2Blur}px ${hexToRgba(shadowColor, shadow2Opacity)})`
      : '';
    
    canvas.style.filter = shadow1 + shadow2;
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // CANVAS 2D RENDERING (Primary rendering path)
  // ═══════════════════════════════════════════════════════════════════════════
  
  // Performance monitoring
  let frameCount = 0;
  let lastFPSCheck = 0;
  let currentFPS = 60;
  
  // ═══════════════════════════════════════════════════════════════════════════
  // 120 FPS PERFORMANCE MODE SYSTEM
  // ═══════════════════════════════════════════════════════════════════════════
  let performanceMode = false;        // 120 FPS performance mode toggle
  let targetFPS = 60;                 // Target FPS (60 normal, 120 performance)
  let fpsCheckInterval = 0.5;         // Check FPS every 500ms in performance mode
  
  // ═══════════════════════════════════════════════════════════════════════════
  // INITIALIZATION STATE MACHINE (Robust Dark Mode System)
  // ═══════════════════════════════════════════════════════════════════════════
  // State: INITIALIZING → DETERMINING_MODE → LOADING_COLORS → READY → RUNNING
  
  const INIT_STATES = {
    INITIALIZING: 'initializing',
    DETERMINING_MODE: 'determining_mode',
    LOADING_COLORS: 'loading_colors',
    READY: 'ready',
    RUNNING: 'running'
  };
  
  let initState = INIT_STATES.INITIALIZING;
  let autoDarkModeEnabled = true;     // Auto dark mode based on time of day
  let isDarkMode = false;             // Current dark mode state
  const SUNSET_HOUR = 18;             // 6 PM
  const SUNRISE_HOUR = 6;             // 6 AM
  
  /**
   * Synchronously determine if it's night time
   * @returns {boolean} True if between SUNSET_HOUR and SUNRISE_HOUR
   */
  function isNightTime() {
    const now = new Date();
    const hour = now.getHours();
    const isNight = hour >= SUNSET_HOUR || hour < SUNRISE_HOUR;
    console.log(`🌍 Time check: ${hour}:${now.getMinutes().toString().padStart(2,'0')} → ${isNight ? 'Night' : 'Day'} (sunset: ${SUNSET_HOUR}, sunrise: ${SUNRISE_HOUR})`);
    return isNight;
  }
  
  /**
   * Determine dark mode state BEFORE any initialization
   * BLOCKING: This must complete before color loading
   * @returns {boolean} The determined dark mode state
   */
  function determineDarkMode() {
    console.log('🔍 STATE: DETERMINING_MODE');
    initState = INIT_STATES.DETERMINING_MODE;
    
    if (!autoDarkModeEnabled) {
      console.log('✓ Dark mode disabled by user → Light mode');
      return false;
    }
    
    const shouldBeDark = isNightTime();
    console.log(`✓ Dark mode determination complete → ${shouldBeDark ? 'DARK' : 'LIGHT'} mode`);
    return shouldBeDark;
  }
  
  /**
   * Apply or remove dark mode styling and update color palette
   * @description Only modifies #bravia-balls container, not entire page (Webflow-safe)
   * @param {boolean} enabled - Whether to enable dark mode
   * @returns {void}
   */
  function applyDarkMode(enabled) {
    isDarkMode = enabled;
    
    // Only modify the simulation container (not entire page)
    if (enabled) {
      container.classList.add('dark-mode');
    } else {
      container.classList.remove('dark-mode');
    }
    
    // Switch to appropriate color palette (light or dark variant)
    applyColorTemplate(currentTemplate);
    
    updateDarkModeUI();
  }
  
  /**
   * Check current time and apply dark mode if between sunset and sunrise
   * @description Only applies dark mode if autoDarkModeEnabled is true
   * @returns {void}
   * @modifies {isDarkMode, html.classList, body.classList}
   */
  function checkAndApplyDarkMode() {
    if (autoDarkModeEnabled) {
      applyDarkMode(isNightTime());
    }
  }
  
  function updateDarkModeUI() {
    const toggle = document.getElementById('darkModeToggle');
    const status = document.getElementById('darkModeStatus');
    
    if (toggle) toggle.checked = autoDarkModeEnabled;
    
    if (status) {
      const now = new Date();
      const hour = now.getHours();
      const timeStr = `${hour.toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
      
      if (isDarkMode) {
        status.textContent = `🌙 Night Mode (${timeStr})`;
        status.style.background = 'rgba(100,100,255,0.3)';
      } else {
        status.textContent = `☀️ Day Mode (${timeStr})`;
        status.style.background = 'rgba(255,200,0,0.3)';
      }
    }
  }
  
  function toggleAutoDarkMode() {
    autoDarkModeEnabled = !autoDarkModeEnabled;
    
    if (autoDarkModeEnabled) {
      checkAndApplyDarkMode();
      console.log('🌙 Auto Dark Mode: ENABLED');
    } else {
      applyDarkMode(false); // Always use light mode when auto is off
      console.log('☀️ Auto Dark Mode: DISABLED');
    }
  }
  
  // Performance mode settings (aggressive optimizations for 120 FPS)
  const PERFORMANCE_SETTINGS = {
    normal: {
      maxBalls: 350,
      collisionIters: 2,
      adaptiveQualityMin: 0.5
    },
    performance: {
      maxBalls: 200,              // Reduce ball count
      collisionIters: 1,          // Reduce collision iterations
      adaptiveQualityMin: 0.3     // More aggressive quality reduction
    }
  };
  
  // Canvas 2D performance optimizations
  let enableLOD = true;               // Level of Detail system
  
  function updateAdaptiveQuality() {
    frameCount++;
    const now = performance.now();
    
    const checkInterval = performanceMode ? (fpsCheckInterval * 1000) : 1000;
    
    if (now - lastFPSCheck >= checkInterval) {
      currentFPS = frameCount * (1000 / checkInterval); // Adjust for check interval
      frameCount = 0;
      lastFPSCheck = now;
      
      // Performance mode: aggressive FPS management
      if (performanceMode) {
        if (currentFPS < targetFPS) {
          // Aggressively reduce quality and settings
          adaptiveQuality = Math.max(PERFORMANCE_SETTINGS.performance.adaptiveQualityMin, adaptiveQuality - 0.2);
          
          // Auto-reduce ball count if FPS still low
          if (currentFPS < targetFPS * 0.8 && balls.length > 100) {
            const reduceBy = Math.min(20, balls.length - 100);
            balls.length -= reduceBy;
            console.log(`⚡ Performance mode: Reduced balls by ${reduceBy} (now ${balls.length})`);
          }
          
        } else if (currentFPS > targetFPS * 1.1) {
          // Gradually restore quality when FPS is good
          adaptiveQuality = Math.min(1.0, adaptiveQuality + 0.1);
        }
      } else {
        // Normal mode: standard adaptive quality
        if (currentFPS < 45) {
          adaptiveQuality = Math.max(0.3, adaptiveQuality - 0.1);
        } else if (currentFPS > 55) {
          adaptiveQuality = Math.min(1.0, adaptiveQuality + 0.05);
        }
      }
      
      const mode = performanceMode ? 'PERF' : 'NORM';
      console.log(`🎮 ${mode} FPS: ${currentFPS}/${targetFPS}, Balls: ${balls.length}`);
    }
  }
  
  function togglePerformanceMode() {
    performanceMode = !performanceMode;
    targetFPS = performanceMode ? 120 : 60;
    
    const settings = performanceMode ? PERFORMANCE_SETTINGS.performance : PERFORMANCE_SETTINGS.normal;
    
    // Apply performance settings
    if (performanceMode) {
      console.log('⚡ PERFORMANCE MODE: Optimizing for 120 FPS...');
      
      // Reduce ball count if above limit
      if (balls.length > settings.maxBalls) {
        balls.length = settings.maxBalls;
        console.log(`⚡ Reduced balls to ${settings.maxBalls} for 120 FPS`);
      }
      
      // Update MAX_BALLS for new spawns
      MAX_BALLS = settings.maxBalls;
      
      // Reduce collision iterations
      currentCollisionIters = settings.collisionIters;
      
    } else {
      console.log('🎨 NORMAL MODE: Restoring visual quality...');
      
      // Restore normal settings
      MAX_BALLS = settings.maxBalls;
      currentCollisionIters = settings.collisionIters;
    }
    
    // Update UI
    updatePerformanceModeUI();
    
    console.log(`🎯 Target FPS: ${targetFPS}, Mode: ${performanceMode ? 'PERFORMANCE' : 'NORMAL'}`);
  }
  
  function updatePerformanceModeUI() {
    const toggle = document.getElementById('performanceModeToggle');
    const status = document.getElementById('performanceModeStatus');
    const maxBallsSlider = document.getElementById('maxBallsSlider');
    const maxBallsVal = document.getElementById('maxBallsVal');
    
    if (toggle) toggle.checked = performanceMode;
    
    if (status) {
      if (performanceMode) {
        status.textContent = `⚡ 120 FPS Mode Active (${balls.length} balls)`;
        status.style.background = 'rgba(255,165,0,0.3)';
      } else {
        status.textContent = `🎨 Normal Mode (${balls.length} balls)`;
        status.style.background = 'rgba(0,0,0,0.2)';
      }
    }
    
    // Update max balls slider
    if (maxBallsSlider && maxBallsVal) {
      maxBallsSlider.value = MAX_BALLS;
      maxBallsVal.textContent = MAX_BALLS.toString();
    }
  }
  
  // Note: Mouse, cursor, device, and mode variables are defined elsewhere in the file

  // Spawn area controls (viewport-relative) - from config
  let SPAWN_X_CENTER_VW = 50;  // spawnX from config
  let SPAWN_Y_VH = -50;        // spawnY from config
  let SPAWN_W_VW = 100;        // spawnWidth from config
  let SPAWN_H_VH = 50;         // spawnHeight from config

  // Resize canvas based on current mode
  function resize() {
    // Ball Pit mode uses 150vh (spawning above viewport), others use 100vh
    const heightMultiplier = (currentMode === MODES.PIT) 
      ? CONSTANTS.CANVAS_HEIGHT_VH_PIT 
      : CONSTANTS.CANVAS_HEIGHT_VH_DEFAULT;
    const simHeight = window.innerHeight * heightMultiplier;
    canvas.width  = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(simHeight * DPR);
    
    // Recalculate grid dimensions and reposition balls if in Pulse Grid mode
    if (currentMode === MODES.PULSE_GRID) {
      calculateGridDimensions();
      // Reposition all balls to valid grid cells
      for (let i = 0; i < balls.length; i++) {
        const ball = balls[i];
        // Clamp grid position to new dimensions
        ball.gridX = Math.max(0, Math.min(gridCols - 1, ball.gridX));
        ball.gridY = Math.max(0, Math.min(gridRows - 1, ball.gridY));
        const pos = gridCellToPixel(ball.gridX, ball.gridY);
        ball.x = pos.x;
        ball.y = pos.y;
        ball.targetX = pos.x;
        ball.targetY = pos.y;
      }
    }
  }
  const setCSSSize = () => {
    // CSS size is handled by CSS classes (mode-pit gets 150vh, others 100svh)
  };
  
  // Debounced resize handler to prevent expensive operations on every pixel change
  let resizeTimeout;
  function handleResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      setCSSSize();
      resize();
      updateEffectiveScaleAndBallSizes();
      updateTextColliders();
    }, 150); // 150ms debounce
  }
  
  setCSSSize(); resize();
  window.addEventListener('resize', handleResize);

  // Physics parameters (from provided config)
  const GE = 1960;        // Earth gravity in px/s^2 at our scale
  let gravityMultiplier = 0; // Zero gravity (weightless mode)
  let G = GE * gravityMultiplier;
  let REST = 0.88;        // restitution from config
  let FRICTION = 0.003;   // air drag from config
  let EMIT_INTERVAL = 0.03; // seconds between drops from config
  let MAX_BALLS = 350;    // max balls from config
  const SOLVER_ITERS = 6;    // Optimized for realistic collisions without jitter
  const POS_CORRECT_PERCENT = 0.8; // Reduced for more stable contacts
  const POS_CORRECT_SLOP = 0.5 * DPR; // Slightly more tolerance to prevent jitter
  const REST_VEL_THRESHOLD = 30; // Lower threshold for more realistic settling

  // Base radius values
  const R_MIN_BASE = 6;
  const R_MAX_BASE = 24;
  let sizeScale = 0.7;     // Global ball size from config
  let sizeVariation = 0.15; // Global size variation from config (reduced from 1.0)
  // Responsive scale: reduce ball size by 60% on mobile breakpoints (≤768px)
  let responsiveScale = 1.0;
  let lastEffectiveScale = null; // tracks previous (sizeScale * responsiveScale)
  // Global mass model: all balls share the same mass in kg
  let ballMassKg = 19.8; // Mass from config (lighter than previous 120g)
  // Mass influence tuning
  const MASS_GRAVITY_EXP = 0.35; // how much mass influences gravity (perceptual)
  const MASS_REST_EXP = 0.15;    // how much mass influences bounce restitution
  let gravityScale = 1.0;        // computed from mass
  function recomputeMassDerivedScales() {
    gravityScale = Math.max(0.5, Math.min(3.0, Math.pow(ballMassKg / MASS_BASELINE_KG, MASS_GRAVITY_EXP)));
  }
  recomputeMassDerivedScales();
  let R_MIN = R_MIN_BASE * sizeScale;
  let R_MAX = R_MAX_BASE * sizeScale;

  function computeResponsiveScale() {
    // Use canvas container width for proper embed behavior
    const containerWidth = canvas.clientWidth || window.innerWidth;
    return (containerWidth <= 768) ? 0.4 : 1.0;
  }

  // Recomputes the effective pixel radius from global size and responsiveness,
  // then proportionally rescales existing balls so the scene updates smoothly.
  function updateEffectiveScaleAndBallSizes() {
    responsiveScale = computeResponsiveScale();
    const effectiveScale = sizeScale * responsiveScale;
    if (lastEffectiveScale === null) {
      lastEffectiveScale = effectiveScale;
      R_MIN = R_MIN_BASE * effectiveScale;
      R_MAX = R_MAX_BASE * effectiveScale;
      return;
    }
    const ratio = effectiveScale / lastEffectiveScale;
    if (ratio !== 1) {
      for (let i = 0; i < balls.length; i++) {
        balls[i].r *= ratio;
      }
      lastEffectiveScale = effectiveScale;
    }
    R_MIN = R_MIN_BASE * effectiveScale;
    R_MAX = R_MAX_BASE * effectiveScale;
  }

  // Update text collision rectangles by measuring DOM elements
  function updateTextColliders() {
    textColliders = []; // Clear existing colliders
    
    const textElement = document.querySelector(TEXT_SELECTOR);
    if (!textElement) return; // No text element found
    
    const textRect = textElement.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    
    // Calculate cap height (height of capital letters only)
    const capHeight = calculateCapHeight(textElement);
    
    // Center the collision box vertically on the visual text
    const heightDifference = textRect.height - capHeight;
    const verticalOffset = heightDifference * 0.5; // Center the cap height within the full text height
    
    // Convert to canvas coordinates with device pixel ratio
    const collider = {
      x: (textRect.left - canvasRect.left) * DPR,
      y: (textRect.top - canvasRect.top + verticalOffset) * DPR,
      width: textRect.width * DPR,
      height: capHeight * DPR
    };
    
    // Only add collider if it's within canvas bounds and has valid dimensions
    if (collider.width > 0 && collider.height > 0 && 
        collider.x < canvas.width && collider.y < canvas.height &&
        collider.x + collider.width > 0 && collider.y + collider.height > 0) {
      textColliders.push(collider);
    }
  }
  
  // Calculate the cap height of text element (height of capital letters)
  function calculateCapHeight(element) {
    // Create a temporary element with just capital letters to measure cap height
    const tempElement = document.createElement('span');
    tempElement.style.cssText = window.getComputedStyle(element).cssText;
    tempElement.style.position = 'absolute';
    tempElement.style.visibility = 'hidden';
    tempElement.style.whiteSpace = 'nowrap';
    tempElement.textContent = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    
    document.body.appendChild(tempElement);
    const capHeight = tempElement.getBoundingClientRect().height;
    document.body.removeChild(tempElement);
    
    return capHeight;
  }

  // Emitter sweep (natural hand-like motion across the top band)
  let EMITTER_SWEEP_ENABLED = false; // Disabled per config
  let emitterPhase = 0;                 // radians
  const EMITTER_SWEEP_HZ = 0.12;        // cycles per second
  const EMITTER_SWEEP_AMPL_VW = 20;     // sweep amplitude in vw
  let emitterSweepDir = 1;              // +1 sweeping right, -1 sweeping left (derived)

  // 8-Color system with weighted distribution (50%, 25%, 12%, 6%, 3%, 2%, 1%, 1%)
  // Color 1 (50%): Dominant/background color
  // Color 2 (25%): Secondary color  
  // Color 3 (15%): Tertiary color
  // Color 4 (7.5%): Accent color
  // Color 5 (2.5%): Rare/special color
  
  // Dual palette system: each theme has light and dark variants
  const COLOR_TEMPLATES = {
    // CORE PALETTE - User's favorite (don't change)
    industrialTeal: { 
      label: 'Industrial Teal',
      light: ['#b7bcb7', '#e4e9e4', '#ffffff', '#00695c', '#000000', '#ff4013', '#0d5cb6', '#ffa000'],
      dark: ['#2a2a2a', '#1a1a1a', '#404040', '#00a88f', '#e0e0e0', '#ff6b47', '#3b7de0', '#ffc04d']
      // Dark mode: Darker grays (similar to bg), brighter hero/accents for visibility
    },
    
    // NEW PALETTES - Designed to match Industrial Teal's playful graphic design energy
    // Each has: neutral grays + bold hero color + high contrast + 3 vibrant accents
    
    sunsetCoral: { 
      label: 'Sunset Coral', 
      light: ['#bdbbb8', '#e8e6e3', '#ffffff', '#ff3b3b', '#000000', '#00f5d4', '#1e40af', '#fb923c'],
      dark: ['#2b2a28', '#1c1b1a', '#3d3d3d', '#ff5c5c', '#dddddd', '#00ffe7', '#4169e1', '#ffa866']
      // Dark: Warm dark grays, bright coral + cyan + orange for visibility
    },
    
    violetPunch: { 
      label: 'Violet Punch', 
      light: ['#b8b7c2', '#e6e5ed', '#ffffff', '#9333ea', '#000000', '#dc2626', '#0ea5e9', '#facc15'],
      dark: ['#2a2832', '#1a1921', '#3e3d47', '#b24dff', '#e0e0e0', '#ff4444', '#00d4ff', '#ffe34d']
      // Dark: Cool dark grays with purple tint, vivid purple + electric accents
    },
    
    citrusBlast: { 
      label: 'Citrus Blast', 
      light: ['#bfbdb5', '#eae8df', '#ffffff', '#ea580c', '#000000', '#e11d48', '#2563eb', '#059669'],
      dark: ['#2c2b27', '#1d1c19', '#3f3e3a', '#ff7733', '#dddddd', '#ff4466', '#4d8aff', '#00bf7f']
      // Dark: Warm dark grays, vibrant orange + pink + blue + green
    },
    
    cobaltSpark: { 
      label: 'Cobalt Spark', 
      light: ['#b5b8be', '#e3e6eb', '#ffffff', '#1d4ed8', '#000000', '#ea580c', '#db2777', '#d97706'],
      dark: ['#282b30', '#191c20', '#3d4147', '#4d7aff', '#dedede', '#ff7f3d', '#ff4d9e', '#ffad33']
      // Dark: Cool dark grays, bright cobalt + orange + magenta + gold
    }
  };

  let currentTemplate = 'industrialTeal';
  let currentColors = COLOR_TEMPLATES.industrialTeal.light.slice(); // 8 colors, light variant by default
  // Cursor color: default to Color 5 (highlight)
  let cursorBallIndex = 4;
  let cursorBallColor = currentColors[cursorBallIndex] || '#000000';
  
  /**
   * Get current color palette based on dark mode state
   * @param {string} templateName - Template name from COLOR_TEMPLATES
   * @returns {Array<string>} Array of 8 color hex codes
   */
  function getCurrentPalette(templateName) {
    const template = COLOR_TEMPLATES[templateName];
    if (!template) return COLOR_TEMPLATES.industrialTeal.light;
    return isDarkMode ? template.dark : template.light;
  }
  
  /**
   * Apply color palette and update all balls
   * @param {string} templateName - Template name to apply
   * @returns {void}
   */
  function applyColorTemplate(templateName) {
    currentTemplate = templateName;
    currentColors = getCurrentPalette(templateName);
    cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor;
    
    // Update existing ball colors
    updateExistingBallColors();
    
    // Sync CSS variables
    syncPaletteVars();
    
    // Update UI color pickers
    updateColorPickersUI();
  }

  // Expose palette as CSS variables for use by page elements
  function syncPaletteVars(colors = currentColors) {
    try {
      const root = document.documentElement;
      const list = (colors && colors.length ? colors : currentColors).slice(0, 8);
      for (let i = 0; i < 8; i++) {
        const hex = list[i] || '#ffffff';
        root.style.setProperty(`--ball-${i+1}`, hex);
      }
    } catch (_) { /* no-op */ }
  }

  // Color weights: Color 1: 50%, Color 2: 25%, Color 3: 15%, Color 4: 7.5%, Color 5: 2.5%
  const COLOR_WEIGHTS = [0.50, 0.25, 0.12, 0.06, 0.03, 0.02, 0.01, 0.01];
  
  function pickRandomColor() {
    try {
      if (!currentColors || currentColors.length === 0) {
        console.warn('No colors available, using fallback');
        return '#ffffff'; // Fallback color
      }
      
      // Use weighted random selection
      const random = Math.random();
      let cumulativeWeight = 0;
      
      for (let i = 0; i < Math.min(currentColors.length, COLOR_WEIGHTS.length); i++) {
        cumulativeWeight += COLOR_WEIGHTS[i];
        if (random <= cumulativeWeight) {
          return currentColors[i];
        }
      }
      
      // Fallback to last color if something goes wrong
      return currentColors[Math.min(currentColors.length - 1, 7)];
    } catch (error) {
      console.error('Error picking random color:', error);
      return '#ffffff'; // Fallback color
    }
  }

  // Repeller controls (from config)
  let repelRadius = 135;   // repelRadius from config
  let repelPower = 1536000;  // repelPower from config
  let repelSoft = 3.4;     // repelSoftness from config
  let mouseX = CONSTANTS.OFFSCREEN_MOUSE, mouseY = CONSTANTS.OFFSCREEN_MOUSE; // offscreen until moved
  let repellerEnabled = false; // disabled by default; enabled by preset or sliders
  const REPELLER_GLOBAL_MULTIPLIER = 20.0; // doubled overall repeller strength
  
  // Touch detection - cursor ball only shows on non-touch devices
  let isTouchDevice = false;
  // Check for touch support
  if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
    isTouchDevice = true;
  }
  
  // Hide modes that aren't available on this device
  // All 4 modes are available on all devices
  function applyDeviceSpecificModeVisibility() {
    // No device-specific mode hiding needed
  }
  
  // Settings persistence using localStorage
  const STORAGE_KEY = 'bouncyBallsSettings';
  
  /**
   * Persist current UI/simulation settings to localStorage
   * @description Saves all mode parameters, colors, and preferences for session persistence
   * @returns {void}
   * @throws {Error} If localStorage is unavailable or quota exceeded
   */
  function saveSettings() {
    const settings = {
      currentMode,
      gravityMultiplierPit,
      repellerEnabledPit,
      attractionPower,
      orbitRadius,
      swarmSpeed,
      weightlessInitialSpeed,
      weightlessBounce,
      weightlessCount,
      weightlessRepellerPower,
      weightlessRepellerRadius,
      restitution: REST,
      friction: FRICTION,
      sizeScale,
      sizeVariation,
      ballMassKg,
      ballSoftness,
      repelPower,
      repelRadius,
      repelSoft,
      cornerRadius,
      motionBlur: trailFade,
      trailSubtlety,
      currentTemplate,
      cursorBallColor,
      // Pulse Grid mode settings
      gridColumns,
      gridBallCount,
      pulseInterval,
      pulseSpeed,
      pulseSynchronicity,
      pulseRandomness,
      pulseMinSteps,
      pulseMaxSteps,
      pulseEasingStyle,
      pulseOvershoot,
      pulseBounceIntensity,
      // Canvas shadow settings
      canvasShadowEnabled,
      shadowOffsetX,
      shadowOffsetY,
      shadowBlur,
      shadowOpacity,
      shadowColor,
      shadow2Enabled,
      shadow2Blur,
      shadow2Opacity,
      // Dark mode settings
      autoDarkModeEnabled
    };
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      console.log('✓ Settings saved');
    } catch (e) {
      console.warn('Could not save settings:', e);
    }
  }
  
  /**
   * Load settings from localStorage and safely apply them
   * @description Each field is guarded to avoid clobbering defaults if missing
   * @returns {boolean} True if settings loaded successfully, false otherwise
   */
  function loadSettings() {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const settings = JSON.parse(saved);
        // Restore all settings
        if (settings.currentMode) currentMode = settings.currentMode;
        if (settings.gravityMultiplierPit !== undefined) gravityMultiplierPit = settings.gravityMultiplierPit;
        if (settings.repellerEnabledPit !== undefined) repellerEnabledPit = settings.repellerEnabledPit;
        if (settings.attractionPower) attractionPower = settings.attractionPower;
        if (settings.orbitRadius) orbitRadius = settings.orbitRadius;
        if (settings.swarmSpeed) swarmSpeed = settings.swarmSpeed;
        if (settings.weightlessInitialSpeed) weightlessInitialSpeed = settings.weightlessInitialSpeed;
        if (settings.weightlessBounce) weightlessBounce = settings.weightlessBounce;
        if (settings.weightlessCount) weightlessCount = settings.weightlessCount;
        if (settings.weightlessRepellerPower !== undefined) weightlessRepellerPower = settings.weightlessRepellerPower;
        if (settings.weightlessRepellerRadius !== undefined) weightlessRepellerRadius = settings.weightlessRepellerRadius;
        if (settings.restitution) REST = settings.restitution;
        if (settings.friction !== undefined) FRICTION = settings.friction;
        if (settings.sizeScale) sizeScale = settings.sizeScale;
        if (settings.sizeVariation !== undefined) sizeVariation = settings.sizeVariation;
        if (settings.ballMassKg) ballMassKg = settings.ballMassKg;
        if (settings.repelPower) repelPower = settings.repelPower;
        if (settings.repelRadius) repelRadius = settings.repelRadius;
        if (settings.repelSoft) repelSoft = settings.repelSoft;
        if (settings.cornerRadius !== undefined) cornerRadius = settings.cornerRadius;
        if (settings.motionBlur !== undefined) trailFade = settings.motionBlur;
        if (settings.trailSubtlety) trailSubtlety = settings.trailSubtlety;
        if (settings.currentTemplate) currentTemplate = settings.currentTemplate;
        if (settings.cursorBallColor) cursorBallColor = settings.cursorBallColor;
        // Pulse Grid mode settings
        if (settings.gridColumns !== undefined) gridColumns = settings.gridColumns;
        if (settings.gridBallCount !== undefined) gridBallCount = settings.gridBallCount;
        if (settings.pulseInterval !== undefined) pulseInterval = settings.pulseInterval;
        if (settings.pulseSpeed !== undefined) pulseSpeed = settings.pulseSpeed;
        if (settings.pulseSynchronicity !== undefined) pulseSynchronicity = settings.pulseSynchronicity;
        if (settings.pulseRandomness !== undefined) pulseRandomness = settings.pulseRandomness;
        if (settings.pulseMinSteps !== undefined) pulseMinSteps = settings.pulseMinSteps;
        if (settings.pulseMaxSteps !== undefined) pulseMaxSteps = settings.pulseMaxSteps;
        if (settings.pulseEasingStyle) pulseEasingStyle = settings.pulseEasingStyle;
        if (settings.pulseOvershoot !== undefined) pulseOvershoot = settings.pulseOvershoot;
        if (settings.pulseBounceIntensity !== undefined) pulseBounceIntensity = settings.pulseBounceIntensity;
        // Canvas shadow settings
        if (settings.canvasShadowEnabled !== undefined) canvasShadowEnabled = settings.canvasShadowEnabled;
        if (settings.shadowOffsetX !== undefined) shadowOffsetX = settings.shadowOffsetX;
        if (settings.shadowOffsetY !== undefined) shadowOffsetY = settings.shadowOffsetY;
        if (settings.shadowBlur !== undefined) shadowBlur = settings.shadowBlur;
        if (settings.shadowOpacity !== undefined) shadowOpacity = settings.shadowOpacity;
        if (settings.shadowColor) shadowColor = settings.shadowColor;
        if (settings.shadow2Enabled !== undefined) shadow2Enabled = settings.shadow2Enabled;
        if (settings.shadow2Blur !== undefined) shadow2Blur = settings.shadow2Blur;
        if (settings.shadow2Opacity !== undefined) shadow2Opacity = settings.shadow2Opacity;
        // Dark mode settings
        if (settings.autoDarkModeEnabled !== undefined) autoDarkModeEnabled = settings.autoDarkModeEnabled;
        
        console.log('✓ Settings loaded');
        return true;
      }
    } catch (e) {
      console.warn('Could not load settings:', e);
    }
    return false;
  }
  
  // Auto-save settings when sliders change
  function autoSaveSettings() {
    // Debounced save (wait 500ms after last change)
    clearTimeout(window.settingsSaveTimeout);
    window.settingsSaveTimeout = setTimeout(saveSettings, 500);
  }

  // Repeller slider mapping (wide dynamic range; midpoint equals 2× previous default)
  const REPEL_BASE_POWER = 12000; // previous default baseline
  const REPEL_SLIDER_MAX = 10000;  // slider range [0..10000]
  const REPEL_CENTER_MULTIPLIER = 2.0; // midpoint = 2× base
  const REPEL_N_OCTAVES = 12; // wide range (~1/32x .. 128x around center)
  function repelSliderToPower(sliderValue) {
    const s = Math.max(0, Math.min(REPEL_SLIDER_MAX, Number(sliderValue))) / REPEL_SLIDER_MAX;
    const mult = REPEL_CENTER_MULTIPLIER * Math.pow(2, (s - 0.5) * REPEL_N_OCTAVES);
    return REPEL_BASE_POWER * mult;
  }
  function powerToRepelSlider(power) {
    const safe = Math.max(1, Number(power));
    const x = safe / (REPEL_BASE_POWER * REPEL_CENTER_MULTIPLIER);
    const s = 0.5 + (Math.log2(x) / REPEL_N_OCTAVES);
    return Math.round(Math.max(0, Math.min(1, s)) * REPEL_SLIDER_MAX);
  }

  
  // High refresh mode is now default
  let highRefreshMode = true; // Always enabled for best performance
  
  // Rounded corners for simulation area
  let cornerRadius = 0; // Corner radius in pixels (0 = square corners)
  
  // Text collision system
  const TEXT_SELECTOR = '#hero-text'; // ID selector for the main text element
  let textColliders = []; // Array of text collision rectangles
  // Motion blur parameters
  let motionBlurFade = 0.025; // from config (trailFade)
  let trailSubtlety = 1.80; // from config
  
  // Performance optimizations and FPS tracking
  let renderFrameCount = 0;
  let physicsStepCount = 0;
  let lastFPSTime = 0;
  let currentRenderFPS = 0;
  let currentPhysicsFPS = 0;
  const renderFpsElement = document.getElementById('render-fps');
  const physicsFpsElement = document.getElementById('physics-fps');
  
  // Adaptive Quality System - automatically adjusts settings based on FPS
  let adaptiveQualityEnabled = true;     // Enable/disable adaptive quality
  let currentCollisionIters = 2;         // Dynamic collision iterations (1-3)
  let lastQualityCheck = 0;              // Last time quality was adjusted
  const QUALITY_CHECK_INTERVAL = 2.0;    // Check every 2 seconds
  
  function updateAdaptiveQuality(now) {
    if (!adaptiveQualityEnabled) return;
    if (now - lastQualityCheck < QUALITY_CHECK_INTERVAL) return;
    
    lastQualityCheck = now;
    
    // Adjust collision iterations based on FPS
    if (currentRenderFPS < 50) {
      // Critical: reduce to 1 iteration
      currentCollisionIters = 1;
      console.log('⚡ Adaptive Quality: LOW (1 collision iter) - FPS:', currentRenderFPS);
    } else if (currentRenderFPS < 70) {
      // Medium: keep at 2 iterations
      currentCollisionIters = 2;
      console.log('⚡ Adaptive Quality: MEDIUM (2 collision iters) - FPS:', currentRenderFPS);
    } else {
      // High: can afford 3 iterations
      currentCollisionIters = 3;
      console.log('⚡ Adaptive Quality: HIGH (3 collision iters) - FPS:', currentRenderFPS);
    }
  }

  // Ball model - updated to remove 3D rendering
  class Ball {
    constructor(x, y, r, color) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random()*2 - 1) * 200; // random lateral kick
      this.vy = -Math.random()*200;          // slight upward variation
      this.r = r;
      this.rBase = r;                         // Store original radius for scaling
      this.m = ballMassKg;                    // all balls share the same mass
      this.color = color;
      this.t = 0;
      // Entry drift state for natural side-throw effect
      this.age = 0;           // seconds since spawn
      this.driftAx = 0;       // lateral acceleration during entry (px/s^2)
      this.driftTime = 0;     // duration of entry drift (s)
      // Spin & squash state
      this.omega = 0;         // angular velocity (rad/s)
      this.squash = 1.0;      // visual squash factor (1 = round)
      this.squashDirX = 1;    // squash direction components (unit vector)
      this.squashDirY = 0;
      // Improved rotation & world-aligned squash
      this.theta = 0;               // integrated angular position (rad)
      this.squashAmount = 0.0;      // 0 = no squash, up to SQUASH_MAX
      this.squashNormalAngle = 0.0; // world-space normal direction for squash
      // Trail mode alpha transparency
      this.alpha = 1.0;       // 1 = opaque, 0 = transparent
    }
    // Integrate motion with simple Euler step
    step(dt) {
      // Advance timers
        this.t += dt;
      this.age += dt;

      // Gravity scaled by mass to make weight perceptible without changing G globally
      // BUT: Zero-G mode has NO gravity or drag (space physics)
      if (currentMode !== MODES.WEIGHTLESS) {
      this.vy += (G * gravityScale) * dt;
      }
      
      // Mass-aware drag (heavier balls lose proportionally less velocity)
      // BUT: Zero-G mode has MINIMAL drag (vacuum of space)
      const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
      const dragAmount = (currentMode === MODES.WEIGHTLESS) ? 0.0001 : FRICTION; // Almost zero in zero-g
      const drag = Math.max(0, 1 - (dragAmount / massScale));
      this.vx *= drag;
      this.vy *= drag;
      // Apply short-lived lateral drift to simulate being thrown from the side above
      if (this.driftAx !== 0 && this.age < this.driftTime) {
        this.vx += (this.driftAx * dt) / massScale;
      } else if (this.driftAx !== 0) {
        this.driftAx = 0; // Clear drift when expired to skip future checks
      }
      applyExternalForces(this, dt);
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      // Angular damping
      const spinDamp = Math.max(0, 1 - CONSTANTS.SPIN_DAMP_PER_S * dt);
      this.omega *= spinDamp;
      // Integrate angular position for visible rotation
      this.theta += this.omega * dt;
      if (this.theta > Math.PI) this.theta -= Math.PI * 2; else if (this.theta < -Math.PI) this.theta += Math.PI * 2;
      // Relax squash amount back to 0 (area-preserving)
      const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
      this.squashAmount += (0 - this.squashAmount) * decay;
      this.squash = 1 - this.squashAmount;
    }
    // Resolve collision with walls (with rounded corners)
    walls(w, h, dt, customRest = REST) {
      // Use custom restitution if provided (for mode-specific bounce behavior)
      const rest = customRest;
      if (cornerRadius === 0) {
        // Standard rectangular collision
      if (this.y + this.r > h) { 
        this.y = h - this.r; 
        // Pre-impact speed for squash amplitude
        const preVy = this.vy;
        // Rolling friction & spin from tangential slip
        const slip = this.vx - this.omega * this.r; // world x is tangential at bottom contact
        const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
        // convert part of slip to spin, reduce horizontal speed (rolling tendency)
        this.omega += (slip / this.r) * CONSTANTS.SPIN_GAIN / massScale;
        const rollDamp = Math.max(0, 1 - CONSTANTS.ROLL_FRICTION_PER_S * dt / massScale);
        this.vx *= rollDamp;
        // Bounce with mass-aware restitution
        const wallRest = Math.abs(preVy) < CONSTANTS.WALL_REST_VEL_THRESHOLD ? 0 : rest;
        this.vy = -this.vy * (wallRest * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash on impact using pre-impact speed
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = -Math.PI / 2; // ground normal upwards
        // Ground coupling: tend towards pure rolling without slipping
        const rollTarget = this.vx / this.r;
        this.omega += (rollTarget - this.omega) * Math.min(1, CONSTANTS.GROUND_COUPLING_PER_S * dt);
      }
      // Top wall collision aligned to the visible viewport top
      // Ball Pit: 150vh canvas, so viewport top is at h/3
      // Other modes: 100vh canvas, so viewport top is at 0
      const viewportTop = (currentMode === MODES.PIT) ? (h / 3) : 0;
      if (this.y - this.r < viewportTop) { 
        this.y = viewportTop + this.r; 
        const preVy = this.vy;
        this.vy = -this.vy * rest; 
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI / 2; // ceiling normal downwards
      }
      if (this.x + this.r > w) { 
        this.x = w - this.r; 
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * rest; 
        const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // right wall normal leftwards
      }
        if (this.x - this.r < 0) { 
          this.x = this.r; 
          {
            const slip = this.vy - this.omega * this.r;
            const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
            this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
          }
          this.vx = -this.vx * rest; 
          const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
          this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
          this.squash = 1 - this.squashAmount;
          this.squashNormalAngle = 0; // left wall normal rightwards
        }
      } else {
        // Rounded corner collision detection
        this.handleRoundedWallCollision(w, h);
      }
      
      // Text collision detection
      this.checkTextCollisions(dt);
    }
    
    // Check collision with text elements
    checkTextCollisions(dt) {
      for (let i = 0; i < textColliders.length; i++) {
        const rect = textColliders[i];
        
        // Check if ball overlaps with text rectangle
        const closestX = Math.max(rect.x, Math.min(this.x, rect.x + rect.width));
        const closestY = Math.max(rect.y, Math.min(this.y, rect.y + rect.height));
        
        const dx = this.x - closestX;
        const dy = this.y - closestY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < this.r) {
          // Collision detected - resolve it
          if (distance === 0) {
            // Ball center is inside rectangle - push out in shortest direction
            const distToLeft = this.x - rect.x;
            const distToRight = (rect.x + rect.width) - this.x;
            const distToTop = this.y - rect.y;
            const distToBottom = (rect.y + rect.height) - this.y;
            
            const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
            
            if (minDist === distToLeft) {
              this.x = rect.x - this.r;
              this.vx = -Math.abs(this.vx) * REST;
            } else if (minDist === distToRight) {
              this.x = rect.x + rect.width + this.r;
              this.vx = Math.abs(this.vx) * REST;
            } else if (minDist === distToTop) {
              this.y = rect.y - this.r;
              this.vy = -Math.abs(this.vy) * REST;
            } else {
              this.y = rect.y + rect.height + this.r;
              this.vy = Math.abs(this.vy) * REST;
            }
          } else {
            // Normal collision resolution
            const overlap = this.r - distance;
            const nx = dx / distance;
            const ny = dy / distance;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity with restitution
            const dotProduct = this.vx * nx + this.vy * ny;
            if (dotProduct < 0) {
              this.vx -= 2 * dotProduct * nx * REST;
              this.vy -= 2 * dotProduct * ny * REST;
              
              // Add squash effect for visual impact
              const impact = Math.min(1, Math.abs(dotProduct) / (this.r * 70));
              this.squash = 1 - getSquashMax() * impact;
              this.squashDirX = Math.abs(nx) > Math.abs(ny) ? 1 : 0;
              this.squashDirY = Math.abs(ny) > Math.abs(nx) ? 1 : 0;
            }
          }
        }
      }
    }
    
    // Handle collision with rounded corner boundaries
    handleRoundedWallCollision(w, h) {
      const r = cornerRadius;
      
      // Check collision with each corner circle
      const corners = [
        { x: r, y: r },           // Top-left
        { x: w - r, y: r },       // Top-right
        { x: w - r, y: h - r },   // Bottom-right
        { x: r, y: h - r }        // Bottom-left
      ];
      
      for (let i = 0; i < corners.length; i++) {
        const corner = corners[i];
        const dx = this.x - corner.x;
        const dy = this.y - corner.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Check if ball is in corner region and colliding with corner circle
        const inCornerRegion = this.isInCornerRegion(corner, w, h, r);
        if (inCornerRegion && dist + this.r > r) {
          // Collision with corner circle
          const overlap = r - (dist - this.r);
          if (overlap > 0 && dist > 0) {
            const nx = dx / dist;
            const ny = dy / dist;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity
            const dot = this.vx * nx + this.vy * ny;
            this.vx -= 2 * dot * nx * REST;
            this.vy -= 2 * dot * ny * REST;
            // Squash aligned to corner normal, proportional to impact
            const impact = Math.min(1, Math.abs(dot) / (this.r * 90));
            this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
            this.squash = 1 - this.squashAmount;
            this.squashNormalAngle = Math.atan2(ny, nx);
          }
        }
      }
      
      // Handle straight wall collisions (outside corner regions)
      // Bottom wall
      if (this.y + this.r > h && (this.x < r || this.x > w - r)) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      
      // Top wall
      if (this.y - this.r < 0 && (this.x < r || this.x > w - r)) {
        this.y = this.r;
        this.vy = -this.vy * REST;
      }
      
      // Right wall
      if (this.x + this.r > w && (this.y < r || this.y > h - r)) {
        this.x = w - this.r;
        // Wall contact: add spin from tangential slip (vertical normal)
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash aligned to wall normal
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(getSquashMax(), impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // normal leftwards
      }
      
      // Left wall
      if (this.x - this.r < 0 && (this.y < r || this.y > h - r)) {
        this.x = this.r;
        {
          const slip = this.vy - this.omega * this.r;
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(getSquashMax(), impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = 0; // normal rightwards
      }
      
      // Handle straight sections of walls
      if (this.y + this.r > h && this.x >= r && this.x <= w - r) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.y - this.r < 0 && this.x >= r && this.x <= w - r) {
        this.y = this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x + this.r > w && this.y >= r && this.y <= h - r) {
        this.x = w - this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x - this.r < 0 && this.y >= r && this.y <= h - r) {
        this.x = this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
    }
    
    // Check if ball is in a corner region
    isInCornerRegion(corner, w, h, r) {
      // Top-left corner
      if (corner.x === r && corner.y === r) {
        return this.x <= r && this.y <= r;
      }
      // Top-right corner
      if (corner.x === w - r && corner.y === r) {
        return this.x >= w - r && this.y <= r;
      }
      // Bottom-right corner
      if (corner.x === w - r && corner.y === h - r) {
        return this.x >= w - r && this.y >= h - r;
      }
      // Bottom-left corner
      if (corner.x === r && corner.y === h - r) {
        return this.x <= r && this.y >= h - r;
      }
      return false;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);

      // World-aligned squash/stretch only for larger balls (performance optimization)
      // Small balls (<15px radius) don't show visible squash, so skip expensive transforms
        const amt = Math.min(getSquashMax(), Math.max(0, this.squashAmount));
      if (this.r > 15 && amt > 0.001) {
        // Area-preserving squash: s * (1/s) maintains roundness perception
        const s = 1 + amt;
        const inv = 1 / s;
        ctx.rotate(this.squashNormalAngle);
        ctx.scale(s, inv);
        ctx.rotate(-this.squashNormalAngle);
      }
      
      // Draw main ball first
        ctx.beginPath();
        ctx.arc(0, 0, this.r, 0, Math.PI*2);
        ctx.fillStyle = this.color;
        ctx.fill();

      ctx.restore();
    }
  }

  const balls = [];

  // Helpers
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function randBetween(a, b) { return a + Math.random() * (b - a); }
  // Compute mass from radius using current weight slider as density baseline
  // Removed radius-based mass; shared mass is used instead
  
  // Draw rounded boundary visualization
  function drawRoundedBoundary(ctx, w, h) {
    const r = cornerRadius;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    // Start from top-left corner (after the curve)
    ctx.moveTo(r, 0);
    
    // Top edge
    ctx.lineTo(w - r, 0);
    
    // Top-right corner
    ctx.arcTo(w, 0, w, r, r);
    
    // Right edge
    ctx.lineTo(w, h - r);
    
    // Bottom-right corner
    ctx.arcTo(w, h, w - r, h, r);
    
    // Bottom edge
    ctx.lineTo(r, h);
    
    // Bottom-left corner
    ctx.arcTo(0, h, 0, h - r, r);
    
    // Left edge
    ctx.lineTo(0, r);
    
    // Top-left corner
    ctx.arcTo(0, 0, r, 0, r);
    
    ctx.closePath();
    ctx.stroke();
  }
  
  function spawnBall(x, y, color = pickRandomColor()) {
    // Calculate size range with variation (ensure positive values)
    const baseSize = (R_MIN + R_MAX) / 2;
    
    let r;
    if (sizeVariation === 0) {
      // No variation: all balls exactly the same size
      r = baseSize;
    } else {
      // Apply limited variation (max 10% from global ball size)
      const maxVariation = baseSize * 0.1; // 10% of global ball size
      const minR = Math.max(1, baseSize - maxVariation);
      const maxR = baseSize + maxVariation;
      r = randBetween(minR, maxR);
    }
    
    const ball = new Ball(x, y, r, color);

    // Natural entry throw with size-aware impulse and sweep-aware direction
    const centerX = canvas.width * 0.5;
    // Prefer current sweep direction if enabled; otherwise side-based
    const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((x < centerX) ? 1 : -1);
    const sizeInfluence = clamp((r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
    const baseKick = 140 * sizeInfluence;  // scale with size
    const randKick = 180 * sizeInfluence;  // scale with size
    const upwardKick = 120;                // small upward speed to soften entry
    ball.vx = dir * (baseKick + Math.random() * randKick);
    ball.vy = -Math.random() * upwardKick;

    // Short lived lateral acceleration to feel like being pushed from the side (size-aware)
    ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence; // px/s^2
    ball.driftTime = 0.22 + Math.random() * 0.28;                    // 0.22–0.5s of drift

    balls.push(ball);
    return ball;
  }
  

  // Continuous emitter within a vw/vh-defined rectangle
  let emitterTimer = 0;
  function pickSpawnPoint() {
    const wCss = canvas.clientWidth;
    const hCss = canvas.clientHeight;
    const widthCss = clamp((SPAWN_W_VW / 100) * wCss, 0, wCss);
    let xCenterCss = clamp((SPAWN_X_CENTER_VW / 100) * wCss, 0, wCss);
    // Apply sweeping emitter motion across the band for natural hand-like movement
    if (EMITTER_SWEEP_ENABLED) {
      const amplPx = (EMITTER_SWEEP_AMPL_VW / 100) * wCss;
      const sweepOffset = Math.sin(emitterPhase) * amplPx;
      const prevX = xCenterCss;
      xCenterCss = clamp(xCenterCss + sweepOffset, 0, wCss);
      emitterSweepDir = (xCenterCss >= prevX) ? 1 : -1;
    }
    // Allow slight offscreen horizontal spawn for natural side entry feel
    const offX = Math.min(40, widthCss * 0.1); // up to 40px or 10% width
    const xLeftCss = clamp(xCenterCss - widthCss / 2 - offX, -offX, wCss);
    const xRightCss = clamp(xCenterCss + widthCss / 2 + offX, -offX, wCss);
    const yTopCss = (SPAWN_Y_VH / 100) * hCss;
    const yBotCss = yTopCss + (SPAWN_H_VH / 100) * hCss;
    // Slight bias along sweep direction to emit closer to the leading edge
    const bias = 0.3; // 0 = uniform, 1 = fully biased to leading edge
    const u = Math.random();
    const biased = bias > 0 ? (emitterSweepDir > 0 ? Math.pow(u, 1 - bias) : 1 - Math.pow(1 - u, 1 - bias)) : u;
    const x = (xLeftCss + (xRightCss - xLeftCss) * biased) * DPR;
    // Add slight upward randomness to spawn height for organic feel
    const y = randBetween(yTopCss * DPR, yBotCss * DPR) - (R_MAX + CONSTANTS.BALL_SPAWN_OFFSET + randBetween(0, 10 * DPR));
    return { x, y };
  }
  
  function emit(dt) {
    // Zero-G and Pulse Grid modes: no continuous spawning, balls are distributed at initialization
    if (currentMode === MODES.WEIGHTLESS || currentMode === MODES.PULSE_GRID) {
      return;
    }
    
    // Ball Pit & Flies modes: standard top emitter
    emitterTimer += dt;
    while (emitterTimer >= EMIT_INTERVAL) {
      // Jitter emissions slightly for organic timing
      const jitter = (Math.random() - 0.5) * EMIT_INTERVAL * 0.5; // ±25%
      emitterTimer -= (EMIT_INTERVAL + jitter);
      // Advance sweep phase based on elapsed time segment (approx)
      emitterPhase += (2 * Math.PI) * EMITTER_SWEEP_HZ * (EMIT_INTERVAL + jitter);
      const p = pickSpawnPoint();
      // Occasionally emit small clusters to mimic handful tosses
      const drops = (Math.random() < 0.35 ? 3 : 1);
      for (let i=0; i<drops; i++) {
        if (balls.length < MAX_BALLS) {
          // Slight horizontal staggering to suggest sideways motion
          const xOffset = i * CONSTANTS.BALL_CLUSTER_SPACING * (Math.random() < 0.5 ? 1 : -1);
          spawnBall(p.x + xOffset, p.y - i * CONSTANTS.BALL_CLUSTER_Y_OFFSET);
        }
      }
    }
  }

  // Spatial hash grid to accelerate broad-phase (optimized)
  const spatialGrid = new Map();
  
  function collectPairsSorted() {
    const n = balls.length;
    if (n < 2) return []; // Early exit for trivial cases
    const cellSize = Math.max(1, R_MAX * 2); // Optimized cell size
    const gridWidth = Math.ceil(canvas.width / cellSize) + 1; // Dynamic grid width
    spatialGrid.clear(); // Reuse map
    
    // Build grid with numeric keys (faster than string concatenation)
    for (let i = 0; i < n; i++) {
      const b = balls[i];
      const cx = (b.x / cellSize) | 0;
      const cy = (b.y / cellSize) | 0;
      const key = cy * gridWidth + cx; // Numeric key
      let arr = spatialGrid.get(key);
      if (!arr) { arr = []; spatialGrid.set(key, arr); }
      arr.push(i);
    }
    
    const pairs = [];
    for (const [key, arr] of spatialGrid) {
      const cy = (key / gridWidth) | 0;
      const cx = key % gridWidth;
      
      // Check 9 neighboring cells (including self)
      for (let oy = -1; oy <= 1; oy++) {
        for (let ox = -1; ox <= 1; ox++) {
          const neighborKey = (cy + oy) * gridWidth + (cx + ox);
          const nb = spatialGrid.get(neighborKey);
          if (!nb) continue;
          
          for (let ii = 0; ii < arr.length; ii++) {
            const i = arr[ii];
            for (let jj = 0; jj < nb.length; jj++) {
              const j = nb[jj];
              if (j <= i) continue;
              
              const A = balls[i], B = balls[j];
              const dx = B.x - A.x, dy = B.y - A.y;
              const rSum = A.r + B.r;
              const dist2 = dx*dx + dy*dy;
              
              if (dist2 < rSum*rSum) {
                const dist = Math.sqrt(Math.max(dist2, CONSTANTS.MIN_DISTANCE_EPSILON));
                const overlap = rSum - dist;
                pairs.push({ i, j, overlap });
              }
            }
          }
        }
      }
    }
    
    // Sort by overlap (most overlapping first for stability)
    pairs.sort((a, b) => b.overlap - a.overlap);
    return pairs;
  }

  // Circle–circle collisions: sequential impulses + Baumgarte positional correction
  function resolveCollisions(iterations = SOLVER_ITERS) {
    const pairs = collectPairsSorted();
    for (let iter = 0; iter < iterations; iter++) {
      for (let k = 0; k < pairs.length; k++) {
        const { i, j } = pairs[k];
        const A = balls[i];
        const B = balls[j];
        const dx = B.x - A.x;
        const dy = B.y - A.y;
        const rSum = A.r + B.r;
        const dist2 = dx * dx + dy * dy;
        if (dist2 === 0 || dist2 > rSum * rSum) continue;
        const dist = Math.sqrt(dist2);
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = rSum - dist;
        const invA = 1 / Math.max(A.m, 0.001);
        const invB = 1 / Math.max(B.m, 0.001);

        // Positional correction
        const correctionMag = POS_CORRECT_PERCENT * Math.max(overlap - POS_CORRECT_SLOP, 0) / (invA + invB);
        const cx = correctionMag * nx;
        const cy = correctionMag * ny;
        A.x -= cx * invA; A.y -= cy * invA;
        B.x += cx * invB; B.y += cy * invB;

        // Velocity impulse along the normal
        const rvx = B.vx - A.vx;
        const rvy = B.vy - A.vy;
        const velAlongNormal = rvx * nx + rvy * ny;
        if (velAlongNormal < 0) {
          const e = Math.abs(velAlongNormal) < REST_VEL_THRESHOLD ? 0 : REST;
          const j = -(1 + e) * velAlongNormal / (invA + invB);
          const ix = j * nx;
          const iy = j * ny;
          A.vx -= ix * invA; A.vy -= iy * invA;
          B.vx += ix * invB; B.vy += iy * invB;

          // Tangential slip to spin (approximate rolling/spin transfer)
          const tvx = rvx - velAlongNormal * nx;
          const tvy = rvy - velAlongNormal * ny;
          const slipMag = Math.hypot(tvx, tvy);
          if (slipMag > 1e-3) {
            const tangentSign = (tvx * -ny + tvy * nx) >= 0 ? 1 : -1; // right-hand tangent
            const gain = CONSTANTS.SPIN_GAIN_TANGENT;
            A.omega -= tangentSign * gain * slipMag / Math.max(A.r, 1);
            B.omega += tangentSign * gain * slipMag / Math.max(B.r, 1);
          }
          // Visual squash aligned to contact normal based on impact
          const impact = Math.min(1, Math.abs(velAlongNormal) / ((A.r + B.r) * 50));
          const sAmt = Math.min(getSquashMax(), impact * 0.8);
          A.squashAmount = Math.max(A.squashAmount, sAmt * 0.8);
          A.squashNormalAngle = Math.atan2(-ny, -nx);
          B.squashAmount = Math.max(B.squashAmount, sAmt * 0.8);
          B.squashNormalAngle = Math.atan2(ny, nx);
        }
      }
    }
  }

  // Main loop optimized for 120fps
  let last = performance.now() / 1000;
  let acc = 0;
  const DT = 1/120; // Target 120fps physics
  function frame(nowMs) {
    const now = nowMs / 1000;
    let dt = Math.min(0.008, now - last); // Cap at ~120fps for high refresh displays
    last = now;
    acc += dt;

  // FPS counters (render and physics) - only update if elements exist
    renderFrameCount++;
    if ((renderFpsElement || physicsFpsElement) && now - lastFPSTime >= CONSTANTS.FPS_UPDATE_INTERVAL) {
      if (renderFpsElement && renderFrameCount !== currentRenderFPS) {
        currentRenderFPS = renderFrameCount;
        renderFpsElement.textContent = currentRenderFPS.toString();
      }
      if (physicsFpsElement && physicsStepCount !== currentPhysicsFPS) {
        currentPhysicsFPS = physicsStepCount;
        physicsFpsElement.textContent = currentPhysicsFPS.toString();
      }
      
      renderFrameCount = 0;
      physicsStepCount = 0;
      lastFPSTime = now;
      
      // Update adaptive quality based on current FPS
      updateAdaptiveQuality(now);
    }

    emit(dt);
    
    // Update pulse grid mode (rhythmic movement)
    if (currentMode === MODES.PULSE_GRID) {
      updatePulseGrid(dt);
    }
    
    // Update text colliders periodically (every ~60 frames for performance)
    if (renderFrameCount % 60 === 0) {
      updateTextColliders();
    }

    // Physics iterations optimized for realistic, stable simulation
    let physicsSteps = 0;
    while (acc >= DT && physicsSteps < CONSTANTS.MAX_PHYSICS_STEPS) {
      // Skip physics step for pulse grid mode (movement handled by updatePulseGrid)
      if (currentMode !== MODES.PULSE_GRID) {
        for (let i=0; i<balls.length; i++) balls[i].step(DT);
      }
      
      // Ball-to-ball collisions (disabled for Flies and Pulse Grid modes)
      if (currentMode !== MODES.FLIES && currentMode !== MODES.PULSE_GRID) {
        resolveCollisions(currentCollisionIters); // Dynamic iterations based on adaptive quality
      }
      
      // Wall collisions (all modes except Pulse Grid)
      if (currentMode !== MODES.PULSE_GRID) {
      const wallRestitution = (currentMode === MODES.WEIGHTLESS) ? weightlessBounce : REST;
      for (let i=0; i<balls.length; i++) balls[i].walls(canvas.width, canvas.height, DT, wallRestitution);
      }
      
      acc -= DT;
      physicsSteps++;
      physicsStepCount++; // Count physics steps for FPS measurement
    }
    
    // Reset accumulator if we're falling behind
    if (acc > DT * CONSTANTS.ACCUMULATOR_RESET_THRESHOLD) acc = 0;

    // ═══════════════════════════════════════════════════════════════════
    // CANVAS 2D RENDERING
    // ═══════════════════════════════════════════════════════════════════
    
    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    // Draw rounded boundary if corner radius > 0 (cache boundary path for performance)
    if (cornerRadius > 0) {
      drawRoundedBoundary(ctx, canvas.width, canvas.height);
    }
    
    // Render balls with individual colors
    for (let i=0; i<balls.length; i++) balls[i].draw(ctx);
    // Draw cursor ball last
    drawCursorBall(ctx);
    
    // Draw current mode indicator (desktop only)
    if (!isTouchDevice) {
      ctx.save();
      ctx.font = '14px system-ui, -apple-system, sans-serif';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      const modeName = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      ctx.fillText(modeName + ' Mode', 10, canvas.height - 10);
      ctx.restore();
    }

    // Use requestAnimationFrame for proper vsync
    requestAnimationFrame(frame);
  }
  
  // Start the main loop with requestAnimationFrame
  console.log('High refresh mode enabled - using requestAnimationFrame');
  requestAnimationFrame(frame);

  // Reset ball sizes to global setting when switching modes
  function resetBallSizeToGlobal() {
    // Update size scale from slider (if needed)
    const globalScale = parseFloat(sizeSliderGlobal.value);
    sizeScale = globalScale;
    
    // Recalculate the actual size range based on sizeScale
    updateEffectiveScaleAndBallSizes();
    
    // Update all existing balls to use proper global size
    const baseSize = (R_MIN + R_MAX) / 2;
    for (let i = 0; i < balls.length; i++) {
      // Apply size variation if set, otherwise use base size
      if (sizeVariation === 0) {
        balls[i].r = baseSize;
        balls[i].rBase = baseSize;
      } else {
        // Apply limited variation (max 10% from global ball size)
        const maxVariation = baseSize * 0.1;
        const minR = Math.max(1, baseSize - maxVariation);
        const maxR = baseSize + maxVariation;
        balls[i].r = randBetween(minR, maxR);
        balls[i].rBase = balls[i].r;
      }
    }
  }

  // Reset balls to spawn positions (preserves all settings)
  function resetBallsToSpawn() {
    if (currentMode === MODES.WEIGHTLESS) {
      // For weightless mode, reinitialize with even distribution
      initializeWeightlessScene();
    } else {
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      const p = pickSpawnPoint();
      ball.x = p.x;
      ball.y = p.y;
      // Re-apply natural entry throw on reset (sweep-aware, size-aware)
      const centerX = canvas.width * 0.5;
      const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((ball.x < centerX) ? 1 : -1);
      const sizeInfluence = clamp((ball.r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
      const baseKick = 140 * sizeInfluence;
      const randKick = 180 * sizeInfluence;
      const upwardKick = 120;
      ball.vx = dir * (baseKick + Math.random() * randKick);
      ball.vy = -Math.random() * upwardKick;
      ball.age = 0;
      ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence;
      ball.driftTime = 0.22 + Math.random() * 0.28;
      }
    }
  }

  // Keyboard: reset balls to spawn, toggle panel
  // ═══════════════════════════════════════════════════════════════════════════
  // DRAGGABLE PANEL FUNCTIONALITY
  // ═══════════════════════════════════════════════════════════════════════════
  const panelHeader = document.getElementById('panelHeader');
  const minimizeBtn = document.getElementById('minimizePanel');
  
  // Configuration: Initial panel visibility (true = visible, false = hidden)
  const PANEL_INITIALLY_VISIBLE = false;
  
  // Apply initial visibility
  if (!PANEL_INITIALLY_VISIBLE && panel) {
    panel.classList.add('hidden');
  }
  
  // Minimize/maximize button
  if (minimizeBtn && panel) {
    minimizeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      panel.classList.toggle('hidden');
    });
  }
  
  // Drag functionality
  if (panelHeader && panel) {
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;
    
    panelHeader.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);
    
    // Touch support
    panelHeader.addEventListener('touchstart', dragStart);
    document.addEventListener('touchmove', drag);
    document.addEventListener('touchend', dragEnd);
    
    function dragStart(e) {
      if (e.type === 'touchstart') {
        initialX = e.touches[0].clientX - xOffset;
        initialY = e.touches[0].clientY - yOffset;
      } else {
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
      }
      
      if (e.target === panelHeader || panelHeader.contains(e.target)) {
        isDragging = true;
        panel.style.cursor = 'grabbing';
      }
    }
    
    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        
        if (e.type === 'touchmove') {
          currentX = e.touches[0].clientX - initialX;
          currentY = e.touches[0].clientY - initialY;
        } else {
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
        }
        
        xOffset = currentX;
        yOffset = currentY;
        
        // Convert fixed position to transform for smooth dragging
        const rect = panel.getBoundingClientRect();
        const computedStyle = window.getComputedStyle(panel);
        const initialTop = parseFloat(computedStyle.top) || 0;
        const initialRight = parseFloat(computedStyle.right) || 0;
        
        panel.style.top = `${initialTop + yOffset}px`;
        panel.style.right = `${initialRight - xOffset}px`;
        panel.style.left = 'auto';
        panel.style.bottom = 'auto';
        
        // Reset offsets after applying position
        xOffset = 0;
        yOffset = 0;
        initialX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        initialY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
      }
    }
    
    function dragEnd(e) {
      if (isDragging) {
        isDragging = false;
        panel.style.cursor = 'move';
        initialX = currentX;
        initialY = currentY;
      }
    }
  }
  
  // ═══════════════════════════════════════════════════════════════════════════
  // KEYBOARD SHORTCUTS
  // ═══════════════════════════════════════════════════════════════════════════
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k === 'r') {
      // Move balls back to spawn area - preserve all parameter settings
      resetBallsToSpawn();
      e.preventDefault(); // Prevent any default browser behavior
    }
    if (k === '/' && panel) {
      e.preventDefault();
      panel.classList.toggle('hidden');
    }
    // Quick mode switches 1-4
    if (k === '1') setMode(MODES.PIT);
    if (k === '2') setMode(MODES.FLIES);
    if (k === '3') setMode(MODES.WEIGHTLESS);
    if (k === '4') setMode(MODES.PULSE_GRID);
  });

  // Seed initial balls across the spawn area for quicker fill
  function seedArea(n = 160) {
    for (let i=0; i<n && balls.length < MAX_BALLS; i++) {
      const p = pickSpawnPoint();
      spawnBall(p.x, p.y);
    }
  }
  seedArea(CONSTANTS.INITIAL_SEED_BALLS);

  // Mouse input (unified handler for repeller + trail recording + boulder dragging)
  let lastTrailRecordTime = 0;
  let lastMousePosition = { x: 0, y: 0 };
  let mouseStoppedTime = 0;
  
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * DPR;
      mouseY = (e.clientY - rect.top) * DPR;
    
    // Ball Pit: enable repeller when power and radius are set
    if (currentMode === MODES.PIT && repelPower > 0 && repelRadius > 0) {
      repellerEnabled = true;
    }


  });
  canvas.addEventListener('mouseleave', () => {
    mouseX = CONSTANTS.OFFSCREEN_MOUSE;
    mouseY = CONSTANTS.OFFSCREEN_MOUSE;
  });


  // Draw a cursor as a ball matching the simulation style
  // Renders the cursor as a simulation-like ball for desktop. Hidden on touch.
  function drawCursorBall(ctx) {
    // Don't show cursor ball on touch devices (mobile)
    if (isTouchDevice) return;
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    
    const x = mouseX, y = mouseY;
    const baseSize = (R_MIN + R_MAX) / 2;
    const r = baseSize;
    
    const color = 'rgba(255, 255, 255, 0.9)';
    
    // Draw main cursor ball first
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    // Add subtle white outline for visibility
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function applyRepeller(b, dt) {
    // Respect "Off" template by treating zero or near-zero params as disabled
    if (!repellerEnabled) return;
    if (repelPower <= 0 || repelRadius <= 0) return;
    const rPx = repelRadius * DPR;
    const dx = b.x - mouseX;
    const dy = b.y - mouseY;
    const d2 = dx*dx + dy*dy;
    const r2 = rPx * rPx;
    if (d2 > r2) return;
    const d = Math.max(Math.sqrt(d2), CONSTANTS.MIN_REPEL_DISTANCE);
    const nx = dx / d;
    const ny = dy / d;
    const q = Math.max(0, 1 - d / rPx);
    const strength = (repelPower * REPELLER_GLOBAL_MULTIPLIER) * Math.pow(q, repelSoft);
    // Heavier balls respond less to the same field
    const massScale = Math.max(0.25, b.m / MASS_BASELINE_KG);
    b.vx += (nx * strength * dt) / massScale;
    b.vy += (ny * strength * dt) / massScale;
    // Add subtle air turbulence for realism (micro perturbations)
    const turbulence = 10; // subtle random force
    b.vx += (Math.random() - 0.5) * turbulence * dt;
    b.vy += (Math.random() - 0.5) * turbulence * dt;
  }

  // Behavior-mode external forces dispatcher
  function applyExternalForces(b, dt) {
    if (currentMode === MODES.PIT) {
      applyRepeller(b, dt);
      return;
    }
    if (currentMode === MODES.FLIES) {
      applyAttractor(b, dt);
      return;
    }
    if (currentMode === MODES.WEIGHTLESS) {
      applyWeightlessRepeller(b, dt);
      return;
    }
    if (currentMode === MODES.PULSE_GRID) {
      // No external forces in grid mode - movement controlled by updatePulseGrid
      return;
    }
  }
  
  // Subtle mouse repeller for Weightless mode
  function applyWeightlessRepeller(b, dt) {
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    if (weightlessRepellerPower <= 0 || weightlessRepellerRadius <= 0) return;
    
    const rPx = weightlessRepellerRadius * DPR;
    const dx = b.x - mouseX;
    const dy = b.y - mouseY;
    const d2 = dx*dx + dy*dy;
    const r2 = rPx * rPx;
    if (d2 > r2) return;
    
    const d = Math.max(Math.sqrt(d2), CONSTANTS.MIN_REPEL_DISTANCE);
    const nx = dx / d;
    const ny = dy / d;
    const q = Math.max(0, 1 - d / rPx);
    const strength = weightlessRepellerPower * q; // linear falloff, gentle
    
    b.vx += nx * strength * dt;
    b.vy += ny * strength * dt;
  }

  // Mouse attractor for Flies-to-Light mode - REALISTIC INSECT FLIGHT
  // Reference: Mosquitoes fly 1-2 m/s with quick acceleration and erratic patterns
  function applyAttractor(b, dt) {
    // Idle swarm center (viewport center) when mouse is outside
    const swarmCenterX = (mouseX === CONSTANTS.OFFSCREEN_MOUSE) ? canvas.width * 0.5 : mouseX;
    const swarmCenterY = (mouseY === CONSTANTS.OFFSCREEN_MOUSE) ? canvas.height * 0.5 : mouseY;
    
    const dx = swarmCenterX - b.x;
    const dy = swarmCenterY - b.y;
    const d2 = dx*dx + dy*dy;
    const d = Math.sqrt(d2 + 1);
    
    // Direction to target (mouse or swarm center)
    const dirX = dx / d;
    const dirY = dy / d;
    
    // 1. VERY STRONG ATTRACTION - insects have incredible acceleration relative to size
    // Mosquitoes can accelerate at 50+ g's in short bursts
    const attractForce = attractionPower * swarmSpeed * 2.0; // Use swarmSpeed multiplier
    b.vx += dirX * attractForce * dt;
    b.vy += dirY * attractForce * dt;
    
    // 2. SEPARATION from nearby flies (looser swarm - insects don't stick together)
    const separationRadius = 120 * DPR; // Much larger separation for natural spread
    let sepX = 0, sepY = 0;
    let neighborCount = 0;
    for (let i = 0; i < balls.length; i++) {
      const other = balls[i];
      if (other === b) continue;
      const dx2 = b.x - other.x;
      const dy2 = b.y - other.y;
      const d2_other = dx2*dx2 + dy2*dy2;
      if (d2_other < separationRadius * separationRadius && d2_other > 0) {
        const d_other = Math.sqrt(d2_other);
        const strength = 1 - (d_other / separationRadius);
        sepX += (dx2 / d_other) * strength;
        sepY += (dy2 / d_other) * strength;
            neighborCount++;
          }
        }
    if (neighborCount > 0) {
      const separationForce = 15000; // Stronger separation for more spread
      b.vx += (sepX / neighborCount) * separationForce * dt;
      b.vy += (sepY / neighborCount) * separationForce * dt;
    }
    
    // 3. INTENSE ERRATIC JITTER - mosquitos dart unpredictably with bursts
    // Real mosquitoes change direction constantly and have explosive acceleration
    const jitterBase = 2500 * swarmSpeed; // Scale jitter with swarm speed
    const burstChance = 0.08; // 8% chance per frame for sudden burst
    if (Math.random() < burstChance) {
      // Sudden burst in random direction (mimics insect reflex)
      const burstAngle = Math.random() * Math.PI * 2;
      const burstStrength = 1500 * swarmSpeed;
      b.vx += Math.cos(burstAngle) * burstStrength;
      b.vy += Math.sin(burstAngle) * burstStrength;
    }
    // Constant erratic jitter (insects never fly perfectly straight)
    b.vx += (Math.random() - 0.5) * jitterBase * dt;
    b.vy += (Math.random() - 0.5) * jitterBase * dt;
    
    // 4. CHAOTIC ORBITAL MOTION - insects spiral unpredictably
    // Orbital force varies wildly based on distance and random factor
    const orbitVariation = 0.3 + Math.random() * 2.0; // 0.3x to 2.3x variation
    const orbitStrength = swarmSpeed * 2000 * orbitVariation * dt; // Strong orbital
    b.vx += -dirY * orbitStrength;
    b.vy += dirX * orbitStrength;
    
    // 5. VERY HIGH speed limit - insects are remarkably fast for their size
    const maxSpeed = 2200 * swarmSpeed; // Scale max speed with swarm speed
    const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
    if (speed > maxSpeed) {
      b.vx = (b.vx / speed) * maxSpeed;
      b.vy = (b.vy / speed) * maxSpeed;
    }
    
    // Minimal damping - insects maintain energy through constant wing beats
    b.vx *= 0.995; // Very light damping for sustained high energy
    b.vy *= 0.995;
  }


  // UI elements
  const restitutionSlider = document.getElementById('restitutionSlider');
  const frictionSlider = document.getElementById('frictionSlider');
  const emitterSlider = document.getElementById('emitterSlider');
  // Mode-specific ball properties controls
  // Global ball properties
  const sizeSliderGlobal = document.getElementById('sizeSliderGlobal');
  const sizeVariationSliderGlobal = document.getElementById('sizeVariationSliderGlobal');
  const weightSliderGlobal = document.getElementById('weightSliderGlobal');
  const ballSoftnessSliderGlobal = document.getElementById('ballSoftnessSliderGlobal');
  const sizeValGlobal = document.getElementById('sizeValGlobal');
  const sizeVariationValGlobal = document.getElementById('sizeVariationValGlobal');
  const weightValGlobal = document.getElementById('weightValGlobal');
  const ballSoftnessValGlobal = document.getElementById('ballSoftnessValGlobal');
  
  // Mode-specific sliders (kept for backward compatibility)
  const sizeSliderPit = document.getElementById('sizeSliderPit');
  const sizeVariationSliderPit = document.getElementById('sizeVariationSliderPit');
  const weightSliderPit = document.getElementById('weightSliderPit');
  const ballSoftnessSliderPit = document.getElementById('ballSoftnessSliderPit');
  const sizeValPit = document.getElementById('sizeValPit');
  const sizeVariationValPit = document.getElementById('sizeVariationValPit');
  const weightValPit = document.getElementById('weightValPit');
  const ballSoftnessValPit = document.getElementById('ballSoftnessValPit');

  const sizeSliderFlies = document.getElementById('sizeSliderFlies');
  const sizeVariationSliderFlies = document.getElementById('sizeVariationSliderFlies');
  const weightSliderFlies = document.getElementById('weightSliderFlies');
  const ballSoftnessSliderFlies = document.getElementById('ballSoftnessSliderFlies');
  const sizeValFlies = document.getElementById('sizeValFlies');
  const sizeVariationValFlies = document.getElementById('sizeVariationValFlies');
  const weightValFlies = document.getElementById('weightValFlies');
  const ballSoftnessValFlies = document.getElementById('ballSoftnessValFlies');

  const sizeSliderZeroG = document.getElementById('sizeSliderZeroG');
  const sizeVariationSliderZeroG = document.getElementById('sizeVariationSliderZeroG');
  const weightSliderZeroG = document.getElementById('weightSliderZeroG');
  const ballSoftnessSliderZeroG = document.getElementById('ballSoftnessSliderZeroG');
  const sizeValZeroG = document.getElementById('sizeValZeroG');
  const sizeVariationValZeroG = document.getElementById('sizeVariationValZeroG');
  const weightValZeroG = document.getElementById('weightValZeroG');
  const ballSoftnessValZeroG = document.getElementById('ballSoftnessValZeroG');

  const maxBallsSlider = document.getElementById('maxBallsSlider');
  const spawnYSlider = document.getElementById('spawnYSlider');
  const spawnWidthSlider = document.getElementById('spawnWidthSlider');
  const spawnCenterSlider = document.getElementById('spawnCenterSlider');
  const spawnHeightSlider = document.getElementById('spawnHeightSlider');
  const repelSizeSlider = document.getElementById('repelSizeSlider');
  const repelPowerSlider = document.getElementById('repelPowerSlider');
  const repelSoftSlider = document.getElementById('repelSoftSlider');
  // Color controls
  const colorSelect = document.getElementById('colorSelect');
  const color1 = document.getElementById('color1');
  const color2 = document.getElementById('color2');
  const color3 = document.getElementById('color3');
  const color4 = document.getElementById('color4');
  const color5 = document.getElementById('color5');
  const color6 = document.getElementById('color6');
  const color7 = document.getElementById('color7');
  const color8 = document.getElementById('color8');
  const cursorColorSelect = document.getElementById('cursorColorSelect');
  // Hex spans
  const color1Val = document.getElementById('color1Val');
  const color2Val = document.getElementById('color2Val');
  const color3Val = document.getElementById('color3Val');
  const color4Val = document.getElementById('color4Val');
  const color5Val = document.getElementById('color5Val');
  const color6Val = document.getElementById('color6Val');
  const color7Val = document.getElementById('color7Val');
  const color8Val = document.getElementById('color8Val');
  // Tooltip hint for copy action
  [color1Val, color2Val, color3Val, color4Val, color5Val, color6Val, color7Val, color8Val].forEach(el => {
    if (el) el.setAttribute('title', 'Click to copy');
  });
  // Scene controls
  const cornerRadiusSlider = document.getElementById('cornerRadiusSlider');
  const cornerRadiusVal = document.getElementById('cornerRadiusVal');
  const motionBlurFadeSlider = document.getElementById('trailFadeSlider'); // motion blur uses old trailFade ID
  const motionBlurFadeVal = document.getElementById('trailFadeVal');
  const trailSubtletySlider = document.getElementById('trailSubtletySlider');
  const trailSubtletyVal = document.getElementById('trailSubtletyVal');

  const restitutionVal = document.getElementById('restitutionVal');
  const frictionVal = document.getElementById('frictionVal');
  const emitterVal = document.getElementById('emitterVal');
  // const sizeVal = document.getElementById('sizeVal'); // Removed - using global controls
  const maxBallsVal = document.getElementById('maxBallsVal');
  // const sizeVariationVal = document.getElementById('sizeVariationVal'); // Removed - using global controls
  // const weightVal = document.getElementById('weightVal'); // Removed - using global controls
  const spawnYVal = document.getElementById('spawnYVal');
  const spawnWidthVal = document.getElementById('spawnWidthVal');
  const spawnCenterVal = document.getElementById('spawnCenterVal');
  const spawnHeightVal = document.getElementById('spawnHeightVal');
  const repelSizeVal = document.getElementById('repelSizeVal');
  const repelPowerVal = document.getElementById('repelPowerVal');
  const repelSoftVal = document.getElementById('repelSoftVal');
  // Scene controls vals (shadows removed)

  // Config capture and build functionality (restored)
  function captureCurrentConfig() {
    return {
      gravityMultiplier,
      restitution: REST,
      friction: FRICTION,
      ballMass: ballMassKg,
      emitRate: EMIT_INTERVAL,
      maxBalls: MAX_BALLS,
      ballScale: sizeScale,
      ballVariation: sizeVariation,
      spawnX: SPAWN_X_CENTER_VW,
      spawnY: SPAWN_Y_VH,
      spawnWidth: SPAWN_W_VW,
      spawnHeight: SPAWN_H_VH,
      sweepEnabled: EMITTER_SWEEP_ENABLED,
      repelRadius,
      repelPower,
      repelSoftness: repelSoft,
      trailFade: motionBlurFade,
      trailSubtlety,
      colors: currentColors.slice(),
      colorWeights: COLOR_WEIGHTS.slice(),
      currentTemplate,
      cursorColorIndex: cursorBallIndex,
      // Performance optimization settings
      performanceMode,
      targetFPS,
      enableLOD
    };
  }
  function generateConfigCode(config) {
    return `// Generated configuration from frontend\nconst CONFIG = ${JSON.stringify(config, null, 2)};`;
  }
  const saveConfigBtn = document.getElementById('saveConfigBtn');
  const buildBtn = document.getElementById('buildBtn');
  const configOutput = document.getElementById('configOutput');
  if (saveConfigBtn && buildBtn && configOutput) {
    saveConfigBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      const code = generateConfigCode(config);
      configOutput.style.display = 'block';
      configOutput.textContent = code;
      navigator.clipboard.writeText(code).then(() => {
        const old = saveConfigBtn.textContent; saveConfigBtn.textContent = '✅ Copied!';
        setTimeout(() => { saveConfigBtn.textContent = old; }, 1200);
      }).catch(() => {
        console.warn('Clipboard copy failed');
        const old = saveConfigBtn.textContent; saveConfigBtn.textContent = '⚠️ Copy failed';
        setTimeout(() => { saveConfigBtn.textContent = old; }, 1200);
      });
    });
    buildBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      configOutput.style.display = 'block';
      configOutput.innerHTML = `
<strong>🚀 Build Instructions:</strong><br>
1. Run: <code>npm run build</code><br>
2. Your current config will be baked into <code>public/js/bouncy-balls-embed.js</code>`;
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'current-config.json'; a.click();
      URL.revokeObjectURL(url);
    });
  }

  // Click-to-copy helper
  function bindCopyOnClick(el, getText) {
    if (!el) return;
    el.addEventListener('click', async () => {
      const text = typeof getText === 'function' ? getText() : String(getText || '').trim();
      try {
        await navigator.clipboard.writeText(text);
        const old = el.textContent;
        el.textContent = 'COPIED';
        el.style.color = '#3ddc84';
        setTimeout(() => { el.textContent = old; el.style.color = '#888'; }, 900);
      } catch (e) {
        console.warn('Clipboard unavailable');
      }
    });
  }

  // Sliders (with auto-save)
  restitutionSlider && restitutionSlider.addEventListener('input', () => { REST = parseFloat(restitutionSlider.value); restitutionVal && (restitutionVal.textContent = REST.toFixed(2)); autoSaveSettings(); });
  frictionSlider && frictionSlider.addEventListener('input', () => { FRICTION = parseFloat(frictionSlider.value); frictionVal && (frictionVal.textContent = FRICTION.toFixed(4)); autoSaveSettings(); });
  emitterSlider && emitterSlider.addEventListener('input', () => { EMIT_INTERVAL = parseFloat(emitterSlider.value); emitterVal && (emitterVal.textContent = EMIT_INTERVAL.toFixed(3)); autoSaveSettings(); });

  // Mode-specific ball properties listeners (apply values globally but source UI is per-mode)
  function bindBallProps(sliders) {
    if (!sliders) return;
    const { size, sizeVal, sizeVar, sizeVarVal, soft, softVal } = sliders;
    size && size.addEventListener('input', () => {
      const newScale = parseFloat(size.value);
    sizeVal && (sizeVal.textContent = newScale.toFixed(1));
    sizeScale = newScale;
    updateEffectiveScaleAndBallSizes();
      // Apply mass to all balls
      for (let i=0; i<balls.length; i++) {
        balls[i].m = ballMassKg;
      }
      autoSaveSettings();
    });
    sizeVar && sizeVar.addEventListener('input', () => {
      const v = parseFloat(sizeVar.value);
      sizeVarVal && (sizeVarVal.textContent = v.toFixed(1));
      sizeVariation = v;
      autoSaveSettings();
    });
    soft && soft.addEventListener('input', () => {
      const s = parseInt(soft.value, 10);
      softVal && (softVal.textContent = String(s));
      ballSoftness = s;
      autoSaveSettings();
    });
  }

  // Global ball properties (apply to all modes)
  bindBallProps({
    size: sizeSliderGlobal, sizeVal: sizeValGlobal,
    sizeVar: sizeVariationSliderGlobal, sizeVarVal: sizeVariationValGlobal,
    soft: ballSoftnessSliderGlobal, softVal: ballSoftnessValGlobal
  });
  maxBallsSlider && maxBallsSlider.addEventListener('input', () => {
    MAX_BALLS = parseInt(maxBallsSlider.value, 10);
    maxBallsVal && (maxBallsVal.textContent = MAX_BALLS.toString());
    // Remove excess balls if current count exceeds new limit (remove from end for better performance)
    if (balls.length > MAX_BALLS) {
      balls.length = MAX_BALLS; // Truncate array efficiently
    }
  });
  sizeVariationSliderGlobal && sizeVariationSliderGlobal.addEventListener('input', () => {
    sizeVariation = parseFloat(sizeVariationSliderGlobal.value);
    sizeVariationValGlobal && (sizeVariationValGlobal.textContent = sizeVariation.toFixed(1));
    
    // Update existing ball sizes to reflect new variation
    updateExistingBallSizes();
  });
  // Mode-specific weight controls
  const weightPitSlider = document.getElementById('weightPitSlider');
  const weightPitVal = document.getElementById('weightPitVal');
  const weightWeightlessSlider = document.getElementById('weightWeightlessSlider');
  const weightWeightlessVal = document.getElementById('weightWeightlessVal');
  // removed legacy rainbow weight controls (replaced by boulderWeight controls)
  
  // Function to update existing ball sizes based on current sizeVariation
  function updateExistingBallSizes() {
    const baseSize = (R_MIN + R_MAX) / 2;
    
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      
      if (sizeVariation === 0) {
        // No variation: all balls exactly the same size
        ball.r = baseSize;
      } else {
        // Apply limited variation (max 10% from global ball size)
        const maxVariation = baseSize * 0.1; // 10% of global ball size
        const minR = Math.max(1, baseSize - maxVariation);
        const maxR = baseSize + maxVariation;
        ball.r = randBetween(minR, maxR);
      }
      
      // Keep shared mass model (no per-ball recompute)
      ball.m = ballMassKg;
    }
  }
  spawnYSlider && spawnYSlider.addEventListener('input', () => {
    SPAWN_Y_VH = parseFloat(spawnYSlider.value);
    spawnYVal && (spawnYVal.textContent = SPAWN_Y_VH.toFixed(0));
    setCSSSize(); resize();
  });
  spawnWidthSlider && spawnWidthSlider.addEventListener('input', () => { SPAWN_W_VW = parseFloat(spawnWidthSlider.value); spawnWidthVal && (spawnWidthVal.textContent = SPAWN_W_VW.toFixed(0)); });
  spawnCenterSlider && spawnCenterSlider.addEventListener('input', () => { SPAWN_X_CENTER_VW = parseFloat(spawnCenterSlider.value); spawnCenterVal && (spawnCenterVal.textContent = SPAWN_X_CENTER_VW.toFixed(0)); });
  spawnHeightSlider && spawnHeightSlider.addEventListener('input', () => { SPAWN_H_VH = parseFloat(spawnHeightSlider.value); spawnHeightVal && (spawnHeightVal.textContent = SPAWN_H_VH.toFixed(0)); });
  repelSizeSlider && repelSizeSlider.addEventListener('input', () => {
    repelRadius = parseFloat(repelSizeSlider.value);
    repelSizeVal && (repelSizeVal.textContent = repelRadius.toFixed(0));
    repellerEnabled = repellerEnabled || (repelPower > 0 && repelRadius > 0); 
  });
  repelPowerSlider && repelPowerSlider.addEventListener('input', () => {
    repelPower = repelSliderToPower(repelPowerSlider.value);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    // Do not auto-enable when template is Off; only enable via template or size/power explicit >0 with mouse over
    if (repellerSelect && repellerSelect.value !== 'off') {
      repellerEnabled = repelPower > 0 && repelRadius > 0; 
    }
  });
  repelSoftSlider && repelSoftSlider.addEventListener('input', () => {
    repelSoft = parseFloat(repelSoftSlider.value);
    repelSoftVal && (repelSoftVal.textContent = repelSoft.toFixed(1));
  });
  
  // Performance Mode Controls
  const performanceModeToggleEl = document.getElementById('performanceModeToggle');
  const performanceModeStatusEl = document.getElementById('performanceModeStatus');
  
  performanceModeToggleEl && performanceModeToggleEl.addEventListener('change', () => {
    togglePerformanceMode();
  });
  
  // Dark Mode Controls
  const darkModeToggleEl = document.getElementById('darkModeToggle');
  const darkModeStatusEl = document.getElementById('darkModeStatus');
  
  darkModeToggleEl && darkModeToggleEl.addEventListener('change', () => {
    toggleAutoDarkMode();
    autoSaveSettings();
  });
  
  // Canvas Shadow Controls
  const canvasShadowEnabledEl = document.getElementById('canvasShadowEnabled');
  const shadowOffsetXEl = document.getElementById('shadowOffsetX');
  const shadowOffsetXVal = document.getElementById('shadowOffsetXVal');
  const shadowOffsetYEl = document.getElementById('shadowOffsetY');
  const shadowOffsetYVal = document.getElementById('shadowOffsetYVal');
  const shadowBlurEl = document.getElementById('shadowBlur');
  const shadowBlurVal = document.getElementById('shadowBlurVal');
  const shadowOpacityEl = document.getElementById('shadowOpacity');
  const shadowOpacityVal = document.getElementById('shadowOpacityVal');
  const shadowColorEl = document.getElementById('shadowColor');
  const shadowColorVal = document.getElementById('shadowColorVal');
  const shadow2EnabledEl = document.getElementById('shadow2Enabled');
  const shadow2BlurEl = document.getElementById('shadow2Blur');
  const shadow2BlurVal = document.getElementById('shadow2BlurVal');
  const shadow2OpacityEl = document.getElementById('shadow2Opacity');
  const shadow2OpacityVal = document.getElementById('shadow2OpacityVal');
  
  canvasShadowEnabledEl && canvasShadowEnabledEl.addEventListener('change', () => {
    canvasShadowEnabled = canvasShadowEnabledEl.checked;
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadowOffsetXEl && shadowOffsetXEl.addEventListener('input', () => {
    shadowOffsetX = parseInt(shadowOffsetXEl.value, 10);
    shadowOffsetXVal && (shadowOffsetXVal.textContent = shadowOffsetX.toString());
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadowOffsetYEl && shadowOffsetYEl.addEventListener('input', () => {
    shadowOffsetY = parseInt(shadowOffsetYEl.value, 10);
    shadowOffsetYVal && (shadowOffsetYVal.textContent = shadowOffsetY.toString());
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadowBlurEl && shadowBlurEl.addEventListener('input', () => {
    shadowBlur = parseInt(shadowBlurEl.value, 10);
    shadowBlurVal && (shadowBlurVal.textContent = shadowBlur.toString());
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadowOpacityEl && shadowOpacityEl.addEventListener('input', () => {
    shadowOpacity = parseFloat(shadowOpacityEl.value);
    shadowOpacityVal && (shadowOpacityVal.textContent = shadowOpacity.toFixed(2));
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadowColorEl && shadowColorEl.addEventListener('input', () => {
    shadowColor = shadowColorEl.value;
    shadowColorVal && (shadowColorVal.textContent = shadowColor.toUpperCase());
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadow2EnabledEl && shadow2EnabledEl.addEventListener('change', () => {
    shadow2Enabled = shadow2EnabledEl.checked;
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadow2BlurEl && shadow2BlurEl.addEventListener('input', () => {
    shadow2Blur = parseInt(shadow2BlurEl.value, 10);
    shadow2BlurVal && (shadow2BlurVal.textContent = shadow2Blur.toString());
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadow2OpacityEl && shadow2OpacityEl.addEventListener('input', () => {
    shadow2Opacity = parseFloat(shadow2OpacityEl.value);
    shadow2OpacityVal && (shadow2OpacityVal.textContent = shadow2Opacity.toFixed(2));
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  // Mouse tracking for cursor ball and repeller
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) * DPR;
    mouseY = (e.clientY - rect.top) * DPR;
  });
  
  canvas.addEventListener('mouseleave', () => {
    mouseX = CONSTANTS.OFFSCREEN_MOUSE;
    mouseY = CONSTANTS.OFFSCREEN_MOUSE;
  });
  
  // Color controls
  colorSelect && colorSelect.addEventListener('change', () => {
    applyColorTemplate(colorSelect.value);
  });

  // Mode switcher wiring
  const modeButtons = Array.from(document.querySelectorAll('.mode-button'));
  const pitControls = document.getElementById('pitControls');
  const fliesControls = document.getElementById('fliesControls');
  const weightlessControls = document.getElementById('weightlessControls');
  const gravityPitSlider = document.getElementById('gravityPitSlider');
  const gravityPitVal = document.getElementById('gravityPitVal');
  const repellerEnabledPitEl = document.getElementById('repellerEnabledPit');
  const attractPowerSlider = document.getElementById('attractPowerSlider');
  const attractPowerVal = document.getElementById('attractPowerVal');
  const orbitRadiusSlider = document.getElementById('orbitRadiusSlider');
  const orbitRadiusVal = document.getElementById('orbitRadiusVal');
  const swarmSpeedSlider = document.getElementById('swarmSpeedSlider');
  const swarmSpeedVal = document.getElementById('swarmSpeedVal');
  
  // Weightless controls
  const weightlessCountSlider = document.getElementById('weightlessCountSlider');
  const weightlessCountVal = document.getElementById('weightlessCountVal');
  const weightlessSpeedSlider = document.getElementById('weightlessSpeedSlider');
  const weightlessSpeedVal = document.getElementById('weightlessSpeedVal');
  const weightlessBounceSlider = document.getElementById('weightlessBounceSlider');
  const weightlessBounceVal = document.getElementById('weightlessBounceVal');
  const weightlessRepelSlider = document.getElementById('weightlessRepelSlider');
  const weightlessRepelVal = document.getElementById('weightlessRepelVal');
  const weightlessRepelRadiusSlider = document.getElementById('weightlessRepelRadiusSlider');
  const weightlessRepelRadiusVal = document.getElementById('weightlessRepelRadiusVal');

  // ═══════════════════════════════════════════════════════════════════════════
  // PROFESSIONAL WEIGHTLESS SCENE INITIALIZATION
  // ═══════════════════════════════════════════════════════════════════════════
  
  // Initialize flies in idle swarm at viewport center
  function initializeFliesScene() {
    balls.length = 0;
    
    const targetBalls = 60; // Good swarm size for flies
    const w = canvas.width;
    const h = canvas.height;
    const centerX = w * 0.5;
    const centerY = h * 0.5;
    
    // Spawn flies in a loose cluster at center with randomized positions
    const swarmRadius = 150 * DPR; // Initial spread radius
    
    for (let i = 0; i < targetBalls; i++) {
      // Random position within swarm radius from center
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * swarmRadius;
      const x = centerX + Math.cos(angle) * distance;
      const y = centerY + Math.sin(angle) * distance;
      
      const ball = spawnBall(x, y);
      
      // Initial erratic velocity (flies are already moving in idle state)
      const speedVariation = 0.5 + Math.random() * 0.5;
      const vAngle = Math.random() * Math.PI * 2;
      const speed = 300 * speedVariation; // Moderate initial speed
      ball.vx = Math.cos(vAngle) * speed;
      ball.vy = Math.sin(vAngle) * speed;
      ball.driftAx = 0;
      ball.driftTime = 0;
    }
  }
  
  /**
   * Initialize Zero-G scene with random ball distribution
   * @description Spawns balls randomly across entire viewport with random velocities
   * @returns {void}
   * @modifies {balls}
   */
  function initializeWeightlessScene() {
    balls.length = 0;
    
    // Fixed count from UI control
    const targetBalls = weightlessCount;
    const w = canvas.width;
    const h = canvas.height;
    
    // Random distribution across entire viewport (no grid)
    const margin = 40 * DPR; // Safe margin from edges
    
    for (let i = 0; i < targetBalls; i++) {
      // Completely random position within viewport
      const x = margin + Math.random() * (w - 2 * margin);
      const y = margin + Math.random() * (h - 2 * margin);
      
      const ball = spawnBall(x, y);
      
      // Random velocity in any direction
      const angle = Math.random() * Math.PI * 2;
      const speed = weightlessInitialSpeed * (0.7 + Math.random() * 0.3);
      ball.vx = Math.cos(angle) * speed;
      ball.vy = Math.sin(angle) * speed;
      ball.driftAx = 0;
      ball.driftTime = 0;
    }
  }
  
  // ═══════════════════════════════════════════════════════════════════════════
  // PULSE GRID MODE - RHYTHMIC GRID-BASED MOVEMENT
  // ═══════════════════════════════════════════════════════════════════════════
  
  // Grid state
  let gridCellSize = 0;
  let gridRows = 0;
  let gridCols = 0;
  let gridOffsetX = 0;
  let gridOffsetY = 0;
  
  /**
   * Calculate grid dimensions based on canvas size and column count
   * @description Computes cell size, row count, and centering offsets for grid layout
   * @returns {void}
   * @modifies {gridCols, gridCellSize, gridRows, gridOffsetX, gridOffsetY}
   */
  function calculateGridDimensions() {
    const w = canvas.width;
    const h = canvas.height;
    
    // Calculate cell size based on columns and 1:1 aspect ratio
    gridCols = gridColumns;
    gridCellSize = w / gridCols;
    gridRows = Math.floor(h / gridCellSize);
    
    // Center grid in viewport
    gridOffsetX = (w - (gridCols * gridCellSize)) / 2;
    gridOffsetY = (h - (gridRows * gridCellSize)) / 2;
  }
  
  function gridCellToPixel(gridX, gridY) {
    return {
      x: gridOffsetX + (gridX + 0.5) * gridCellSize,
      y: gridOffsetY + (gridY + 0.5) * gridCellSize
    };
  }
  
  /**
   * Initialize Pulse Grid scene with rhythmic ball placement
   * @description Clears existing balls and spawns new ones in unique grid cells with staggered jump times.
   * Uses random distribution to ensure balls are spread across entire viewport.
   * @returns {void}
   * @modifies {balls}
   * @example
   * initializePulseGridScene(); // Creates 120 balls on 40-column grid
   */
  function initializePulseGridScene() {
    balls.length = 0;
    calculateGridDimensions();
    
    const maxCells = gridCols * gridRows;
    const targetBalls = Math.min(gridBallCount, maxCells); // Cap at grid capacity
    
    // Create array of all possible cells
    const allCells = [];
    for (let row = 0; row < gridRows; row++) {
      for (let col = 0; col < gridCols; col++) {
        allCells.push({ gridX: col, gridY: row });
      }
    }
    
    // Shuffle array for random distribution
    for (let i = allCells.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [allCells[i], allCells[j]] = [allCells[j], allCells[i]];
    }
    
    // Take first N cells for even random distribution across viewport
    for (let i = 0; i < targetBalls; i++) {
      const cell = allCells[i];
      const pos = gridCellToPixel(cell.gridX, cell.gridY);
      
      const ball = spawnBall(pos.x, pos.y);
      
      // Grid-specific properties
      ball.gridX = cell.gridX;
      ball.gridY = cell.gridY;
      ball.targetX = pos.x;
      ball.targetY = pos.y;
      ball.jumpProgress = 1.0; // Start at rest
      ball.vx = 0;
      ball.vy = 0;
      ball.driftAx = 0;
      ball.driftTime = 0;
      
      // Stagger initial jump times based on synchronicity
      const baseDelay = pulseInterval;
      const phaseOffset = pulseSynchronicity * Math.random() * baseDelay;
      ball.nextJumpTime = baseDelay + phaseOffset;
    }
  }
  
  /**
   * Update grid ball positions with rhythmic movement
   * @description Handles beat timing, direction selection, and jump animation for all balls in grid mode
   * @param {number} dt - Delta time in seconds since last update
   * @returns {void}
   * @modifies {balls[].x, balls[].y, balls[].gridX, balls[].gridY, balls[].jumpProgress}
   */
  function updatePulseGrid(dt) {
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      
      // Check if it's time for a new jump
      ball.nextJumpTime -= dt;
      
      if (ball.nextJumpTime <= 0 && ball.jumpProgress >= 1.0) {
        // Initiate new jump
        const directions = [
          { dx: 0, dy: -1 },  // up
          { dx: 0, dy: 1 },   // down
          { dx: -1, dy: 0 },  // left
          { dx: 1, dy: 0 }    // right
        ];
        
        // Pick random direction
        const dir = directions[Math.floor(Math.random() * directions.length)];
        
        // Pick random step count
        const stepRange = pulseMaxSteps - pulseMinSteps + 1;
        const steps = pulseMinSteps + Math.floor(Math.random() * stepRange);
        
        // Apply randomness to step count
        const randomizedSteps = Math.max(1, Math.round(steps * (1 - pulseRandomness * 0.5 + pulseRandomness * Math.random())));
        
        // Calculate new grid position
        let newGridX = ball.gridX + dir.dx * randomizedSteps;
        let newGridY = ball.gridY + dir.dy * randomizedSteps;
        
        // Clamp to grid bounds
        newGridX = Math.max(0, Math.min(gridCols - 1, newGridX));
        newGridY = Math.max(0, Math.min(gridRows - 1, newGridY));
        
        // Update target
        ball.gridX = newGridX;
        ball.gridY = newGridY;
        const newPos = gridCellToPixel(newGridX, newGridY);
        ball.targetX = newPos.x;
        ball.targetY = newPos.y;
        
        // Start jump animation
        ball.jumpProgress = 0.0;
        ball.jumpStartX = ball.x;
        ball.jumpStartY = ball.y;
        
        // Schedule next jump with rhythm interval and randomness
        const intervalJitter = pulseRandomness * pulseInterval * (Math.random() - 0.5);
        const syncJitter = pulseSynchronicity * pulseInterval * Math.random();
        ball.nextJumpTime = pulseInterval + intervalJitter + syncJitter;
      }
      
      // Animate jump if in progress
      if (ball.jumpProgress < 1.0) {
        ball.jumpProgress += dt / pulseSpeed;
        
        if (ball.jumpProgress >= 1.0) {
          ball.jumpProgress = 1.0;
          ball.x = ball.targetX;
          ball.y = ball.targetY;
          ball.vx = 0;
          ball.vy = 0;
        } else {
          const t = ball.jumpProgress;
          let eased = t;
          
          // Apply easing based on style
          if (pulseEasingStyle === 'linear') {
            // Constant speed
            eased = t;
          } else if (pulseEasingStyle === 'snap') {
            // Robotic snap with overshoot and bounce-back
            if (t < 0.6) {
              // Fast acceleration to overshoot point
              const t1 = t / 0.6;
              eased = t1 * t1 * pulseOvershoot;
            } else {
              // Bounce back to final position
              const t2 = (t - 0.6) / 0.4;
              const bounceAmount = (pulseOvershoot - 1.0) * (1 - t2);
              eased = 1.0 + bounceAmount - pulseBounceIntensity * Math.sin(t2 * Math.PI);
            }
          } else if (pulseEasingStyle === 'bounce') {
            // Elastic bounce effect
            if (t < 0.7) {
              eased = (t / 0.7) * (t / 0.7);
            } else {
              const t2 = (t - 0.7) / 0.3;
              eased = 1.0 - pulseBounceIntensity * 0.5 * Math.sin(t2 * Math.PI * 2);
            }
          } else if (pulseEasingStyle === 'smooth') {
            // Classic ease-in-out
            eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
          }
          
          // Interpolate position (STRAIGHT LINE - no arc)
          ball.x = ball.jumpStartX + (ball.targetX - ball.jumpStartX) * eased;
          ball.y = ball.jumpStartY + (ball.targetY - ball.jumpStartY) * eased;
          
          // Zero velocity during animation
          ball.vx = 0;
          ball.vy = 0;
        }
      }
    }
  }

  /**
   * Update UI to reflect current mode selection
   * @description Toggles active class on mode controls and updates ARIA states
   * @returns {void}
   */
  function updateModeControlsUI() {
    const pulseGridControls = document.getElementById('pulseGridControls');
    if (pitControls) pitControls.classList.toggle('active', currentMode === MODES.PIT);
    if (fliesControls) fliesControls.classList.toggle('active', currentMode === MODES.FLIES);
    if (weightlessControls) weightlessControls.classList.toggle('active', currentMode === MODES.WEIGHTLESS);
    if (pulseGridControls) pulseGridControls.classList.toggle('active', currentMode === MODES.PULSE_GRID);
    
    // Update mode buttons and ARIA states
    modeButtons.forEach(btn => {
      const isActive = btn.getAttribute('data-mode') === currentMode;
      btn.classList.toggle('active', isActive);
      btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
  }
  
  /**
   * Announce message to screen readers via live region
   * @param {string} message - Message to announce
   * @returns {void}
   */
  function announceToScreenReader(message) {
    const announcer = document.getElementById('announcer');
    if (announcer) {
      announcer.textContent = ''; // Clear first for re-announcement
      setTimeout(() => announcer.textContent = message, 100);
    }
  }

  /**
   * Switch to a different simulation mode
   * @description Changes physics behavior, initializes mode-specific scene, and updates UI
   * @param {string} mode - Mode constant from MODES enum ('pit'|'flies'|'weightless'|'pulse-grid')
   * @returns {void}
   * @modifies {currentMode, balls, gravityMultiplier, G, repellerEnabled}
   * @example
   * setMode(MODES.PULSE_GRID); // Switch to grid mode
   */
  function setMode(mode) {
    currentMode = mode;
    
    // Announce mode change to screen readers
    const modeNames = {
      [MODES.PIT]: 'Ball Pit',
      [MODES.FLIES]: 'Flies to Light',
      [MODES.WEIGHTLESS]: 'Zero Gravity',
      [MODES.PULSE_GRID]: 'Pulse Grid'
    };
    announceToScreenReader(`Switched to ${modeNames[mode]} mode`);
    
    // Update container CSS class for mode-specific styling (canvas height)
    container.className = ''; // Clear all mode classes
    if (currentMode === MODES.PIT) {
      container.classList.add('mode-pit'); // 150vh height
    }
    // Other modes use default 100svh (no class needed)
    
    // Resize canvas to match new mode's height
    resize();
    
    // Apply per-mode high-level toggles and initialization
    if (currentMode === MODES.PIT) {
      gravityMultiplier = gravityMultiplierPit;
      G = GE * gravityMultiplier;
      repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0);
      EMITTER_SWEEP_ENABLED = true;
      // Reset scene when entering Ball Pit
      balls.length = 0;
      emitterTimer = 0;
      // Reset ball sizes to global
      resetBallSizeToGlobal();
    } else if (currentMode === MODES.FLIES) {
      gravityMultiplier = 0.0; // no gravity
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
      // Initialize flies scene with idle swarm at center
      initializeFliesScene();
      // Reset ball sizes to global (after initialization)
      resetBallSizeToGlobal();
    } else if (currentMode === MODES.WEIGHTLESS) {
      gravityMultiplier = 0.0; // zero gravity (weightless)
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
      // Initialize weightless scene with even distribution
      initializeWeightlessScene();
      // Reset ball sizes to global (after initialization)
      resetBallSizeToGlobal();
    } else if (currentMode === MODES.PULSE_GRID) {
      gravityMultiplier = 0.0; // no physics gravity in grid mode
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
      // Initialize pulse grid scene with rhythmic movement
      initializePulseGridScene();
      // Reset ball sizes to global (after initialization)
      resetBallSizeToGlobal();
    }
    updateModeControlsUI();
  }

  // Hook up UI listeners (with auto-save on changes)
  modeButtons.forEach(btn => btn.addEventListener('click', () => {
    setMode(btn.getAttribute('data-mode'));
    // Note: resetBallSizeToGlobal() is now called inside setMode() for each mode
    autoSaveSettings();
  }));
  gravityPitSlider && gravityPitSlider.addEventListener('input', () => {
    gravityMultiplierPit = parseFloat(gravityPitSlider.value);
    gravityPitVal && (gravityPitVal.textContent = gravityMultiplierPit.toFixed(1));
    autoSaveSettings();
    if (currentMode === MODES.PIT) { gravityMultiplier = gravityMultiplierPit; G = GE * gravityMultiplier; }
  });
  
  // Mode-specific weight controls
  weightPitSlider && weightPitSlider.addEventListener('input', () => {
    ballMassKg = parseFloat(weightPitSlider.value);
    weightPitVal && (weightPitVal.textContent = ballMassKg.toFixed(2));
    // Apply shared mass to all balls
    for (let i=0; i<balls.length; i++) {
      balls[i].m = ballMassKg;
    }
    // Recompute derived scaling so gravity visibly changes with weight
    recomputeMassDerivedScales();
    autoSaveSettings();
  });
  repellerEnabledPitEl && repellerEnabledPitEl.addEventListener('change', () => {
    repellerEnabledPit = !!repellerEnabledPitEl.checked;
    if (currentMode === MODES.PIT) repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0);
  });
  attractPowerSlider && attractPowerSlider.addEventListener('input', () => {
    attractionPower = parseFloat(attractPowerSlider.value);
    attractPowerVal && (attractPowerVal.textContent = Math.round(attractionPower).toString());
  });
  orbitRadiusSlider && orbitRadiusSlider.addEventListener('input', () => {
    orbitRadius = parseFloat(orbitRadiusSlider.value);
    orbitRadiusVal && (orbitRadiusVal.textContent = Math.round(orbitRadius).toString());
  });
  swarmSpeedSlider && swarmSpeedSlider.addEventListener('input', () => {
    swarmSpeed = parseFloat(swarmSpeedSlider.value);
    swarmSpeedVal && (swarmSpeedVal.textContent = swarmSpeed.toFixed(1));
  });
  
  // Weightless controls
  weightlessCountSlider && weightlessCountSlider.addEventListener('input', () => {
    weightlessCount = parseInt(weightlessCountSlider.value, 10);
    weightlessCountVal && (weightlessCountVal.textContent = weightlessCount.toString());
    if (currentMode === MODES.WEIGHTLESS) initializeWeightlessScene();
  });
  weightlessSpeedSlider && weightlessSpeedSlider.addEventListener('input', () => {
    weightlessInitialSpeed = parseFloat(weightlessSpeedSlider.value);
    weightlessSpeedVal && (weightlessSpeedVal.textContent = Math.round(weightlessInitialSpeed).toString());
  });
  weightlessBounceSlider && weightlessBounceSlider.addEventListener('input', () => {
    weightlessBounce = parseFloat(weightlessBounceSlider.value);
    weightlessBounceVal && (weightlessBounceVal.textContent = weightlessBounce.toFixed(2));
  });
  weightlessRepelSlider && weightlessRepelSlider.addEventListener('input', () => {
    weightlessRepellerPower = parseFloat(weightlessRepelSlider.value);
    weightlessRepelVal && (weightlessRepelVal.textContent = Math.round(weightlessRepellerPower).toString());
    autoSaveSettings();
  });
  weightlessRepelRadiusSlider && weightlessRepelRadiusSlider.addEventListener('input', () => {
    weightlessRepellerRadius = parseFloat(weightlessRepelRadiusSlider.value);
    weightlessRepelRadiusVal && (weightlessRepelRadiusVal.textContent = Math.round(weightlessRepellerRadius).toString());
    autoSaveSettings();
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // PULSE GRID MODE CONTROLS
  // ═══════════════════════════════════════════════════════════════════════════
  
  const gridPresetSelect = document.getElementById('gridPresetSelect');
  const gridBallCountSlider = document.getElementById('gridBallCountSlider');
  const gridBallCountVal = document.getElementById('gridBallCountVal');
  const gridColumnsSlider = document.getElementById('gridColumnsSlider');
  const gridColumnsVal = document.getElementById('gridColumnsVal');
  const pulseIntervalSlider = document.getElementById('pulseIntervalSlider');
  const pulseIntervalVal = document.getElementById('pulseIntervalVal');
  const pulseSpeedSlider = document.getElementById('pulseSpeedSlider');
  const pulseSpeedVal = document.getElementById('pulseSpeedVal');
  const pulseMinStepsSlider = document.getElementById('pulseMinStepsSlider');
  const pulseMinStepsVal = document.getElementById('pulseMinStepsVal');
  const pulseMaxStepsSlider = document.getElementById('pulseMaxStepsSlider');
  const pulseMaxStepsVal = document.getElementById('pulseMaxStepsVal');
  const pulseSynchronicitySlider = document.getElementById('pulseSynchronicitySlider');
  const pulseSynchronicityVal = document.getElementById('pulseSynchronicityVal');
  const pulseRandomnessSlider = document.getElementById('pulseRandomnessSlider');
  const pulseRandomnessVal = document.getElementById('pulseRandomnessVal');
  
  // Preset configurations
  const gridPresets = {
    synchronized: {
      interval: 0.6,
      speed: 0.2,
      minSteps: 1,
      maxSteps: 2,
      synchronicity: 0.1,
      randomness: 0.2,
      easingStyle: 'snap',
      overshoot: 1.12,
      bounce: 0.18
    },
    organic: {
      interval: 0.8,
      speed: 0.25,
      minSteps: 1,
      maxSteps: 3,
      synchronicity: 0.3,
      randomness: 0.4,
      easingStyle: 'smooth',
      overshoot: 1.05,
      bounce: 0.1
    },
    chaotic: {
      interval: 0.4,
      speed: 0.15,
      minSteps: 2,
      maxSteps: 4,
      synchronicity: 0.7,
      randomness: 0.8,
      easingStyle: 'bounce',
      overshoot: 1.15,
      bounce: 0.25
    }
  };
  
  /**
   * Apply animation preset to Pulse Grid mode
   * @description Updates all grid animation parameters from preset configuration
   * @param {string} presetName - Preset key ('synchronized'|'organic'|'chaotic')
   * @returns {void}
   * @modifies {pulseInterval, pulseSpeed, pulseMinSteps, pulseMaxSteps, pulseSynchronicity, pulseRandomness, pulseEasingStyle, pulseOvershoot, pulseBounceIntensity}
   */
  function applyGridPreset(presetName) {
    const preset = gridPresets[presetName];
    if (!preset) return;
    
    pulseInterval = preset.interval;
    pulseSpeed = preset.speed;
    pulseMinSteps = preset.minSteps;
    pulseMaxSteps = preset.maxSteps;
    pulseSynchronicity = preset.synchronicity;
    pulseRandomness = preset.randomness;
    pulseEasingStyle = preset.easingStyle;
    pulseOvershoot = preset.overshoot;
    pulseBounceIntensity = preset.bounce;
    
    // Update UI
    if (pulseIntervalSlider) pulseIntervalSlider.value = preset.interval;
    if (pulseIntervalVal) pulseIntervalVal.textContent = preset.interval.toFixed(1);
    if (pulseSpeedSlider) pulseSpeedSlider.value = preset.speed;
    if (pulseSpeedVal) pulseSpeedVal.textContent = preset.speed.toFixed(2);
    if (pulseMinStepsSlider) pulseMinStepsSlider.value = preset.minSteps;
    if (pulseMinStepsVal) pulseMinStepsVal.textContent = preset.minSteps.toString();
    if (pulseMaxStepsSlider) pulseMaxStepsSlider.value = preset.maxSteps;
    if (pulseMaxStepsVal) pulseMaxStepsVal.textContent = preset.maxSteps.toString();
    if (pulseSynchronicitySlider) pulseSynchronicitySlider.value = preset.synchronicity;
    if (pulseSynchronicityVal) pulseSynchronicityVal.textContent = preset.synchronicity.toFixed(2);
    if (pulseRandomnessSlider) pulseRandomnessSlider.value = preset.randomness;
    if (pulseRandomnessVal) pulseRandomnessVal.textContent = preset.randomness.toFixed(2);
    
    const pulseEasingSelect = document.getElementById('pulseEasingSelect');
    const pulseOvershootSlider = document.getElementById('pulseOvershootSlider');
    const pulseOvershootVal = document.getElementById('pulseOvershootVal');
    const pulseBounceSlider = document.getElementById('pulseBounceSlider');
    const pulseBounceVal = document.getElementById('pulseBounceVal');
    
    if (pulseEasingSelect) pulseEasingSelect.value = preset.easingStyle;
    if (pulseOvershootSlider) pulseOvershootSlider.value = preset.overshoot;
    if (pulseOvershootVal) pulseOvershootVal.textContent = preset.overshoot.toFixed(2);
    if (pulseBounceSlider) pulseBounceSlider.value = preset.bounce;
    if (pulseBounceVal) pulseBounceVal.textContent = preset.bounce.toFixed(2);
    
    // Reinitialize if in grid mode
    if (currentMode === MODES.PULSE_GRID) {
      initializePulseGridScene();
    }
  }
  
  // Preset selector
  gridPresetSelect && gridPresetSelect.addEventListener('change', () => {
    applyGridPreset(gridPresetSelect.value);
    autoSaveSettings();
  });
  
  // Ball count
  gridBallCountSlider && gridBallCountSlider.addEventListener('input', () => {
    gridBallCount = parseInt(gridBallCountSlider.value, 10);
    gridBallCountVal && (gridBallCountVal.textContent = gridBallCount.toString());
    if (currentMode === MODES.PULSE_GRID) initializePulseGridScene();
    autoSaveSettings();
  });
  
  // Grid columns
  gridColumnsSlider && gridColumnsSlider.addEventListener('input', () => {
    gridColumns = parseInt(gridColumnsSlider.value, 10);
    gridColumnsVal && (gridColumnsVal.textContent = gridColumns.toString());
    if (currentMode === MODES.PULSE_GRID) {
      calculateGridDimensions();
      initializePulseGridScene();
    }
    autoSaveSettings();
  });
  
  // Beat interval
  pulseIntervalSlider && pulseIntervalSlider.addEventListener('input', () => {
    pulseInterval = parseFloat(pulseIntervalSlider.value);
    pulseIntervalVal && (pulseIntervalVal.textContent = pulseInterval.toFixed(1));
    autoSaveSettings();
  });
  
  // Jump speed
  pulseSpeedSlider && pulseSpeedSlider.addEventListener('input', () => {
    pulseSpeed = parseFloat(pulseSpeedSlider.value);
    pulseSpeedVal && (pulseSpeedVal.textContent = pulseSpeed.toFixed(2));
    autoSaveSettings();
  });
  
  // Min steps
  pulseMinStepsSlider && pulseMinStepsSlider.addEventListener('input', () => {
    pulseMinSteps = parseInt(pulseMinStepsSlider.value, 10);
    pulseMinStepsVal && (pulseMinStepsVal.textContent = pulseMinSteps.toString());
    // Ensure min <= max
    if (pulseMinSteps > pulseMaxSteps) {
      pulseMaxSteps = pulseMinSteps;
      if (pulseMaxStepsSlider) pulseMaxStepsSlider.value = pulseMinSteps;
      if (pulseMaxStepsVal) pulseMaxStepsVal.textContent = pulseMinSteps.toString();
    }
    autoSaveSettings();
  });
  
  // Max steps
  pulseMaxStepsSlider && pulseMaxStepsSlider.addEventListener('input', () => {
    pulseMaxSteps = parseInt(pulseMaxStepsSlider.value, 10);
    pulseMaxStepsVal && (pulseMaxStepsVal.textContent = pulseMaxSteps.toString());
    // Ensure min <= max
    if (pulseMaxSteps < pulseMinSteps) {
      pulseMinSteps = pulseMaxSteps;
      if (pulseMinStepsSlider) pulseMinStepsSlider.value = pulseMaxSteps;
      if (pulseMinStepsVal) pulseMinStepsVal.textContent = pulseMaxSteps.toString();
    }
    autoSaveSettings();
  });
  
  // Synchronicity
  pulseSynchronicitySlider && pulseSynchronicitySlider.addEventListener('input', () => {
    pulseSynchronicity = parseFloat(pulseSynchronicitySlider.value);
    pulseSynchronicityVal && (pulseSynchronicityVal.textContent = pulseSynchronicity.toFixed(2));
    autoSaveSettings();
  });
  
  // Randomness
  pulseRandomnessSlider && pulseRandomnessSlider.addEventListener('input', () => {
    pulseRandomness = parseFloat(pulseRandomnessSlider.value);
    pulseRandomnessVal && (pulseRandomnessVal.textContent = pulseRandomness.toFixed(2));
    autoSaveSettings();
  });
  
  // Animation style controls
  const pulseEasingSelect = document.getElementById('pulseEasingSelect');
  const pulseOvershootSlider = document.getElementById('pulseOvershootSlider');
  const pulseOvershootVal = document.getElementById('pulseOvershootVal');
  const pulseBounceSlider = document.getElementById('pulseBounceSlider');
  const pulseBounceVal = document.getElementById('pulseBounceVal');
  
  pulseEasingSelect && pulseEasingSelect.addEventListener('change', () => {
    pulseEasingStyle = pulseEasingSelect.value;
    autoSaveSettings();
  });
  
  pulseOvershootSlider && pulseOvershootSlider.addEventListener('input', () => {
    pulseOvershoot = parseFloat(pulseOvershootSlider.value);
    pulseOvershootVal && (pulseOvershootVal.textContent = pulseOvershoot.toFixed(2));
    autoSaveSettings();
  });
  
  pulseBounceSlider && pulseBounceSlider.addEventListener('input', () => {
    pulseBounceIntensity = parseFloat(pulseBounceSlider.value);
    pulseBounceVal && (pulseBounceVal.textContent = pulseBounceIntensity.toFixed(2));
    autoSaveSettings();
  });

  /**
   * Update existing ball colors to use new color palette
   * @returns {void}
   */
  function updateExistingBallColors() {
    for (let i = 0; i < balls.length; i++) {
      balls[i].color = pickRandomColor();
    }
  }
  
  /**
   * Update color picker UI elements to show current palette
   * @returns {void}
   */
  function updateColorPickersUI() {
    const color1 = document.getElementById('color1');
    const color2 = document.getElementById('color2');
    const color3 = document.getElementById('color3');
    const color4 = document.getElementById('color4');
    const color5 = document.getElementById('color5');
    const color6 = document.getElementById('color6');
    const color7 = document.getElementById('color7');
    const color8 = document.getElementById('color8');
    const color1Val = document.getElementById('color1Val');
    const color2Val = document.getElementById('color2Val');
    const color3Val = document.getElementById('color3Val');
    const color4Val = document.getElementById('color4Val');
    const color5Val = document.getElementById('color5Val');
    const color6Val = document.getElementById('color6Val');
    const color7Val = document.getElementById('color7Val');
    const color8Val = document.getElementById('color8Val');
    
    if (color1 && color1Val) { color1.value = currentColors[0]; color1Val.textContent = currentColors[0].toUpperCase(); }
    if (color2 && color2Val) { color2.value = currentColors[1]; color2Val.textContent = currentColors[1].toUpperCase(); }
    if (color3 && color3Val) { color3.value = currentColors[2]; color3Val.textContent = currentColors[2].toUpperCase(); }
    if (color4 && color4Val) { color4.value = currentColors[3]; color4Val.textContent = currentColors[3].toUpperCase(); }
    if (color5 && color5Val) { color5.value = currentColors[4]; color5Val.textContent = currentColors[4].toUpperCase(); }
    if (color6 && color6Val) { color6.value = currentColors[5]; color6Val.textContent = currentColors[5].toUpperCase(); }
    if (color7 && color7Val) { color7.value = currentColors[6]; color7Val.textContent = currentColors[6].toUpperCase(); }
    if (color8 && color8Val) { color8.value = currentColors[7]; color8Val.textContent = currentColors[7].toUpperCase(); }
  }
  
  color1 && color1.addEventListener('input', () => { currentColors[0] = color1.value; color1Val && (color1Val.textContent = color1.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color2 && color2.addEventListener('input', () => { currentColors[1] = color2.value; color2Val && (color2Val.textContent = color2.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color3 && color3.addEventListener('input', () => { currentColors[2] = color3.value; color3Val && (color3Val.textContent = color3.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color4 && color4.addEventListener('input', () => { currentColors[3] = color4.value; color4Val && (color4Val.textContent = color4.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color5 && color5.addEventListener('input', () => { currentColors[4] = color5.value; color5Val && (color5Val.textContent = color5.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color6 && color6.addEventListener('input', () => { currentColors[5] = color6.value; color6Val && (color6Val.textContent = color6.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color7 && color7.addEventListener('input', () => { currentColors[6] = color7.value; color7Val && (color7Val.textContent = color7.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color8 && color8.addEventListener('input', () => { currentColors[7] = color8.value; color8Val && (color8Val.textContent = color8.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  cursorColorSelect && cursorColorSelect.addEventListener('change', () => { 
    const idx = Math.max(1, Math.min(8, parseInt(cursorColorSelect.value, 10))) - 1; 
    cursorBallIndex = idx; 
    cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor;
    autoSaveSettings();
  });

  // Bind click-to-copy on hex badges
  bindCopyOnClick(color1Val, () => color1.value.toUpperCase());
  bindCopyOnClick(color2Val, () => color2.value.toUpperCase());
  bindCopyOnClick(color3Val, () => color3.value.toUpperCase());
  bindCopyOnClick(color4Val, () => color4.value.toUpperCase());
  bindCopyOnClick(color5Val, () => color5.value.toUpperCase());
  bindCopyOnClick(color6Val, () => color6.value.toUpperCase());
  bindCopyOnClick(color7Val, () => color7.value.toUpperCase());
  bindCopyOnClick(color8Val, () => color8.value.toUpperCase());
  // If the user changes any color, keep the cursor color stable unless it was the one changed
  // To keep behavior simple, we do not auto-switch the cursor color here.
  
  // Scene control event listeners
  cornerRadiusSlider && cornerRadiusSlider.addEventListener('input', () => { 
    cornerRadius = parseFloat(cornerRadiusSlider.value); 
    cornerRadiusVal && (cornerRadiusVal.textContent = cornerRadius.toFixed(0)); 
  });
  motionBlurFadeSlider && motionBlurFadeSlider.addEventListener('input', () => { 
    motionBlurFade = parseFloat(motionBlurFadeSlider.value); 
    motionBlurFadeVal && (motionBlurFadeVal.textContent = motionBlurFade.toFixed(3)); 
  });
  trailSubtletySlider && trailSubtletySlider.addEventListener('input', () => {
    trailSubtlety = parseFloat(trailSubtletySlider.value);
    trailSubtletyVal && (trailSubtletyVal.textContent = trailSubtlety.toFixed(2) + '×');
  });

  // Presets (10 each)
  // Rubber-focused physics presets under Earth gravity (≈1960 px/s²)
  const PHYSICS_PRESETS = {
    rubberPlayground: { label: 'Rubber – Playground', G: 1960, REST: 0.90, FRICTION: 0.0025, sizeScale: 1.8, maxBalls: 450, sizeVariation: 0.20 },
    rubberRacquet:    { label: 'Rubber – Racquetball', G: 3320, REST: 0.97, FRICTION: 0.0035, sizeScale: 0.7, maxBalls: 350, sizeVariation: 0.30 },
    rubberSuperball:  { label: 'Rubber – Superball', G: 1960, REST: 0.95, FRICTION: 0.0015, sizeScale: 1.2, maxBalls: 450, sizeVariation: 0.05 },
    rubberSoft:       { label: 'Rubber – Soft', G: 1960, REST: 0.86, FRICTION: 0.0035, sizeScale: 2.2, maxBalls: 350, sizeVariation: 0.25 },
    rubberHeavy:      { label: 'Rubber – Heavy', G: 1960, REST: 0.88, FRICTION: 0.0030, sizeScale: 2.0, maxBalls: 400, sizeVariation: 0.15 }
  };

  const SPAWN_PRESETS = {
    fullRain:       { label: 'Full Rain (top-half)', EMIT_INTERVAL: 0.030, xCenter: 50, y: -50, w: 100, h: 50 },
    narrowStrip:    { label: 'Narrow Strip Top', EMIT_INTERVAL: 0.050, xCenter: 50, y: -40, w: 20,  h: 10 },
    leftGutter:     { label: 'Left Gutter', EMIT_INTERVAL: 0.045, xCenter: 10, y: -60, w: 18,  h: 20 },
    rightGutter:    { label: 'Right Gutter', EMIT_INTERVAL: 0.045, xCenter: 90, y: -60, w: 18,  h: 20 },
    centerFountain: { label: 'Center Fountain', EMIT_INTERVAL: 0.020, xCenter: 50, y: -30, w: 30,  h: 20 },
    stormBurst:     { label: 'Storm Burst', EMIT_INTERVAL: 0.005, xCenter: 50, y: -80, w: 100, h: 30 },
    slowSnow:       { label: 'Slow Snow', EMIT_INTERVAL: 0.200, xCenter: 50, y: -30, w: 100, h: 20 },
    edgeDrizzle:    { label: 'Edge Drizzle', EMIT_INTERVAL: 0.080, xCenter: 15, y: -40, w: 30,  h: 15 },
    twinColumns:    { label: 'Twin Columns', EMIT_INTERVAL: 0.030, xCenter: 30, y: -50, w: 10,  h: 40 },
    focusedBeam:    { label: 'Focused Beam', EMIT_INTERVAL: 0.015, xCenter: 50, y: -70, w: 6,   h: 12 }
  };

  const REPELLER_PRESETS = {
    off:         { label: 'Off', r: 710,   p: 27400 * 10, s: 4.4 },
    gentle:      { label: 'Gentle Breeze', r: 120, p: 2500, s: 2.5 },
    pushField:   { label: 'Push Field', r: 240, p: 8000 * 10, s: 2.0 },
    tractor:     { label: 'Tractor Push', r: 320, p: 14000 * 10, s: 1.6 },
    magnet:      { label: 'Magnet Repel', r: 200, p: 18000 * 10, s: 3.0 },
    pulse:       { label: 'Pulse Strong', r: 280, p: 22000 * 10, s: 1.2 },
    wideSoft:    { label: 'Wide Soft', r: 500, p: 8000 * 10, s: 4.5 },
    needle:      { label: 'Needle Point', r: 80,  p: 26000 * 10, s: 0.8 },
    wall:        { label: 'Invisible Wall', r: 700, p: 16000 * 10, s: 5.0 },
    singularity: { label: 'Singularity', r: 600, p: 30000 * 10, s: 0.5 }
  };

  // Populate selects
  function fillSelect(select, dict, selectedKey) {
    select.innerHTML = '';
    for (const [key, val] of Object.entries(dict)) {
      const opt = document.createElement('option');
      opt.value = key; opt.textContent = val.label || key; if (key === selectedKey) opt.selected = true;
      select.appendChild(opt);
    }
  }

  const physicsSelect = document.getElementById('physicsSelect');
  const spawnSelect = document.getElementById('spawnSelect');
  const repellerSelect = document.getElementById('repellerSelect');

  if (physicsSelect) fillSelect(physicsSelect, PHYSICS_PRESETS, 'rubberRacquet');
  if (spawnSelect) fillSelect(spawnSelect, SPAWN_PRESETS, 'fullRain');
  if (repellerSelect) fillSelect(repellerSelect, REPELLER_PRESETS, 'off');
  // Populate color template dropdown
  if (colorSelect) fillSelect(colorSelect, COLOR_TEMPLATES, 'industrialTeal');

  // Helper function for UI updates
  function updateSliderAndValue(slider, valueElement, value, decimals = 0) {
    if (slider) slider.value = String(value);
    if (valueElement) valueElement.textContent = decimals > 0 ? value.toFixed(decimals) : value.toString();
  }

  // Reusable event listener factory for sliders
  // Removed unused slider listener factory

  // Apply preset helpers
  function applyPhysicsPreset(key) {
    const p = PHYSICS_PRESETS[key]; if (!p) return;
    // Keep gravity constant (1.1x Earth). Only apply REST and FRICTION from preset.
    REST = p.REST; FRICTION = p.FRICTION;
    MAX_BALLS = p.maxBalls; sizeVariation = p.sizeVariation;
    const newScale = p.sizeScale;
    sizeScale = newScale;
    // Recompute effective scale and proportionally resize existing balls
    updateEffectiveScaleAndBallSizes();
    // Apply mass to all balls
    for (let i=0; i<balls.length; i++) {
        balls[i].m = ballMassKg;
    }
    
    // Remove excess balls if new limit is lower (truncate efficiently)
    if (balls.length > MAX_BALLS) { balls.length = MAX_BALLS; }
    
    // Update UI efficiently (gravity is fixed; no slider to update)
    updateSliderAndValue(restitutionSlider, restitutionVal, REST, 2);
    updateSliderAndValue(frictionSlider, frictionVal, FRICTION, 4);
    updateSliderAndValue(sizeSliderGlobal, sizeValGlobal, sizeScale, 1);
    updateSliderAndValue(maxBallsSlider, maxBallsVal, MAX_BALLS, 0);
    updateSliderAndValue(sizeVariationSliderGlobal, sizeVariationValGlobal, sizeVariation, 1);
    
    // Apply the new size variation to existing balls
    updateExistingBallSizes();
  }
  function applySpawnPreset(key) {
    const s = SPAWN_PRESETS[key]; if (!s) return;
    EMIT_INTERVAL = s.EMIT_INTERVAL; SPAWN_X_CENTER_VW = s.xCenter; SPAWN_Y_VH = s.y; SPAWN_W_VW = s.w; SPAWN_H_VH = s.h;
    updateSliderAndValue(emitterSlider, emitterVal, EMIT_INTERVAL, 3);
    updateSliderAndValue(spawnCenterSlider, spawnCenterVal, SPAWN_X_CENTER_VW, 0);
    updateSliderAndValue(spawnYSlider, spawnYVal, SPAWN_Y_VH, 0);
    updateSliderAndValue(spawnWidthSlider, spawnWidthVal, SPAWN_W_VW, 0);
    updateSliderAndValue(spawnHeightSlider, spawnHeightVal, SPAWN_H_VH, 0);
  }
  function applyRepellerPreset(key) {
    const r = REPELLER_PRESETS[key]; if (!r) return;
    repelRadius = r.r; repelPower = r.p * (REPELLER_GLOBAL_MULTIPLIER / 20.0); // keep perceived strength consistent after global doubling
    repellerEnabled = (key !== 'off');
    updateSliderAndValue(repelSizeSlider, repelSizeVal, repelRadius, 0);
    // Sync slider to mapped power and label
    const sliderPos = powerToRepelSlider(repelPower);
    if (repelPowerSlider) repelPowerSlider.value = String(sliderPos);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    updateSliderAndValue(repelSoftSlider, repelSoftVal, repelSoft, 1);
  }

  // Apply sane defaults FIRST (before event listeners to avoid triggering them)
  applyPhysicsPreset('rubberRacquet');
  applySpawnPreset('fullRain');
  applyRepellerPreset('off');
  
  // Initialize color system with current palette
  updateColorPickersUI();
  syncPaletteVars();

  // Hook presets to selects AFTER applying defaults
  physicsSelect && physicsSelect.addEventListener('change', () => applyPhysicsPreset(physicsSelect.value));
  spawnSelect && spawnSelect.addEventListener('change', () => applySpawnPreset(spawnSelect.value));
  repellerSelect && repellerSelect.addEventListener('change', () => applyRepellerPreset(repellerSelect.value));

  // Now that sizeScale is set by presets, compute responsive scale once
  updateEffectiveScaleAndBallSizes();
  
  // Initialize text colliders
  updateTextColliders();
  
  // Load saved settings from localStorage
  const settingsLoaded = loadSettings();
  
  // Apply canvas shadow with loaded or default settings
  updateCanvasShadow();
  
  // Initialize dark mode based on time of day
  checkAndApplyDarkMode();
  
  // Check dark mode every minute for time transitions
  setInterval(checkAndApplyDarkMode, 60000); // Every 60 seconds
  
  // Apply device-specific mode visibility (hide Trail on mobile)
  applyDeviceSpecificModeVisibility();
  
  // Initialize mode: random mode on each page load
  if (!settingsLoaded || true) { // Always randomize mode
    const availableModes = Object.values(MODES);
    const randomMode = availableModes[Math.floor(Math.random() * availableModes.length)];
    currentMode = randomMode;
    console.log(`🎲 Random mode selected: ${randomMode}`);
  }
  setMode(currentMode);
  
  // Save settings on mode change or slider change
  window.addEventListener('beforeunload', saveSettings);
})();

  </script>
</body>
</html>