<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Refined Bravia Balls ‚Äì Canvas Physics</title>
<style>
  /* Prevent page scrolling - simulation fills viewport */
  html, body {
    overflow: hidden;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
  }
  
  /* Removed global html/body styles - simulation is self-contained within #bravia-balls */
  /* Scoped wrapper for embed friendliness and interaction hygiene */
  #bravia-balls {
    overflow: hidden; /* Critical: prevent scrollbars from canvas overflow */
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100svh; /* Default height for most modes */
    background: #cecece; /* Light mode background */
    transition: background-color 0.3s ease;
    overscroll-behavior: contain;
    -webkit-tap-highlight-color: transparent;
    user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
    pointer-events: auto !important; /* Critical: override Webflow's pointer-events: none */
  }
  #bravia-balls canvas {
    pointer-events: auto !important; /* Ensure canvas receives mouse events */
  }
  #bravia-balls.dark-mode {
    background: #0a0a0a; /* Dark mode background */
  }
  /* Ball Pit mode needs extra height for spawning above viewport */
  /* Canvas is clipped to 100svh visible area, but rendering extends to 150vh */
  #bravia-balls.mode-pit {
    height: 100svh; /* Keep visible area at 100svh (no scrollbars) */
  }
  #bravia-balls.mode-pit canvas {
    height: 150vh; /* Canvas renders 150vh for ball spawning above */
  }
  #bravia-balls canvas { 
    display: block; 
    width: 100vw; /* Full viewport width */
    height: 100svh; /* Full small viewport height */
    position: absolute;
    bottom: 0;
    left: 0;
    -webkit-user-drag: none;
    user-select: none; 
    -webkit-user-select: none;
    touch-action: none;
    cursor: none;
    /* Shadow applied dynamically via JavaScript */
  }
  @media (prefers-reduced-motion: reduce) { 
    #bravia-balls canvas { filter: none; } 
  }
  #bravia-balls .panel {
    position: fixed;
    top: 5vh;
    right: 5vh;
    color: #fff;
    font: 10px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    background: rgba(0,0,0,0.45);
    padding: 6px;
    border-radius: 6px;
    user-select: none;
    display: flex;
    flex-direction: column;
    gap: 4px;
    z-index: 10;
    max-height: 90vh;
    overflow: auto;
    backdrop-filter: blur(6px);
    cursor: move;
    min-width: 200px;
    transition: background-color 0.3s ease, border-color 0.3s ease;
  }
  #bravia-balls.dark-mode .panel {
    background: rgba(20,20,20,0.75);
    border: 1px solid rgba(255,255,255,0.15);
  }
  #bravia-balls .panel.hidden { display: none; }
  #bravia-balls .panel .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 6px;
    background: rgba(255,255,255,0.05);
    border-radius: 4px;
    margin-bottom: 4px;
    cursor: move;
    font-weight: 600;
    font-size: 11px;
  }
  #bravia-balls .panel .panel-header .drag-handle {
    opacity: 0.5;
    margin-right: 6px;
  }
  #bravia-balls .panel label {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 4px;
    width: 200px;
    font-size: 9px;
  }
  #bravia-balls .panel label span:first-child {
    flex-shrink: 0;
    max-width: 90px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  #bravia-balls .panel input[type="range"] {
    flex: 1;
    min-width: 60px;
    height: 12px;
  }
  #bravia-balls .panel span.val {
    width: 42px;
    text-align: right;
    font-family: monospace;
    font-size: 9px;
  }
  #bravia-balls .panel span.hex-val {
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    font-size: 10px;
    color: #888;
    background: rgba(0,0,0,0.05);
    padding: 1px 4px;
    border-radius: 2px;
    margin-left: 4px;
    text-transform: uppercase;
    cursor: pointer;
  }
  #bravia-balls .panel code {
    font-family: monospace;
    background: rgba(255,255,255,0.1);
    padding: 1px 3px;
    border-radius: 3px;
    font-size: 9px;
  }
  #bravia-balls .panel details { background: rgba(255,255,255,0.04); border-radius: 4px; padding: 4px; }
  #bravia-balls .panel summary { cursor: pointer; list-style: none; outline: none; font-size: 10px; }
  #bravia-balls .panel summary::-webkit-details-marker { display: none; }
  #bravia-balls .panel summary { display:flex; align-items:center; justify-content:space-between; color:#b8c2c7; padding: 2px; }
  #bravia-balls .panel .group { display:flex; flex-direction:column; gap:4px; margin-top:4px; }
  #bravia-balls .panel button {
    font-size: 9px;
    padding: 4px 8px;
  }
  #bravia-balls .panel select {
    font-size: 9px;
    padding: 2px 4px;
  }
  #bravia-balls .panel input[type="color"] {
    width: 28px;
    height: 20px;
    border: none;
    border-radius: 3px;
    padding: 0;
  }
  
  /* Mode switcher - segmented control */
  #bravia-balls .mode-switcher {
    display: flex;
    background: rgba(0,0,0,0.3);
    border-radius: 4px;
    padding: 1px;
    gap: 1px;
    margin-bottom: 6px;
  }
  #bravia-balls .mode-button {
    flex: 1;
    padding: 4px 6px;
    background: transparent;
    border: none;
    border-radius: 3px;
    color: rgba(255,255,255,0.6);
    font-size: 9px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
  }
  #bravia-balls .mode-button:hover {
    background: rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.8);
  }
  #bravia-balls .mode-button.active {
    background: rgba(255,255,255,0.15);
    color: #ffffff;
    font-weight: 600;
  }
  #bravia-balls .mode-controls { display: none; }
  #bravia-balls .mode-controls.active { display: block; }
  
  /* Palette variables (defaults match 'industrialTeal') */
  :root {
    --ball-1: #b7bcb7;
    --ball-2: #e4e9e4;
    --ball-3: #ffffff;
    --ball-4: #00695c;
    --ball-5: #000000;
    --ball-6: #ff4013;
    --ball-7: #0d5cb6;
    --ball-8: #ffa000;
  }
  /* Utility classes for using the palette elsewhere on the page */
  .text-ball-1 { color: var(--ball-1); }
  .text-ball-2 { color: var(--ball-2); }
  .text-ball-3 { color: var(--ball-3); }
  .text-ball-4 { color: var(--ball-4); }
  .text-ball-5 { color: var(--ball-5); }
  .text-ball-6 { color: var(--ball-6); }
  .text-ball-7 { color: var(--ball-7); }
  .text-ball-8 { color: var(--ball-8); }
  .bg-ball-1 { background-color: var(--ball-1); }
  .bg-ball-2 { background-color: var(--ball-2); }
  .bg-ball-3 { background-color: var(--ball-3); }
  .bg-ball-4 { background-color: var(--ball-4); }
  .bg-ball-5 { background-color: var(--ball-5); }
  .bg-ball-6 { background-color: var(--ball-6); }
  .bg-ball-7 { background-color: var(--ball-7); }
  .bg-ball-8 { background-color: var(--ball-8); }
  .border-ball-1 { border-color: var(--ball-1); }
  .border-ball-2 { border-color: var(--ball-2); }
  .border-ball-3 { border-color: var(--ball-3); }
  .border-ball-4 { border-color: var(--ball-4); }
  .border-ball-5 { border-color: var(--ball-5); }
  .border-ball-6 { border-color: var(--ball-6); }
  .border-ball-7 { border-color: var(--ball-7); }
  .border-ball-8 { border-color: var(--ball-8); }
</style>
</head>
<body>
<div id="bravia-balls">
  <canvas id="c" aria-label="Interactive bouncy balls physics simulation" role="application" draggable="false"></canvas>
  <div class="panel" id="controlPanel" role="region" aria-label="Simulation controls" tabindex="-1">
  
  <!-- Draggable header -->
  <div class="panel-header" id="panelHeader" role="banner">
    <span><span class="drag-handle" aria-hidden="true">‚ãÆ‚ãÆ</span>Controls</span>
    <button style="cursor: pointer; opacity: 0.7; background: none; border: none; color: inherit; font-size: 16px; padding: 0;" id="minimizePanel" title="Toggle panel" aria-label="Toggle control panel" aria-expanded="true">‚àí</button>
  </div>
  
  <!-- Screen reader announcements -->
  <div role="status" aria-live="polite" aria-atomic="true" style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;" id="announcer"></div>
  
  <!-- 120 FPS Performance Mode Toggle (TOP PRIORITY) -->
  <div style="margin-bottom: 12px; padding: 8px; background: rgba(255,0,0,0.15); border-radius: 4px; border: 1px solid rgba(255,0,0,0.3);">
    <label style="display: flex; align-items: center; cursor: pointer; font-weight: 600; font-size: 11px;">
      <input type="checkbox" id="performanceModeToggle" style="margin-right: 8px; cursor: pointer;">
      <span>‚ö° 120 FPS Performance Mode</span>
    </label>
    <div style="font-size: 9px; opacity: 0.7; margin-top: 6px; line-height: 1.3;">
      Aggressive optimizations: reduces balls, disables glass morphism, targets 120 FPS
    </div>
    <div id="performanceModeStatus" style="font-size: 9px; margin-top: 6px; padding: 4px; background: rgba(0,0,0,0.2); border-radius: 3px; font-family: monospace;">
      üé® Normal Mode (350 balls)
    </div>
  </div>
  
  <!-- Dark Mode Toggle -->
  <div style="margin-bottom: 12px; padding: 8px; background: rgba(100,100,255,0.15); border-radius: 4px; border: 1px solid rgba(100,100,255,0.3);">
    <label style="display: flex; align-items: center; cursor: pointer; font-weight: 600; font-size: 11px;">
      <input type="checkbox" id="darkModeToggle" style="margin-right: 8px; cursor: pointer;">
      <span>üåô Auto Dark Mode</span>
    </label>
    <div style="font-size: 9px; opacity: 0.7; margin-top: 6px; line-height: 1.3;">
      Automatically enables dark background from sunset (6 PM) to sunrise (6 AM)
    </div>
    <div id="darkModeStatus" style="font-size: 9px; margin-top: 6px; padding: 4px; background: rgba(0,0,0,0.2); border-radius: 3px; font-family: monospace;">
      ‚òÄÔ∏è Day Mode
    </div>
  </div>
  
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- GLOBAL SETTINGS (apply to ALL modes) - ABOVE MODE SWITCHER             -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  
  <details open>
    <summary>üåê Global Ball Properties</summary>
    <div class="group">
        <label title="Global ball size scale (0.1-6.0). Smaller = more balls fit, larger = more dramatic collisions">Size: <span class="val" id="sizeValGlobal">1.2</span><input type="range" id="sizeSliderGlobal" min="0.1" max="6.0" step="0.05" value="1.2"></label>
        <label title="Ball deformation on collision (0-100). 0 = rigid/hard, 100 = very soft/squishy">Softness: <span class="val" id="ballSoftnessValGlobal">20</span><input type="range" id="ballSoftnessSliderGlobal" min="0" max="100" step="1" value="20"></label>
        <div style="font-size: 9px; opacity: 0.7; margin-top: 4px;">Softness: 0 = rigid, 20 = subtle, 100 = very squishy</div>
    </div>
  </details>
  
  <!-- Build Controls -->
  <div style="margin-bottom: 12px; padding: 8px; background: rgba(0,255,0,0.1); border-radius: 4px; text-align: center;">
    <button id="saveConfigBtn" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold; margin-right: 8px;">üíæ Save Config</button>
    <button id="buildBtn" style="background: #2196F3; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">üöÄ Build Embed</button>
    <div style="font-size: 9px; opacity: 0.7; margin-top: 6px; line-height: 1.3;">Save downloads current-config.json ‚Üí replace in source/ folder</div>
    <div id="configOutput" style="margin-top: 8px; font-family: monospace; font-size: 10px; color: #333; max-height: 120px; overflow-y: auto; display: none; text-align: left; background: rgba(255,255,255,0.8); padding: 6px; border-radius: 3px;"></div>
    </div>
  
  <details open>
    <summary>üé® Colors</summary>
    <div class="group">
        <label>Color template: <select id="colorSelect"></select></label>
        <label>Color 1 (50%): <input type="color" id="color1" value="#ffffff"> <span class="hex-val" id="color1Val">#ffffff</span></label>
        <label>Color 2 (25%): <input type="color" id="color2" value="#f8f9fa"> <span class="hex-val" id="color2Val">#f8f9fa</span></label>
        <label>Color 3 (12%): <input type="color" id="color3" value="#e9ecef"> <span class="hex-val" id="color3Val">#e9ecef</span></label>
        <label>Color 4 (6%): <input type="color" id="color4" value="#d90429"> <span class="hex-val" id="color4Val">#d90429</span></label>
        <label>Color 5 (3%): <input type="color" id="color5" value="#000000"> <span class="hex-val" id="color5Val">#000000</span></label>
        <label>Color 6 (2%): <input type="color" id="color6" value="#54d4ff"> <span class="hex-val" id="color6Val">#54d4ff</span></label>
        <label>Color 7 (1%): <input type="color" id="color7" value="#b589ff"> <span class="hex-val" id="color7Val">#b589ff</span></label>
        <label>Color 8 (1%): <input type="color" id="color8" value="#ffc27a"> <span class="hex-val" id="color8Val">#ffc27a</span></label>
        <label>Cursor color:
          <select id="cursorColorSelect">
            <option value="1">Color 1</option>
            <option value="2">Color 2</option>
            <option value="3">Color 3</option>
            <option value="4">Color 4</option>
            <option value="5" selected>Color 5 (highlight)</option>
            <option value="6">Color 6</option>
            <option value="7">Color 7</option>
            <option value="8">Color 8</option>
          </select>
        </label>
        <div style="font-size: 9px; opacity: 0.7; margin-top: 4px;">Colors appear by weight: 1 is most common, 8 is rarest</div>
    </div>
  </details>
  
  <details open>
    <summary>üåë Canvas Shadow</summary>
    <div class="group">
      <label title="Enable/disable canvas drop-shadow filter">
        <span>Shadow enabled</span>
        <input type="checkbox" id="canvasShadowEnabled">
      </label>
      <label title="Shadow horizontal offset (-20 to 20px)">
        <span>Shadow X offset (px)</span>
        <input type="range" id="shadowOffsetX" min="-20" max="20" step="0.1" value="1">
        <span class="val" id="shadowOffsetXVal">1</span>
      </label>
      <label title="Shadow vertical offset (-20 to 20px)">
        <span>Shadow Y offset (px)</span>
        <input type="range" id="shadowOffsetY" min="-20" max="20" step="0.1" value="1">
        <span class="val" id="shadowOffsetYVal">1</span>
      </label>
      <label title="Shadow blur radius (0-30px)">
        <span>Shadow blur (px)</span>
        <input type="range" id="shadowBlur" min="0" max="30" step="0.1" value="0">
        <span class="val" id="shadowBlurVal">0</span>
          </label>
      <label title="Shadow opacity (0-1)">
        <span>Shadow opacity</span>
        <input type="range" id="shadowOpacity" min="0" max="1" step="0.01" value="0.29">
        <span class="val" id="shadowOpacityVal">0.29</span>
          </label>
      <label title="Shadow color">
        <span>Shadow color</span>
        <input type="color" id="shadowColor" value="#000000">
        <span class="hex-val" id="shadowColorVal">#000000</span>
          </label>
      <label title="Additional shadow layer for depth">
        <span>Second shadow enabled</span>
        <input type="checkbox" id="shadow2Enabled">
          </label>
      <label title="Second shadow blur (0-20px)">
        <span>Shadow 2 blur (px)</span>
        <input type="range" id="shadow2Blur" min="0" max="20" step="1" value="4">
        <span class="val" id="shadow2BlurVal">4</span>
          </label>
      <label title="Second shadow opacity (0-1)">
        <span>Shadow 2 opacity</span>
        <input type="range" id="shadow2Opacity" min="0" max="1" step="0.01" value="0.10">
        <span class="val" id="shadow2OpacityVal">0.10</span>
          </label>
    </div>
  </details>
  
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!--                        MODE SWITCHER & MODE SETTINGS                     -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  
  <div style="margin: 20px 0; padding: 12px 0; border-top: 1px solid rgba(255,255,255,0.15);">
    <div style="text-align: center; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; opacity: 0.6; margin-bottom: 12px;">
      Mode Settings
    </div>
    
    <!-- Mode Switcher -->
    <div class="mode-switcher" style="margin-bottom: 16px;" role="group" aria-label="Simulation mode selector">
      <button class="mode-button active" data-mode="pit" aria-label="Ball Pit mode" aria-pressed="true">üéØ Pit</button>
      <button class="mode-button" data-mode="flies" aria-label="Flies to Light mode" aria-pressed="false">üïäÔ∏è Flies</button>
      <button class="mode-button" data-mode="weightless" aria-label="Zero Gravity mode" aria-pressed="false">üåå Zero-G</button>
      <button class="mode-button" data-mode="pulse-grid" aria-label="Pulse Grid mode" aria-pressed="false">üéπ Pulse</button>
      <button class="mode-button" data-mode="vortex" aria-label="Vortex Spiral mode" aria-pressed="false">üåÄ Vortex</button>
    </div>
  </div>
  
  <div id="pitControls" class="mode-controls active">
    <details open>
      <summary>üéØ Ball Pit Mode</summary>
      <div class="group">
        <label title="Choose physics preset (Rubber, Bouncy, etc.)">
          <span>Physics template</span>
          <select id="physicsSelect"></select>
        </label>
        <label title="Gravity strength (0.0-2.0√ó Earth gravity). Config: 0 = zero gravity (weightless)">
          <span>Gravity (√óEarth)</span>
          <input type="range" id="gravityPitSlider" min="0.0" max="2.0" step="0.05" value="0.0">
          <span class="val" id="gravityPitVal">0.0</span>
        </label>
        <label title="Ball mass/weight (50-200 grams). Config: 19.8g for lighter feel">
          <span>Weight (grams)</span>
          <input type="range" id="weightPitSlider" min="10.0" max="200.0" step="1.0" value="19.8">
          <span class="val" id="weightPitVal">19.8</span>
        </label>
        <label title="Bounce restitution (0.0-1.0). Config: 0.97 for bouncier feel">
          <span>Bounciness</span>
          <input type="range" id="restitutionSlider" min="0.00" max="1.00" step="0.01" value="0.97">
          <span class="val" id="restitutionVal">0.97</span>
        </label>
        <label title="Air resistance/friction (0.000-0.010). Config: 0.0035 for light drag">
          <span>Air friction</span>
          <input type="range" id="frictionSlider" min="0.000" max="0.010" step="0.0005" value="0.0035">
          <span class="val" id="frictionVal">0.0035</span>
        </label>
      </div>
    </details>
    <details open>
      <summary>üñºÔ∏è Scene & Effects</summary>
      <div class="group">
        <label title="Maximum number of balls in simulation (50-800). Higher = more crowded. Config: 350 for zero-gravity">
          <span>Max balls</span>
          <input type="range" id="maxBallsSlider" min="50" max="800" step="25" value="350">
          <span class="val" id="maxBallsVal">350</span>
        </label>
        <label title="Rounded corner radius for viewport (0-50 pixels). 0 = sharp corners">
          <span>Corner radius (px)</span>
          <input type="range" id="cornerRadiusSlider" min="0" max="50" step="2" value="0">
          <span class="val" id="cornerRadiusVal">0</span>
        </label>
        <label title="Motion blur trail length (0.0-0.5). Config: 0.025 for subtle trails">
          <span>Motion blur</span>
          <input type="range" id="trailFadeSlider" min="0.000" max="0.500" step="0.005" value="0.025">
          <span class="val" id="trailFadeVal">0.025</span>
        </label>
        <label title="Motion blur intensity (0.5-2.0√ó). Config: 1.8√ó for pronounced trails">
          <span>Blur intensity</span>
          <input type="range" id="trailSubtletySlider" min="0.50" max="2.00" step="0.05" value="1.80">
          <span class="val" id="trailSubtletyVal">1.80√ó</span>
        </label>
        <div style="font-size: 9px; opacity: 0.7; margin-top: 4px;">Motion blur works in all modes</div>
      </div>
    </details>
    <details open>
      <summary>üéØ Spawn Settings</summary>
      <div class="group">
        <label title="Choose spawn behavior preset">
          <span>Spawn template</span>
          <select id="spawnSelect"></select>
        </label>
        <label title="Time between ball spawns (0.01-0.5 seconds). Lower = more frequent">
          <span>Emit interval (s)</span>
          <input type="range" id="emitterSlider" min="0.010" max="0.500" step="0.005" value="0.04">
          <span class="val" id="emitterVal">0.04</span>
        </label>
        <label title="Vertical spawn position (-100 to 100% viewport height). Negative = above viewport">
          <span>Spawn Y position (%)</span>
          <input type="range" id="spawnYSlider" min="-100" max="100" step="5" value="-50">
          <span class="val" id="spawnYVal">-50</span>
        </label>
        <label title="Horizontal spawn area width (10-100% viewport width). 100% = full width">
          <span>Spawn width (%)</span>
          <input type="range" id="spawnWidthSlider" min="10" max="100" step="5" value="100">
          <span class="val" id="spawnWidthVal">100</span>
        </label>
        <label title="Horizontal spawn center position (0-100% viewport width). 50% = center">
          <span>Spawn X center (%)</span>
          <input type="range" id="spawnCenterSlider" min="0" max="100" step="5" value="50">
          <span class="val" id="spawnCenterVal">50</span>
        </label>
        <label title="Vertical spawn area height (10-100% viewport height)">
          <span>Spawn height (%)</span>
          <input type="range" id="spawnHeightSlider" min="10" max="100" step="5" value="50">
          <span class="val" id="spawnHeightVal">50</span>
        </label>
      </div>
    </details>
    <details open>
      <summary>üß≤ Mouse Repeller</summary>
      <div class="group">
        <label title="Choose repeller behavior preset">
          <span>Repeller template</span>
          <select id="repellerSelect"></select>
        </label>
        <label title="Enable/disable mouse repeller effect">
          <span>Repeller active</span>
          <input type="checkbox" id="repellerEnabledPit" checked>
        </label>
        <label title="Repeller influence radius (50-1000 pixels). Larger = affects more balls">
          <span>Repel size (px)</span>
          <input type="range" id="repelSizeSlider" min="50" max="1000" step="5" value="710">
          <span class="val" id="repelSizeVal">710</span>
        </label>
        <label title="Repulsion strength (0-10000). Higher = stronger push away from mouse">
          <span>Repel power</span>
          <input type="range" id="repelPowerSlider" min="0" max="10000" step="100" value="7920">
          <span class="val" id="repelPowerVal">274000</span>
        </label>
        <label title="Repeller field softness (0.5-5.0). Lower = sharper cutoff, higher = gradual fade">
          <span>Repel softness</span>
          <input type="range" id="repelSoftSlider" min="0.5" max="5.0" step="0.1" value="2.0">
          <span class="val" id="repelSoftVal">2.0</span>
        </label>
      </div>
    </details>
  </div>
  
  <div id="fliesControls" class="mode-controls">
    <details open>
      <summary>üïäÔ∏è Flies to Light Mode</summary>
      <div class="group">
        <label title="Attraction strength toward mouse (100-8000). Higher = stronger pull toward cursor">
          <span>Attraction power</span>
          <input type="range" id="attractPowerSlider" min="100" max="8000" step="50" value="5000">
          <span class="val" id="attractPowerVal">5000</span>
        </label>
        <label title="Orbit distance around mouse (50-400 pixels). Larger = wider swarm formation">
          <span>Orbit radius (px)</span>
          <input type="range" id="orbitRadiusSlider" min="50" max="400" step="10" value="180">
          <span class="val" id="orbitRadiusVal">180</span>
        </label>
        <label title="Swarm movement speed (0.2-5.0√ó). Higher = faster, more responsive">
          <span>Swarm speed (√ó)</span>
          <input type="range" id="swarmSpeedSlider" min="0.2" max="5.0" step="0.1" value="0.4">
          <span class="val" id="swarmSpeedVal">0.4</span>
        </label>
      </div>
    </details>
  </div>
  
  <!-- Weightless Mode Controls -->
  <div id="weightlessControls" class="mode-controls">
    <details open>
      <summary>üåå Zero-G Mode</summary>
      <div class="group">
        <label title="Number of balls in scene (20-200). Fixed count, no spawning">
          <span>Ball count</span>
          <input type="range" id="weightlessCountSlider" min="20" max="200" step="10" value="80">
          <span class="val" id="weightlessCountVal">80</span>
        </label>
        <label title="Initial velocity magnitude (100-600 pixels/second). Realistic space: 200-300. Higher = faster motion">
          <span>Initial speed (px/s)</span>
          <input type="range" id="weightlessSpeedSlider" min="100" max="600" step="25" value="250">
          <span class="val" id="weightlessSpeedVal">250</span>
        </label>
        <label title="Wall bounce elasticity (0.8-1.0). Realistic space: 0.95-0.98. 1.0 = perfect energy conservation">
          <span>Bounce elasticity</span>
          <input type="range" id="weightlessBounceSlider" min="0.8" max="1.0" step="0.01" value="0.97">
          <span class="val" id="weightlessBounceVal">0.97</span>
        </label>
      </div>
    </details>
    <details open>
      <summary>üß≤ Mouse Repeller</summary>
      <div class="group">
        <label title="Repeller strength (0-10000). 0 = disabled. Controls how strongly balls are pushed away from cursor">
          <span>Repeller power</span>
          <input type="range" id="weightlessRepelSlider" min="0" max="10000" step="100" value="300">
          <span class="val" id="weightlessRepelVal">300</span>
        </label>
        <label title="Repeller radius (50-300 pixels). Larger = wider push area around cursor">
          <span>Repeller radius (px)</span>
          <input type="range" id="weightlessRepelRadiusSlider" min="50" max="300" step="10" value="150">
          <span class="val" id="weightlessRepelRadiusVal">150</span>
        </label>
      </div>
    </details>
  </div>
  
  <!-- Pulse Grid Mode Controls -->
  <div id="pulseGridControls" class="mode-controls">
    <details open>
      <summary>üéπ Pulse Grid Mode</summary>
      <div class="group">
        <label title="Choose animation preset">
          <span>Animation preset</span>
          <select id="gridPresetSelect">
            <option value="synchronized">‚ú® Synchronized Pulse</option>
            <option value="organic" selected>üåø Organic Flow</option>
            <option value="chaotic">‚ö° Chaotic Dance</option>
          </select>
        </label>
        <label title="Number of balls in grid (40-200)">
          <span>Ball count</span>
          <input type="range" id="gridBallCountSlider" min="40" max="200" step="10" value="120">
          <span class="val" id="gridBallCountVal">120</span>
        </label>
        <label title="Number of columns in the grid (20-80). More columns = smaller cells">
          <span>Grid columns</span>
          <input type="range" id="gridColumnsSlider" min="20" max="80" step="5" value="40">
          <span class="val" id="gridColumnsVal">40</span>
        </label>
      </div>
    </details>
    <details open>
      <summary>‚ö° Movement & Rhythm</summary>
      <div class="group">
        <label title="Time between movements in seconds (0.2-2.0). Lower = faster rhythm">
          <span>Beat interval (s)</span>
          <input type="range" id="pulseIntervalSlider" min="0.2" max="2.0" step="0.1" value="0.8">
          <span class="val" id="pulseIntervalVal">0.8</span>
        </label>
        <label title="Jump animation duration (0.1-1.0 seconds). Should be less than beat interval">
          <span>Jump speed (s)</span>
          <input type="range" id="pulseSpeedSlider" min="0.1" max="1.0" step="0.05" value="0.25">
          <span class="val" id="pulseSpeedVal">0.25</span>
        </label>
        <label title="Minimum grid cells to move (1-3)">
          <span>Min steps</span>
          <input type="range" id="pulseMinStepsSlider" min="1" max="3" step="1" value="1">
          <span class="val" id="pulseMinStepsVal">1</span>
        </label>
        <label title="Maximum grid cells to move (1-5)">
          <span>Max steps</span>
          <input type="range" id="pulseMaxStepsSlider" min="1" max="5" step="1" value="3">
          <span class="val" id="pulseMaxStepsVal">3</span>
        </label>
      </div>
    </details>
    <details open>
      <summary>üé≠ Coordination & Chaos</summary>
      <div class="group">
        <label title="Movement synchronization (0-1). 0 = all balls move together, 1 = completely random timing">
          <span>Synchronicity</span>
          <input type="range" id="pulseSynchronicitySlider" min="0.0" max="1.0" step="0.05" value="0.3">
          <span class="val" id="pulseSynchronicityVal">0.30</span>
        </label>
        <label title="Movement variation (0-1). 0 = uniform, 1 = chaotic and unpredictable">
          <span>Randomness</span>
          <input type="range" id="pulseRandomnessSlider" min="0.0" max="1.0" step="0.05" value="0.4">
          <span class="val" id="pulseRandomnessVal">0.40</span>
        </label>
      </div>
    </details>
    <details open>
      <summary>ü§ñ Animation Style</summary>
      <div class="group">
        <label title="Animation easing style">
          <span>Easing style</span>
          <select id="pulseEasingSelect">
            <option value="linear">Linear (Constant speed)</option>
            <option value="snap" selected>Snap (Robotic)</option>
            <option value="bounce">Bounce (Elastic)</option>
            <option value="smooth">Smooth (Ease in-out)</option>
          </select>
        </label>
        <label title="Overshoot amount (1.0-1.3). 1.0 = no overshoot, 1.2 = 20% overshoot for robotic snap">
          <span>Overshoot</span>
          <input type="range" id="pulseOvershootSlider" min="1.0" max="1.3" step="0.01" value="1.08">
          <span class="val" id="pulseOvershootVal">1.08</span>
        </label>
        <label title="Bounce-back intensity (0-0.5). Higher = more pronounced settle-back effect">
          <span>Bounce intensity</span>
          <input type="range" id="pulseBounceSlider" min="0.0" max="0.5" step="0.01" value="0.15">
          <span class="val" id="pulseBounceVal">0.15</span>
        </label>
      </div>
    </details>
  </div>
  
  <!-- Vortex Mode Controls -->
  <div id="vortexControls" class="mode-controls">
    <details open>
      <summary>üåÄ Vortex Spiral Mode</summary>
      <div class="group">
        <label title="Number of orbiting balls (50-300)">
          <span>Ball count</span>
          <input type="range" id="vortexBallCountSlider" min="50" max="300" step="10" value="200">
          <span class="val" id="vortexBallCountVal">200</span>
        </label>
        <label title="Central gravity well strength (1000-15000)">
          <span>Well strength</span>
          <input type="range" id="vortexWellStrengthSlider" min="1000" max="15000" step="500" value="8000">
          <span class="val" id="vortexWellStrengthVal">8000</span>
        </label>
        <label title="Mouse cursor gravity well strength (0-10000)">
          <span>Mouse strength</span>
          <input type="range" id="vortexMouseStrengthSlider" min="0" max="10000" step="500" value="3000">
          <span class="val" id="vortexMouseStrengthVal">3000</span>
        </label>
        <label title="Initial orbital velocity (50-400 px/s)">
          <span>Initial speed</span>
          <input type="range" id="vortexInitialSpeedSlider" min="50" max="800" step="10" value="450">
          <span class="val" id="vortexInitialSpeedVal">450</span>
        </label>
        <label title="Orbital decay rate (-0.001 to 0.001). Positive = spiral in, negative = spiral out">
          <span>Orbital decay</span>
          <input type="range" id="vortexDecaySlider" min="-0.001" max="0.001" step="0.0001" value="0.0001">
          <span class="val" id="vortexDecayVal">0.0001</span>
        </label>
        <label title="Color balls based on speed (blue=slow, red=fast)">
          <span>Speed coloring</span>
          <input type="checkbox" id="vortexSpeedColorCheckbox" checked>
        </label>
      </div>
    </details>
    
    <!-- Save & Reset Controls -->
    <div style="margin-top: 16px; padding-top: 16px; border-top: 2px solid rgba(255,255,255,0.15);">
      <button id="resetBtn" style="padding: 10px 16px; background: #ff6b47; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600; width: 100%; font-size: 14px;">üîÑ Reset to Defaults</button>
      <div style="font-size: 9px; opacity: 0.7; margin-top: 8px; text-align: center;">Clears saved settings & reloads with defaults</div>
    </div>
  </div>
  
    <div style="font-size:10px; opacity:0.8;">Press <code>R</code> to reset ‚Ä¢ <code>/</code> toggle panel ‚Ä¢ <code>1-5</code> switch modes</div>
  </div>
  
  <!-- FPS Counter -->
  <div id="fps-counter" style="position: fixed; top: 5vh; left: 5vh; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 4px; font-family: monospace; font-size: 12px; z-index: 1001; backdrop-filter: blur(6px); line-height: 1.4;">
    Render: <span id="render-fps">--</span> fps<br>
    Physics: <span id="physics-fps">--</span> fps<br>
  </div>
</div>
<script>
// Version: 2024-10-02 - 5-mode system (Ball Pit, Flies, Zero-G, Pulse Grid, Vortex)
(() => {
  // Behavior modes with device availability
  const MODES = {
    PIT: 'pit',          // Ball Pit: gravity + repeller
    FLIES: 'flies',      // Flies to Light: attraction to mouse, no gravity
    WEIGHTLESS: 'weightless',  // Weightless Bounce: zero-G bouncing balls
    PULSE_GRID: 'pulse-grid',   // Pulse Grid: rhythmic grid-based movement
    VORTEX: 'vortex'     // Vortex Spiral: orbital mechanics with gravity wells
  };
  
  // Mode availability by device type
  const MODE_AVAILABILITY = {
    [MODES.PIT]: { desktop: true, mobile: true },
    [MODES.FLIES]: { desktop: true, mobile: true },
    [MODES.WEIGHTLESS]: { desktop: true, mobile: true },
    [MODES.PULSE_GRID]: { desktop: true, mobile: true },
    [MODES.VORTEX]: { desktop: true, mobile: true }
  };
  
  let currentMode = MODES.PIT;
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // GLOBAL PARAMETERS (apply to all modes)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  let ballSoftness = 20; // 0-100: controls squash/stretch on collision (0=hard, 100=very squishy)
  
  // Mode-specific parameters
  // Ball Pit mode parameters - REALISTIC RUBBER BALL PHYSICS
  let gravityMultiplierPit = 1.05; // Lighter, floatier feel (updated from config)
  let repellerEnabledPit = true;
  
  // Flies mode parameters - REALISTIC INSECT FLIGHT (mosquitoes/gnats)
  let attractionPower = 5000; // Much faster: insects dart quickly toward light
  let orbitRadius = 180; // Wider: insects don't cluster tightly
  let swarmSpeed = 0.4; // Slower, more graceful movement
  
  // Weightless mode parameters - REALISTIC SPACE PHYSICS
  let weightlessCount = 80; // fixed number of balls
  let weightlessInitialSpeed = 250; // Slightly faster for visible motion in zero-g
  let weightlessBounce = 0.97; // Very elastic but not perfect (micro-imperfections)
  let weightlessRepellerPower = 300; // subtle mouse repeller strength
  let weightlessRepellerRadius = 150; // repeller radius (px)
  
  // Pulse Grid mode parameters - RHYTHMIC GRID-BASED MOVEMENT
  let gridColumns = 40; // Number of columns in the grid (width)
  let gridCellAspect = 1.0; // Cell aspect ratio (1.0 = square cells)
  let pulseInterval = 0.8; // Time between movements (seconds) - the "beat"
  let pulseSpeed = 0.25; // Duration of jump animation (seconds)
  let pulseSynchronicity = 0.3; // How synchronized movements are (0=all sync, 1=random)
  let pulseRandomness = 0.4; // Movement variation and jitter (0=uniform, 1=chaotic)
  let pulseMinSteps = 1; // Minimum grid cells to move per pulse
  let pulseMaxSteps = 3; // Maximum grid cells to move per pulse
  let gridBallCount = 120; // Number of balls in grid mode
  let pulseBounceIntensity = 0.15; // Bounce-back effect strength (0=none, 1=extreme)
  let pulseEasingStyle = 'snap'; // Easing style: 'linear', 'snap', 'bounce'
  let pulseOvershoot = 1.08; // Overshoot multiplier for robotic feel (1.0=none, 1.2=20% overshoot)
  
  // Vortex mode parameters - ORBITAL MECHANICS
  let vortexWellStrength = 8000; // Central gravity well strength (increased for stronger spin)
  let vortexBallCount = 200; // Number of orbiting balls
  let vortexInitialSpeed = 450; // Initial orbital velocity (px/s) - faster for dramatic effect
  let vortexDecayRate = 0.0001; // Orbital decay (reduced for more stable orbits)
  let vortexMouseWellStrength = 3000; // Mouse cursor gravity well strength
  let vortexTrailLength = 0; // Trail fade (0=no trails, 0.1=long trails)
  let vortexSpeedColorEnabled = false; // Color balls based on speed (disabled for palette colors)
  
  let cursorBallVisible = true;       // Show cursor ball on desktop
  
  // Canvas shadow filter parameters
  let canvasShadowEnabled = false;
  let shadowOffsetX = 1;
  let shadowOffsetY = 1;
  let shadowBlur = 0;
  let shadowOpacity = 0.29;
  let shadowColor = '#000000';
  let shadow2Enabled = false;
  let shadow2Blur = 4;
  let shadow2Opacity = 0.10;
  
  // Mass constants (needed before CONSTANTS object)
  const MASS_BASELINE_KG = 1.0; // reference mass for scaling drag/forces
  
  // Configuration validation schema
  const CONFIG_SCHEMA = {
    gridColumns: { min: 20, max: 80, type: 'integer', default: 40 },
    gridBallCount: { min: 40, max: 200, type: 'integer', default: 120 },
    pulseInterval: { min: 0.2, max: 2.0, type: 'number', default: 0.8 },
    pulseSpeed: { min: 0.1, max: 1.0, type: 'number', default: 0.25 },
    pulseSynchronicity: { min: 0, max: 1, type: 'number', default: 0.3 },
    pulseRandomness: { min: 0, max: 1, type: 'number', default: 0.4 },
    pulseMinSteps: { min: 1, max: 3, type: 'integer', default: 1 },
    pulseMaxSteps: { min: 1, max: 5, type: 'integer', default: 3 },
    pulseOvershoot: { min: 1.0, max: 1.3, type: 'number', default: 1.08 },
    pulseBounceIntensity: { min: 0, max: 0.5, type: 'number', default: 0.15 },
    shadowOffsetX: { min: -20, max: 20, type: 'integer', default: 0 },
    shadowOffsetY: { min: -20, max: 20, type: 'integer', default: 4 },
    shadowBlur: { min: 0, max: 30, type: 'integer', default: 12 },
    shadowOpacity: { min: 0, max: 1, type: 'number', default: 0.15 },
    shadow2Blur: { min: 0, max: 20, type: 'integer', default: 4 },
    shadow2Opacity: { min: 0, max: 1, type: 'number', default: 0.10 }
  };
  
  /**
   * Validate and clamp configuration value
   * @param {string} key - Configuration parameter name
   * @param {*} value - Value to validate
   * @returns {*} Validated and clamped value
   */
  function validateConfigValue(key, value) {
    const schema = CONFIG_SCHEMA[key];
    if (!schema) return value; // Unknown key, pass through
    
    let validated = value;
    
    // Type conversion
    if (schema.type === 'integer') {
      validated = Math.round(Number(validated));
      if (!Number.isFinite(validated)) {
        console.warn(`${key} must be a number, using default ${schema.default}`);
        return schema.default;
      }
    } else if (schema.type === 'number') {
      validated = Number(validated);
      if (!Number.isFinite(validated)) {
        console.warn(`${key} must be a number, using default ${schema.default}`);
        return schema.default;
      }
    }
    
    // Range validation
    if (schema.min !== undefined && validated < schema.min) {
      console.warn(`${key} (${validated}) below minimum (${schema.min}), clamping`);
      validated = schema.min;
    }
    
    if (schema.max !== undefined && validated > schema.max) {
      console.warn(`${key} (${validated}) above maximum (${schema.max}), clamping`);
      validated = schema.max;
    }
    
    return validated;
  }
  
  // Constants for magic numbers
  const CONSTANTS = {
    CANVAS_HEIGHT_VH_PIT: 1.5,    // 150vh for Ball Pit (spawning above viewport)
    CANVAS_HEIGHT_VH_DEFAULT: 1.0, // 100vh for other modes
    OFFSCREEN_MOUSE: -1e9,        // Offscreen mouse position
    MIN_DISTANCE_EPSILON: 1e-6,   // Minimum distance for collision calculations
    MIN_REPEL_DISTANCE: 1e-4,     // Minimum repeller distance
    ACCUMULATOR_RESET_THRESHOLD: 3, // Reset accumulator if behind by this many frames
    INITIAL_SEED_BALLS: 200,      // Initial balls to seed
    BALL_SPAWN_OFFSET: 2,         // Offset for ball spawning
    BALL_CLUSTER_SPACING: 8,      // Spacing between clustered balls
    BALL_CLUSTER_Y_OFFSET: 12,    // Y offset for clustered balls
    MAX_PHYSICS_STEPS: 2,         // Maximum physics steps per frame
    FPS_UPDATE_INTERVAL: 1.0,     // FPS counter update interval in seconds
    // Spin & squash tuning
    SPIN_DAMP_PER_S: 2.0,         // angular damping per second
    SPIN_GAIN: 0.25,              // how strongly tangential slip converts to spin
    SPIN_GAIN_TANGENT: 0.18,      // ball‚Äìball tangential slip to spin
    ROLL_FRICTION_PER_S: 1.5,     // rolling friction for horizontal speed per second when grounded
    SQUASH_MAX_BASE: 0.20,        // base maximum squash at softness=40 (moderate)
    SQUASH_DECAY_PER_S: 18.0,     // faster relaxation for snappy feel
    WALL_REST_VEL_THRESHOLD: 70,  // below this, wall bounce becomes inelastic (settles)
    GROUND_COUPLING_PER_S: 8.0    // match roll (vx) to spin (omega) when grounded
  };
  
  // Dynamic squash calculation based on ball softness (0-100)
  // 0 = completely hard (no deformation)
  // 40 = normal/default (0.20 squash)
  // 100 = very squishy (0.50 squash)
  function getSquashMax() {
    if (ballSoftness === 0) return 0; // Completely hard - no squash
    // Linear interpolation: softness 40 = base value (0.20)
    // softness 100 = 2.5√ó base (0.50)
    return CONSTANTS.SQUASH_MAX_BASE * (ballSoftness / 40.0);
  }

  const canvas = document.getElementById('c');
  const container = document.getElementById('bravia-balls');
  
  // Validate canvas context availability with transparent background
  let ctx;
  try {
    ctx = canvas.getContext('2d', { alpha: true }); // Alpha channel for transparency
    if (!ctx) {
      throw new Error('Canvas 2D context not available');
    }
    // Canvas needs transparent background to show dark mode behind it
    console.log('‚úÖ Canvas initialized with alpha transparency');
  } catch (error) {
    console.error('‚ùå Failed to initialize canvas:', error);
    container.innerHTML = `
      <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #1a1a1a; color: white; font-family: system-ui, -apple-system, sans-serif;">
        <div style="text-align: center; padding: 40px; background: rgba(255,50,50,0.1); border: 2px solid rgba(255,50,50,0.3); border-radius: 12px; max-width: 480px;">
          <div style="font-size: 72px; margin-bottom: 20px; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));">‚ö†Ô∏è</div>
          <h2 style="margin: 0 0 16px 0; font-size: 24px; font-weight: 600;">Canvas Not Supported</h2>
          <p style="margin: 0 0 12px 0; opacity: 0.9; line-height: 1.6; font-size: 15px;">Your browser doesn't support the HTML5 Canvas 2D features required for this interactive simulation.</p>
          <p style="margin: 0; opacity: 0.7; font-size: 13px;">Please try a modern browser like Chrome, Firefox, Safari, or Edge.</p>
        </div>
      </div>
    `;
    throw error; // Stop execution
  }
  
  const panel = document.getElementById('controlPanel');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  
  /**
   * Update canvas drop-shadow filter based on current shadow settings
   * @description Applies CSS filter to canvas element with dynamic shadow parameters
   * @returns {void}
   */
  function updateCanvasShadow() {
    if (!canvasShadowEnabled) {
      canvas.style.filter = 'none';
      return;
    }
    
    // Parse shadow color to rgba with opacity
    const hexToRgba = (hex, opacity) => {
      const r = parseInt(hex.slice(1, 3), 16);
      const g = parseInt(hex.slice(3, 5), 16);
      const b = parseInt(hex.slice(5, 7), 16);
      return `rgba(${r}, ${g}, ${b}, ${opacity})`;
    };
    
    const shadow1 = `drop-shadow(${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${hexToRgba(shadowColor, shadowOpacity)})`;
    const shadow2 = shadow2Enabled 
      ? ` drop-shadow(${shadowOffsetX}px ${Math.round(shadowOffsetY * 0.5)}px ${shadow2Blur}px ${hexToRgba(shadowColor, shadow2Opacity)})`
      : '';
    
    canvas.style.filter = shadow1 + shadow2;
  }

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // CANVAS 2D RENDERING (Primary rendering path)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  // Performance monitoring
  let frameCount = 0;
  let lastFPSCheck = 0;
  let currentFPS = 60;
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // 120 FPS PERFORMANCE MODE SYSTEM
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  let performanceMode = false;        // 120 FPS performance mode toggle
  let targetFPS = 60;                 // Target FPS (60 normal, 120 performance)
  let fpsCheckInterval = 0.5;         // Check FPS every 500ms in performance mode
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // INITIALIZATION STATE MACHINE (Robust Dark Mode System)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // State: INITIALIZING ‚Üí DETERMINING_MODE ‚Üí LOADING_COLORS ‚Üí READY ‚Üí RUNNING
  
  const INIT_STATES = {
    INITIALIZING: 'initializing',
    DETERMINING_MODE: 'determining_mode',
    LOADING_COLORS: 'loading_colors',
    READY: 'ready',
    RUNNING: 'running'
  };
  
  let initState = INIT_STATES.INITIALIZING;
  let autoDarkModeEnabled = true;     // Auto dark mode based on time of day
  let isDarkMode = false;             // Current dark mode state
  const SUNSET_HOUR = 18;             // 6 PM
  const SUNRISE_HOUR = 6;             // 6 AM
  
  /**
   * Synchronously determine if it's night time
   * @returns {boolean} True if between SUNSET_HOUR and SUNRISE_HOUR
   */
  function isNightTime() {
    const now = new Date();
    const hour = now.getHours();
    const isNight = hour >= SUNSET_HOUR || hour < SUNRISE_HOUR;
    console.log(`üåç Time check: ${hour}:${now.getMinutes().toString().padStart(2,'0')} ‚Üí ${isNight ? 'Night' : 'Day'} (sunset: ${SUNSET_HOUR}, sunrise: ${SUNRISE_HOUR})`);
    return isNight;
  }
  
  /**
   * Determine dark mode state BEFORE any initialization
   * BLOCKING: This must complete before color loading
   * @returns {boolean} The determined dark mode state
   */
  function determineDarkMode() {
    console.log('üîç STATE: DETERMINING_MODE');
    initState = INIT_STATES.DETERMINING_MODE;
    
    if (!autoDarkModeEnabled) {
      console.log('‚úì Dark mode disabled by user ‚Üí Light mode');
      return false;
    }
    
    const shouldBeDark = isNightTime();
    console.log(`‚úì Dark mode determination complete ‚Üí ${shouldBeDark ? 'DARK' : 'LIGHT'} mode`);
    return shouldBeDark;
  }
  
  /**
   * Apply or remove dark mode styling and update color palette
   * @description Only modifies #bravia-balls container, not entire page (Webflow-safe)
   * @param {boolean} enabled - Whether to enable dark mode
   * @returns {void}
   */
  function applyDarkMode(enabled) {
    isDarkMode = enabled;
    
    // Apply dark mode to both simulation container AND body for Webflow content
    if (enabled) {
      container.classList.add('dark-mode');
      document.body.classList.add('dark-mode');
    } else {
      container.classList.remove('dark-mode');
      document.body.classList.remove('dark-mode');
    }
    
    // Switch to appropriate color palette (light or dark variant)
    applyColorTemplate(currentTemplate);
    
    updateDarkModeUI();
  }
  
  /**
   * Check current time and apply dark mode if between sunset and sunrise
   * @description Only applies dark mode if autoDarkModeEnabled is true
   * @returns {void}
   * @modifies {isDarkMode, html.classList, body.classList}
   */
  function checkAndApplyDarkMode() {
    if (autoDarkModeEnabled) {
      applyDarkMode(isNightTime());
    }
  }
  
  function updateDarkModeUI() {
    const toggle = document.getElementById('darkModeToggle');
    const status = document.getElementById('darkModeStatus');
    
    if (toggle) toggle.checked = autoDarkModeEnabled;
    
    if (status) {
      const now = new Date();
      const hour = now.getHours();
      const timeStr = `${hour.toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
      
      if (isDarkMode) {
        status.textContent = `üåô Night Mode (${timeStr})`;
        status.style.background = 'rgba(100,100,255,0.3)';
      } else {
        status.textContent = `‚òÄÔ∏è Day Mode (${timeStr})`;
        status.style.background = 'rgba(255,200,0,0.3)';
      }
    }
  }
  
  function toggleAutoDarkMode() {
    autoDarkModeEnabled = !autoDarkModeEnabled;
    
    if (autoDarkModeEnabled) {
      checkAndApplyDarkMode();
      console.log('üåô Auto Dark Mode: ENABLED');
    } else {
      applyDarkMode(false); // Always use light mode when auto is off
      console.log('‚òÄÔ∏è Auto Dark Mode: DISABLED');
    }
  }
  
  // Performance mode settings (aggressive optimizations for 120 FPS)
  const PERFORMANCE_SETTINGS = {
    normal: {
      maxBalls: 350,
      collisionIters: 2,
      adaptiveQualityMin: 0.5
    },
    performance: {
      maxBalls: 200,              // Reduce ball count
      collisionIters: 1,          // Reduce collision iterations
      adaptiveQualityMin: 0.3     // More aggressive quality reduction
    }
  };
  
  // Canvas 2D performance optimizations
  let enableLOD = true;               // Level of Detail system
  
  function updateAdaptiveQuality() {
    frameCount++;
    const now = performance.now();
    
    const checkInterval = performanceMode ? (fpsCheckInterval * 1000) : 1000;
    
    if (now - lastFPSCheck >= checkInterval) {
      currentFPS = frameCount * (1000 / checkInterval); // Adjust for check interval
      frameCount = 0;
      lastFPSCheck = now;
      
      // Performance mode: aggressive FPS management
      if (performanceMode) {
        if (currentFPS < targetFPS) {
          // Aggressively reduce quality and settings
          adaptiveQuality = Math.max(PERFORMANCE_SETTINGS.performance.adaptiveQualityMin, adaptiveQuality - 0.2);
          
          // Auto-reduce ball count if FPS still low
          if (currentFPS < targetFPS * 0.8 && balls.length > 100) {
            const reduceBy = Math.min(20, balls.length - 100);
            balls.length -= reduceBy;
            console.log(`‚ö° Performance mode: Reduced balls by ${reduceBy} (now ${balls.length})`);
          }
          
        } else if (currentFPS > targetFPS * 1.1) {
          // Gradually restore quality when FPS is good
          adaptiveQuality = Math.min(1.0, adaptiveQuality + 0.1);
        }
      } else {
        // Normal mode: standard adaptive quality
        if (currentFPS < 45) {
          adaptiveQuality = Math.max(0.3, adaptiveQuality - 0.1);
        } else if (currentFPS > 55) {
          adaptiveQuality = Math.min(1.0, adaptiveQuality + 0.05);
        }
      }
      
      const mode = performanceMode ? 'PERF' : 'NORM';
      console.log(`üéÆ ${mode} FPS: ${currentFPS}/${targetFPS}, Balls: ${balls.length}`);
    }
  }
  
  function togglePerformanceMode() {
    performanceMode = !performanceMode;
    targetFPS = performanceMode ? 120 : 60;
    
    const settings = performanceMode ? PERFORMANCE_SETTINGS.performance : PERFORMANCE_SETTINGS.normal;
    
    // Apply performance settings
    if (performanceMode) {
      console.log('‚ö° PERFORMANCE MODE: Optimizing for 120 FPS...');
      
      // Reduce ball count if above limit
      if (balls.length > settings.maxBalls) {
        balls.length = settings.maxBalls;
        console.log(`‚ö° Reduced balls to ${settings.maxBalls} for 120 FPS`);
      }
      
      // Update MAX_BALLS for new spawns
      MAX_BALLS = settings.maxBalls;
      
      // Reduce collision iterations
      currentCollisionIters = settings.collisionIters;
      
    } else {
      console.log('üé® NORMAL MODE: Restoring visual quality...');
      
      // Restore normal settings
      MAX_BALLS = settings.maxBalls;
      currentCollisionIters = settings.collisionIters;
    }
    
    // Update UI
    updatePerformanceModeUI();
    
    console.log(`üéØ Target FPS: ${targetFPS}, Mode: ${performanceMode ? 'PERFORMANCE' : 'NORMAL'}`);
  }
  
  function updatePerformanceModeUI() {
    const toggle = document.getElementById('performanceModeToggle');
    const status = document.getElementById('performanceModeStatus');
    const maxBallsSlider = document.getElementById('maxBallsSlider');
    const maxBallsVal = document.getElementById('maxBallsVal');
    
    if (toggle) toggle.checked = performanceMode;
    
    if (status) {
      if (performanceMode) {
        status.textContent = `‚ö° 120 FPS Mode Active (${balls.length} balls)`;
        status.style.background = 'rgba(255,165,0,0.3)';
      } else {
        status.textContent = `üé® Normal Mode (${balls.length} balls)`;
        status.style.background = 'rgba(0,0,0,0.2)';
      }
    }
    
    // Update max balls slider
    if (maxBallsSlider && maxBallsVal) {
      maxBallsSlider.value = MAX_BALLS;
      maxBallsVal.textContent = MAX_BALLS.toString();
    }
  }
  
  // Note: Mouse, cursor, device, and mode variables are defined elsewhere in the file

  // Spawn area controls (viewport-relative) - from config
  let SPAWN_X_CENTER_VW = 50;  // spawnX from config
  let SPAWN_Y_VH = -50;        // spawnY from config
  let SPAWN_W_VW = 100;        // spawnWidth from config
  let SPAWN_H_VH = 50;         // spawnHeight from config

  // Resize canvas based on current mode
  function resize() {
    // Ball Pit mode uses 150vh (spawning above viewport), others use 100vh
    const heightMultiplier = (currentMode === MODES.PIT) 
      ? CONSTANTS.CANVAS_HEIGHT_VH_PIT 
      : CONSTANTS.CANVAS_HEIGHT_VH_DEFAULT;
    const simHeight = window.innerHeight * heightMultiplier;
    canvas.width  = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(simHeight * DPR);
    
    // Recalculate grid dimensions and reposition balls if in Pulse Grid mode
    if (currentMode === MODES.PULSE_GRID) {
      calculateGridDimensions();
      // Reposition all balls to valid grid cells
      for (let i = 0; i < balls.length; i++) {
        const ball = balls[i];
        // Clamp grid position to new dimensions
        ball.gridX = Math.max(0, Math.min(gridCols - 1, ball.gridX));
        ball.gridY = Math.max(0, Math.min(gridRows - 1, ball.gridY));
        const pos = gridCellToPixel(ball.gridX, ball.gridY);
        ball.x = pos.x;
        ball.y = pos.y;
        ball.targetX = pos.x;
        ball.targetY = pos.y;
      }
    }
  }
  const setCSSSize = () => {
    // CSS size is handled by CSS classes (mode-pit gets 150vh, others 100svh)
  };
  
  // Debounced resize handler to prevent expensive operations on every pixel change
  let resizeTimeout;
  function handleResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      setCSSSize();
      resize();
      updateEffectiveScaleAndBallSizes();
      updateTextColliders();
    }, 150); // 150ms debounce
  }
  
  setCSSSize(); resize();
  window.addEventListener('resize', handleResize);

  // Physics parameters (from provided config)
  const GE = 1960;        // Earth gravity in px/s^2 at our scale
  let gravityMultiplier = 0; // Zero gravity (weightless mode)
  let G = GE * gravityMultiplier;
  let REST = 0.97;        // restitution from config (bouncier)
  let FRICTION = 0.0035;  // air drag from config (less drag, slower settling)
  let EMIT_INTERVAL = 0.03; // seconds between drops from config
  let MAX_BALLS = 350;    // max balls from config
  const SOLVER_ITERS = 6;    // Optimized for realistic collisions without jitter
  const POS_CORRECT_PERCENT = 0.8; // Reduced for more stable contacts
  const POS_CORRECT_SLOP = 0.5 * DPR; // Slightly more tolerance to prevent jitter
  const REST_VEL_THRESHOLD = 30; // Lower threshold for more realistic settling

  // Base radius values
  const R_MIN_BASE = 6;
  const R_MAX_BASE = 24;
  let sizeScale = 1.2;    // Global ball size multiplier
  let sizeVariation = 0.3; // Size variation: 30% range (was 0)
  // Responsive scale: reduce ball size by 60% on mobile breakpoints (‚â§768px)
  let responsiveScale = 1.0;
  let lastEffectiveScale = null; // tracks previous (sizeScale * responsiveScale)
  // Global mass model: all balls share the same mass in kg
  let ballMassKg = 91; // Mass from config (heavier for more momentum)
  // Mass influence tuning
  const MASS_GRAVITY_EXP = 0.35; // how much mass influences gravity (perceptual)
  const MASS_REST_EXP = 0.15;    // how much mass influences bounce restitution
  let gravityScale = 1.0;        // computed from mass
  function recomputeMassDerivedScales() {
    gravityScale = Math.max(0.5, Math.min(3.0, Math.pow(ballMassKg / MASS_BASELINE_KG, MASS_GRAVITY_EXP)));
  }
  recomputeMassDerivedScales();
  let R_MIN = R_MIN_BASE * sizeScale;
  let R_MAX = R_MAX_BASE * sizeScale;

  function computeResponsiveScale() {
    // Use canvas container width for proper embed behavior
    const containerWidth = canvas.clientWidth || window.innerWidth;
    return (containerWidth <= 768) ? 0.4 : 1.0;
  }

  // Recomputes the effective pixel radius from global size and responsiveness,
  // then proportionally rescales existing balls so the scene updates smoothly.
  function updateEffectiveScaleAndBallSizes() {
    responsiveScale = computeResponsiveScale();
    const effectiveScale = sizeScale * responsiveScale;
    if (lastEffectiveScale === null) {
      lastEffectiveScale = effectiveScale;
      R_MIN = R_MIN_BASE * effectiveScale;
      R_MAX = R_MAX_BASE * effectiveScale;
      return;
    }
    const ratio = effectiveScale / lastEffectiveScale;
    if (ratio !== 1) {
      for (let i = 0; i < balls.length; i++) {
        balls[i].r *= ratio;
      }
      lastEffectiveScale = effectiveScale;
    }
    R_MIN = R_MIN_BASE * effectiveScale;
    R_MAX = R_MAX_BASE * effectiveScale;
  }

  // Update text collision rectangles by measuring DOM elements
  function updateTextColliders() {
    textColliders = []; // Clear existing colliders
    
    const textElement = document.querySelector(TEXT_SELECTOR);
    if (!textElement) return; // No text element found
    
    const textRect = textElement.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    
    // Calculate cap height (height of capital letters only)
    const capHeight = calculateCapHeight(textElement);
    
    // Center the collision box vertically on the visual text
    const heightDifference = textRect.height - capHeight;
    const verticalOffset = heightDifference * 0.5; // Center the cap height within the full text height
    
    // Convert to canvas coordinates with device pixel ratio
    const collider = {
      x: (textRect.left - canvasRect.left) * DPR,
      y: (textRect.top - canvasRect.top + verticalOffset) * DPR,
      width: textRect.width * DPR,
      height: capHeight * DPR
    };
    
    // Only add collider if it's within canvas bounds and has valid dimensions
    if (collider.width > 0 && collider.height > 0 && 
        collider.x < canvas.width && collider.y < canvas.height &&
        collider.x + collider.width > 0 && collider.y + collider.height > 0) {
      textColliders.push(collider);
    }
  }
  
  // Calculate the cap height of text element (height of capital letters)
  function calculateCapHeight(element) {
    // Create a temporary element with just capital letters to measure cap height
    const tempElement = document.createElement('span');
    tempElement.style.cssText = window.getComputedStyle(element).cssText;
    tempElement.style.position = 'absolute';
    tempElement.style.visibility = 'hidden';
    tempElement.style.whiteSpace = 'nowrap';
    tempElement.textContent = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    
    document.body.appendChild(tempElement);
    const capHeight = tempElement.getBoundingClientRect().height;
    document.body.removeChild(tempElement);
    
    return capHeight;
  }

  // Emitter sweep (natural hand-like motion across the top band)
  let EMITTER_SWEEP_ENABLED = false; // Disabled per config
  let emitterPhase = 0;                 // radians
  const EMITTER_SWEEP_HZ = 0.12;        // cycles per second
  const EMITTER_SWEEP_AMPL_VW = 20;     // sweep amplitude in vw
  let emitterSweepDir = 1;              // +1 sweeping right, -1 sweeping left (derived)

  // 8-Color system with weighted distribution (50%, 25%, 12%, 6%, 3%, 2%, 1%, 1%)
  // Color 1 (50%): Dominant/background color
  // Color 2 (25%): Secondary color  
  // Color 3 (15%): Tertiary color
  // Color 4 (7.5%): Accent color
  // Color 5 (2.5%): Rare/special color
  
  // Dual palette system: each theme has light and dark variants
  // DARK MODE DESIGN PRINCIPLE: On #0a0a0a background, colors need +30-50% luminance
  // Black‚ÜíLight gray, White‚ÜíMid-tone, Accents‚ÜíHigher saturation
  const COLOR_TEMPLATES = {
    // CORE PALETTE - Industrial Teal
    industrialTeal: { 
      label: 'Industrial Teal',
      light: ['#b7bcb7', '#e4e9e4', '#ffffff', '#00695c', '#000000', '#ff4013', '#0d5cb6', '#ffa000'],
      dark: [
        '#6b726b',  // Color 1 (50%): Light warm gray - clearly visible on #0a0a0a
        '#3d453d',  // Color 2 (25%): Medium-dark gray with warmth
        '#8a928a',  // Color 3 (15%): Lighter gray for contrast
        '#00e6c3',  // Color 4 (7.5%): Bright teal - hero color pops on dark
        '#d5d5d5',  // Color 5 (2.5%): Off-white for cursor (was pure black)
        '#ff6b47',  // Color 6: Bright coral-red accent
        '#5b9aff',  // Color 7: Bright blue accent
        '#ffb84d'   // Color 8: Bright amber accent
      ]
    },
    
    sunsetCoral: { 
      label: 'Sunset Coral', 
      light: ['#bdbbb8', '#e8e6e3', '#ffffff', '#ff3b3b', '#000000', '#00f5d4', '#1e40af', '#fb923c'],
      dark: [
        '#716f6b',  // Warm medium gray
        '#3f3d3a',  // Dark warm gray
        '#8e8c88',  // Light warm gray
        '#ff6b6b',  // Bright coral - hero
        '#d8d8d8',  // Off-white for cursor
        '#00ffe7',  // Electric cyan accent
        '#6ba3ff',  // Soft blue accent
        '#ffb570'   // Peachy orange accent
      ]
    },
    
    violetPunch: { 
      label: 'Violet Punch', 
      light: ['#b8b7c2', '#e6e5ed', '#ffffff', '#9333ea', '#000000', '#dc2626', '#0ea5e9', '#facc15'],
      dark: [
        '#6d6c7a',  // Cool purple-tinted gray
        '#3a3845',  // Dark cool gray
        '#8b8a98',  // Light cool gray
        '#c266ff',  // Bright violet - hero
        '#dad6e8',  // Tinted off-white for cursor
        '#ff5c5c',  // Bright red accent
        '#42d4ff',  // Bright cyan accent
        '#fff066'   // Bright yellow accent
      ]
    },
    
    citrusBlast: { 
      label: 'Citrus Blast', 
      light: ['#bfbdb5', '#eae8df', '#ffffff', '#ea580c', '#000000', '#e11d48', '#2563eb', '#059669'],
      dark: [
        '#74726a',  // Warm beige-gray
        '#403e38',  // Dark warm gray
        '#918f87',  // Light beige-gray
        '#ff8c4d',  // Bright orange - hero
        '#dbd9d1',  // Warm off-white for cursor
        '#ff5c7a',  // Bright pink accent
        '#6ba3ff',  // Bright blue accent
        '#00d699'   // Bright green accent
      ]
    },
    
    cobaltSpark: { 
      label: 'Cobalt Spark', 
      light: ['#b5b8be', '#e3e6eb', '#ffffff', '#1d4ed8', '#000000', '#ea580c', '#db2777', '#d97706'],
      dark: [
        '#696d75',  // Cool blue-tinted gray
        '#3a3e45',  // Dark steel gray
        '#878b93',  // Light steel gray
        '#6b9dff',  // Bright cobalt - hero
        '#d6dae2',  // Cool off-white for cursor
        '#ff8c5c',  // Bright orange accent
        '#ff66b3',  // Bright magenta accent
        '#ffc266'   // Bright gold accent
      ]
    }
  };

  let currentTemplate = 'industrialTeal';
  let currentColors = COLOR_TEMPLATES.industrialTeal.light.slice(); // 8 colors, light variant by default
  // Cursor color: default to Color 4 (hero teal)
  let cursorBallIndex = 4;
  let cursorBallColor = currentColors[cursorBallIndex] || '#00695c';
  
  /**
   * Get current color palette based on dark mode state
   * @param {string} templateName - Template name from COLOR_TEMPLATES
   * @returns {Array<string>} Array of 8 color hex codes
   */
  function getCurrentPalette(templateName) {
    const template = COLOR_TEMPLATES[templateName];
    if (!template) return COLOR_TEMPLATES.industrialTeal.light;
    return isDarkMode ? template.dark : template.light;
  }
  
  /**
   * Apply color palette and update all balls
   * @param {string} templateName - Template name to apply
   * @returns {void}
   */
  function applyColorTemplate(templateName) {
    currentTemplate = templateName;
    currentColors = getCurrentPalette(templateName);
    cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor;
    
    // Update existing ball colors
    updateExistingBallColors();
    
    // Sync CSS variables
    syncPaletteVars();
    
    // Update UI color pickers
    updateColorPickersUI();
  }

  // Expose palette as CSS variables for use by page elements
  function syncPaletteVars(colors = currentColors) {
    try {
      const root = document.documentElement;
      const list = (colors && colors.length ? colors : currentColors).slice(0, 8);
      for (let i = 0; i < 8; i++) {
        const hex = list[i] || '#ffffff';
        root.style.setProperty(`--ball-${i+1}`, hex);
      }
    } catch (_) { /* no-op */ }
  }

  // Color weights: Color 1: 50%, Color 2: 25%, Color 3: 15%, Color 4: 7.5%, Color 5: 2.5%
  const COLOR_WEIGHTS = [0.50, 0.25, 0.12, 0.06, 0.03, 0.02, 0.01, 0.01];
  
  function pickRandomColor() {
    try {
      if (!currentColors || currentColors.length === 0) {
        console.warn('No colors available, using fallback');
        return '#ffffff'; // Fallback color
      }
      
      // Use weighted random selection
      const random = Math.random();
      let cumulativeWeight = 0;
      
      for (let i = 0; i < Math.min(currentColors.length, COLOR_WEIGHTS.length); i++) {
        cumulativeWeight += COLOR_WEIGHTS[i];
        if (random <= cumulativeWeight) {
          return currentColors[i];
        }
      }
      
      // Fallback to last color if something goes wrong
      return currentColors[Math.min(currentColors.length - 1, 7)];
    } catch (error) {
      console.error('Error picking random color:', error);
      return '#ffffff'; // Fallback color
    }
  }

  // Repeller controls (from config)
  let repelRadius = 710;   // repelRadius from config (wide area)
  let repelPower = 274000;  // repelPower from config (gentle push)
  let repelSoft = 3.4;     // repelSoftness from config
  let mouseX = CONSTANTS.OFFSCREEN_MOUSE, mouseY = CONSTANTS.OFFSCREEN_MOUSE; // offscreen until moved
  let mouseInCanvas = false; // track if mouse is over canvas (for vortex mode)
  let repellerEnabled = false; // disabled by default; enabled by preset or sliders
  const REPELLER_GLOBAL_MULTIPLIER = 20.0; // doubled overall repeller strength
  
  // Touch detection - cursor ball only shows on non-touch devices
  let isTouchDevice = false;
  // Check for touch support
  if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
    isTouchDevice = true;
  }
  
  // Hide modes that aren't available on this device
  // All 4 modes are available on all devices
  function applyDeviceSpecificModeVisibility() {
    // No device-specific mode hiding needed
  }
  
  // Settings persistence using localStorage
  const STORAGE_KEY = 'bouncyBallsSettings';
  const SETTINGS_VERSION = 2; // Increment to invalidate old localStorage (v2: ball size 1.3 default)
  const LOCALSTORAGE_ENABLED = false; // DISABLED - localStorage causes config issues
  
  /**
   * Persist current UI/simulation settings to localStorage
   * @description Saves all mode parameters, colors, and preferences for session persistence
   * @returns {void}
   * @throws {Error} If localStorage is unavailable or quota exceeded
   */
  function saveSettings() {
    if (!LOCALSTORAGE_ENABLED) {
      log('‚ö†Ô∏è localStorage is disabled');
      return;
    }
    const settings = {
      version: SETTINGS_VERSION, // Version number to invalidate old settings
      currentMode,
      gravityMultiplierPit,
      repellerEnabledPit,
      attractionPower,
      orbitRadius,
      swarmSpeed,
      weightlessInitialSpeed,
      weightlessBounce,
      weightlessCount,
      weightlessRepellerPower,
      weightlessRepellerRadius,
      restitution: REST,
      friction: FRICTION,
      sizeScale,
      sizeVariation,
      ballMassKg,
      ballSoftness,
      repelPower,
      repelRadius,
      repelSoft,
      cornerRadius,
      motionBlur: trailFade,
      trailSubtlety,
      currentTemplate,
      cursorBallColor,
      // Pulse Grid mode settings
      gridColumns,
      gridBallCount,
      pulseInterval,
      pulseSpeed,
      pulseSynchronicity,
      pulseRandomness,
      pulseMinSteps,
      pulseMaxSteps,
      pulseEasingStyle,
      pulseOvershoot,
      pulseBounceIntensity,
      // Canvas shadow settings
      canvasShadowEnabled,
      shadowOffsetX,
      shadowOffsetY,
      shadowBlur,
      shadowOpacity,
      shadowColor,
      shadow2Enabled,
      shadow2Blur,
      shadow2Opacity,
      // Dark mode settings
      autoDarkModeEnabled
    };
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      log('‚úì Settings saved (version ' + SETTINGS_VERSION + ')');
    } catch (e) {
      console.warn('Could not save settings:', e);
    }
  }
  
  /**
   * Load settings from localStorage and safely apply them
   * @description Each field is guarded to avoid clobbering defaults if missing
   * @returns {boolean} True if settings loaded successfully, false otherwise
   */
  function loadSettings() {
    if (!LOCALSTORAGE_ENABLED) {
      log('‚ö†Ô∏è localStorage is disabled - using defaults');
      return false;
    }
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const settings = JSON.parse(saved);
        
        // Version check - clear old localStorage if version doesn't match
        if (!settings.version || settings.version !== SETTINGS_VERSION) {
          log('üóëÔ∏è Clearing old localStorage (version mismatch: ' + (settings.version || 'none') + ' ‚Üí ' + SETTINGS_VERSION + ')');
          localStorage.removeItem(STORAGE_KEY);
          return false; // Use defaults
        }
        
        // Restore all settings
        if (settings.currentMode) currentMode = settings.currentMode;
        if (settings.gravityMultiplierPit !== undefined) gravityMultiplierPit = settings.gravityMultiplierPit;
        if (settings.repellerEnabledPit !== undefined) repellerEnabledPit = settings.repellerEnabledPit;
        if (settings.attractionPower) attractionPower = settings.attractionPower;
        if (settings.orbitRadius) orbitRadius = settings.orbitRadius;
        if (settings.swarmSpeed) swarmSpeed = settings.swarmSpeed;
        if (settings.weightlessInitialSpeed) weightlessInitialSpeed = settings.weightlessInitialSpeed;
        if (settings.weightlessBounce) weightlessBounce = settings.weightlessBounce;
        if (settings.weightlessCount) weightlessCount = settings.weightlessCount;
        if (settings.weightlessRepellerPower !== undefined) weightlessRepellerPower = settings.weightlessRepellerPower;
        if (settings.weightlessRepellerRadius !== undefined) weightlessRepellerRadius = settings.weightlessRepellerRadius;
        if (settings.restitution) REST = settings.restitution;
        if (settings.friction !== undefined) FRICTION = settings.friction;
        if (settings.sizeScale) sizeScale = settings.sizeScale;
        if (settings.sizeVariation !== undefined) sizeVariation = settings.sizeVariation;
        if (settings.ballMassKg) ballMassKg = settings.ballMassKg;
        if (settings.repelPower) repelPower = settings.repelPower;
        if (settings.repelRadius) repelRadius = settings.repelRadius;
        if (settings.repelSoft) repelSoft = settings.repelSoft;
        if (settings.cornerRadius !== undefined) cornerRadius = settings.cornerRadius;
        if (settings.motionBlur !== undefined) trailFade = settings.motionBlur;
        if (settings.trailSubtlety) trailSubtlety = settings.trailSubtlety;
        if (settings.currentTemplate) currentTemplate = settings.currentTemplate;
        if (settings.cursorBallColor) cursorBallColor = settings.cursorBallColor;
        // Pulse Grid mode settings
        if (settings.gridColumns !== undefined) gridColumns = settings.gridColumns;
        if (settings.gridBallCount !== undefined) gridBallCount = settings.gridBallCount;
        if (settings.pulseInterval !== undefined) pulseInterval = settings.pulseInterval;
        if (settings.pulseSpeed !== undefined) pulseSpeed = settings.pulseSpeed;
        if (settings.pulseSynchronicity !== undefined) pulseSynchronicity = settings.pulseSynchronicity;
        if (settings.pulseRandomness !== undefined) pulseRandomness = settings.pulseRandomness;
        if (settings.pulseMinSteps !== undefined) pulseMinSteps = settings.pulseMinSteps;
        if (settings.pulseMaxSteps !== undefined) pulseMaxSteps = settings.pulseMaxSteps;
        if (settings.pulseEasingStyle) pulseEasingStyle = settings.pulseEasingStyle;
        if (settings.pulseOvershoot !== undefined) pulseOvershoot = settings.pulseOvershoot;
        if (settings.pulseBounceIntensity !== undefined) pulseBounceIntensity = settings.pulseBounceIntensity;
        // Canvas shadow settings
        if (settings.canvasShadowEnabled !== undefined) canvasShadowEnabled = settings.canvasShadowEnabled;
        if (settings.shadowOffsetX !== undefined) shadowOffsetX = settings.shadowOffsetX;
        if (settings.shadowOffsetY !== undefined) shadowOffsetY = settings.shadowOffsetY;
        if (settings.shadowBlur !== undefined) shadowBlur = settings.shadowBlur;
        if (settings.shadowOpacity !== undefined) shadowOpacity = settings.shadowOpacity;
        if (settings.shadowColor) shadowColor = settings.shadowColor;
        if (settings.shadow2Enabled !== undefined) shadow2Enabled = settings.shadow2Enabled;
        if (settings.shadow2Blur !== undefined) shadow2Blur = settings.shadow2Blur;
        if (settings.shadow2Opacity !== undefined) shadow2Opacity = settings.shadow2Opacity;
        // Dark mode settings
        if (settings.autoDarkModeEnabled !== undefined) autoDarkModeEnabled = settings.autoDarkModeEnabled;
        
        console.log('‚úì Settings loaded');
        return true;
      }
    } catch (e) {
      console.warn('Could not load settings:', e);
    }
    return false;
  }
  
  // Auto-save settings when sliders change
  function autoSaveSettings() {
    // Debounced save (wait 500ms after last change)
    clearTimeout(window.settingsSaveTimeout);
    window.settingsSaveTimeout = setTimeout(saveSettings, 500);
  }

  // Repeller slider mapping (wide dynamic range; midpoint equals 2√ó previous default)
  const REPEL_BASE_POWER = 12000; // previous default baseline
  const REPEL_SLIDER_MAX = 10000;  // slider range [0..10000]
  const REPEL_CENTER_MULTIPLIER = 2.0; // midpoint = 2√ó base
  const REPEL_N_OCTAVES = 12; // wide range (~1/32x .. 128x around center)
  function repelSliderToPower(sliderValue) {
    const s = Math.max(0, Math.min(REPEL_SLIDER_MAX, Number(sliderValue))) / REPEL_SLIDER_MAX;
    const mult = REPEL_CENTER_MULTIPLIER * Math.pow(2, (s - 0.5) * REPEL_N_OCTAVES);
    return REPEL_BASE_POWER * mult;
  }
  function powerToRepelSlider(power) {
    const safe = Math.max(1, Number(power));
    const x = safe / (REPEL_BASE_POWER * REPEL_CENTER_MULTIPLIER);
    const s = 0.5 + (Math.log2(x) / REPEL_N_OCTAVES);
    return Math.round(Math.max(0, Math.min(1, s)) * REPEL_SLIDER_MAX);
  }

  
  // High refresh mode is now default
  let highRefreshMode = true; // Always enabled for best performance
  
  // Rounded corners for simulation area
  let cornerRadius = 0; // Corner radius in pixels (0 = square corners)
  
  // Text collision system
  const TEXT_SELECTOR = '#hero-text'; // ID selector for the main text element
  let textColliders = []; // Array of text collision rectangles
  // Motion blur parameters
  let motionBlurFade = 0.025; // from config (trailFade)
  let trailSubtlety = 1.80; // from config
  
  // Performance optimizations and FPS tracking
  // Debug logging (set to false in production for ~1KB bundle reduction)
  const DEBUG = true; // Set to false to disable all console logs
  const log = DEBUG ? console.log.bind(console) : () => {};
  
  let renderFrameCount = 0;
  let physicsStepCount = 0;
  let lastFPSTime = 0;
  let currentRenderFPS = 0;
  let currentPhysicsFPS = 0;
  const renderFpsElement = document.getElementById('render-fps');
  const physicsFpsElement = document.getElementById('physics-fps');
  
  // Adaptive Quality System - automatically adjusts settings based on FPS
  let adaptiveQualityEnabled = true;     // Enable/disable adaptive quality
  let currentCollisionIters = 2;         // Dynamic collision iterations (1-3)
  let lastQualityCheck = 0;              // Last time quality was adjusted
  const QUALITY_CHECK_INTERVAL = 2.0;    // Check every 2 seconds
  
  function updateAdaptiveQuality(now) {
    if (!adaptiveQualityEnabled) return;
    if (now - lastQualityCheck < QUALITY_CHECK_INTERVAL) return;
    
    lastQualityCheck = now;
    
    // Adjust collision iterations based on FPS
    if (currentRenderFPS < 50) {
      // Critical: reduce to 1 iteration
      currentCollisionIters = 1;
      console.log('‚ö° Adaptive Quality: LOW (1 collision iter) - FPS:', currentRenderFPS);
    } else if (currentRenderFPS < 70) {
      // Medium: keep at 2 iterations
      currentCollisionIters = 2;
      console.log('‚ö° Adaptive Quality: MEDIUM (2 collision iters) - FPS:', currentRenderFPS);
    } else {
      // High: can afford 3 iterations
      currentCollisionIters = 3;
      console.log('‚ö° Adaptive Quality: HIGH (3 collision iters) - FPS:', currentRenderFPS);
    }
  }

  // Ball model - updated to remove 3D rendering
  class Ball {
    constructor(x, y, r, color) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random()*2 - 1) * 200; // random lateral kick
      this.vy = -Math.random()*200;          // slight upward variation
      this.r = r;
      this.rBase = r;                         // Store original radius for scaling
      this.m = ballMassKg;                    // all balls share the same mass
      this.color = color;
      this.t = 0;
      // Entry drift state for natural side-throw effect
      this.age = 0;           // seconds since spawn
      this.driftAx = 0;       // lateral acceleration during entry (px/s^2)
      this.driftTime = 0;     // duration of entry drift (s)
      // Spin & squash state
      this.omega = 0;         // angular velocity (rad/s)
      this.squash = 1.0;      // visual squash factor (1 = round)
      this.squashDirX = 1;    // squash direction components (unit vector)
      this.squashDirY = 0;
      // Improved rotation & world-aligned squash
      this.theta = 0;               // integrated angular position (rad)
      this.squashAmount = 0.0;      // 0 = no squash, up to SQUASH_MAX
      this.squashNormalAngle = 0.0; // world-space normal direction for squash
      // Trail mode alpha transparency
      this.alpha = 1.0;       // 1 = opaque, 0 = transparent
    }
    // Integrate motion with simple Euler step
    step(dt) {
      // Advance timers
        this.t += dt;
      this.age += dt;

      // Gravity scaled by mass to make weight perceptible without changing G globally
      // BUT: Zero-G mode has NO gravity or drag (space physics)
      if (currentMode !== MODES.WEIGHTLESS) {
      this.vy += (G * gravityScale) * dt;
      }
      
      // Mass-aware drag (heavier balls lose proportionally less velocity)
      // BUT: Zero-G mode has MINIMAL drag (vacuum of space)
      const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
      const dragAmount = (currentMode === MODES.WEIGHTLESS) ? 0.0001 : FRICTION; // Almost zero in zero-g
      const drag = Math.max(0, 1 - (dragAmount / massScale));
      this.vx *= drag;
      this.vy *= drag;
      // Apply short-lived lateral drift to simulate being thrown from the side above
      if (this.driftAx !== 0 && this.age < this.driftTime) {
        this.vx += (this.driftAx * dt) / massScale;
      } else if (this.driftAx !== 0) {
        this.driftAx = 0; // Clear drift when expired to skip future checks
      }
      applyExternalForces(this, dt);
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      // Angular damping
      const spinDamp = Math.max(0, 1 - CONSTANTS.SPIN_DAMP_PER_S * dt);
      this.omega *= spinDamp;
      // Integrate angular position for visible rotation
      this.theta += this.omega * dt;
      if (this.theta > Math.PI) this.theta -= Math.PI * 2; else if (this.theta < -Math.PI) this.theta += Math.PI * 2;
      // Relax squash amount back to 0 (area-preserving)
      const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
      this.squashAmount += (0 - this.squashAmount) * decay;
      this.squash = 1 - this.squashAmount;
    }
    // Resolve collision with walls (with rounded corners)
    walls(w, h, dt, customRest = REST) {
      // Use custom restitution if provided (for mode-specific bounce behavior)
      const rest = customRest;
      if (cornerRadius === 0) {
        // Standard rectangular collision
      if (this.y + this.r > h) { 
        this.y = h - this.r; 
        // Pre-impact speed for squash amplitude
        const preVy = this.vy;
        // Rolling friction & spin from tangential slip
        const slip = this.vx - this.omega * this.r; // world x is tangential at bottom contact
        const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
        // convert part of slip to spin, reduce horizontal speed (rolling tendency)
        this.omega += (slip / this.r) * CONSTANTS.SPIN_GAIN / massScale;
        const rollDamp = Math.max(0, 1 - CONSTANTS.ROLL_FRICTION_PER_S * dt / massScale);
        this.vx *= rollDamp;
        // Bounce with mass-aware restitution
        const wallRest = Math.abs(preVy) < CONSTANTS.WALL_REST_VEL_THRESHOLD ? 0 : rest;
        this.vy = -this.vy * (wallRest * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash on impact using pre-impact speed
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = -Math.PI / 2; // ground normal upwards
        // Ground coupling: tend towards pure rolling without slipping
        const rollTarget = this.vx / this.r;
        this.omega += (rollTarget - this.omega) * Math.min(1, CONSTANTS.GROUND_COUPLING_PER_S * dt);
      }
      // Top wall collision aligned to the visible viewport top
      // Ball Pit: 150vh canvas, so viewport top is at h/3
      // Other modes: 100vh canvas, so viewport top is at 0
      const viewportTop = (currentMode === MODES.PIT) ? (h / 3) : 0;
      if (this.y - this.r < viewportTop) { 
        this.y = viewportTop + this.r; 
        const preVy = this.vy;
        this.vy = -this.vy * rest; 
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI / 2; // ceiling normal downwards
      }
      if (this.x + this.r > w) { 
        this.x = w - this.r; 
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * rest; 
        const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // right wall normal leftwards
      }
        if (this.x - this.r < 0) { 
          this.x = this.r; 
          {
            const slip = this.vy - this.omega * this.r;
            const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
            this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
          }
          this.vx = -this.vx * rest; 
          const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
          this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
          this.squash = 1 - this.squashAmount;
          this.squashNormalAngle = 0; // left wall normal rightwards
        }
      } else {
        // Rounded corner collision detection
        this.handleRoundedWallCollision(w, h);
      }
      
      // Text collision detection
      this.checkTextCollisions(dt);
    }
    
    // Check collision with text elements
    checkTextCollisions(dt) {
      for (let i = 0; i < textColliders.length; i++) {
        const rect = textColliders[i];
        
        // Check if ball overlaps with text rectangle
        const closestX = Math.max(rect.x, Math.min(this.x, rect.x + rect.width));
        const closestY = Math.max(rect.y, Math.min(this.y, rect.y + rect.height));
        
        const dx = this.x - closestX;
        const dy = this.y - closestY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < this.r) {
          // Collision detected - resolve it
          if (distance === 0) {
            // Ball center is inside rectangle - push out in shortest direction
            const distToLeft = this.x - rect.x;
            const distToRight = (rect.x + rect.width) - this.x;
            const distToTop = this.y - rect.y;
            const distToBottom = (rect.y + rect.height) - this.y;
            
            const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
            
            if (minDist === distToLeft) {
              this.x = rect.x - this.r;
              this.vx = -Math.abs(this.vx) * REST;
            } else if (minDist === distToRight) {
              this.x = rect.x + rect.width + this.r;
              this.vx = Math.abs(this.vx) * REST;
            } else if (minDist === distToTop) {
              this.y = rect.y - this.r;
              this.vy = -Math.abs(this.vy) * REST;
            } else {
              this.y = rect.y + rect.height + this.r;
              this.vy = Math.abs(this.vy) * REST;
            }
          } else {
            // Normal collision resolution
            const overlap = this.r - distance;
            const nx = dx / distance;
            const ny = dy / distance;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity with restitution
            const dotProduct = this.vx * nx + this.vy * ny;
            if (dotProduct < 0) {
              this.vx -= 2 * dotProduct * nx * REST;
              this.vy -= 2 * dotProduct * ny * REST;
              
              // Add squash effect for visual impact
              const impact = Math.min(1, Math.abs(dotProduct) / (this.r * 70));
              this.squash = 1 - getSquashMax() * impact;
              this.squashDirX = Math.abs(nx) > Math.abs(ny) ? 1 : 0;
              this.squashDirY = Math.abs(ny) > Math.abs(nx) ? 1 : 0;
            }
          }
        }
      }
    }
    
    // Handle collision with rounded corner boundaries
    handleRoundedWallCollision(w, h) {
      const r = cornerRadius;
      
      // Check collision with each corner circle
      const corners = [
        { x: r, y: r },           // Top-left
        { x: w - r, y: r },       // Top-right
        { x: w - r, y: h - r },   // Bottom-right
        { x: r, y: h - r }        // Bottom-left
      ];
      
      for (let i = 0; i < corners.length; i++) {
        const corner = corners[i];
        const dx = this.x - corner.x;
        const dy = this.y - corner.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Check if ball is in corner region and colliding with corner circle
        const inCornerRegion = this.isInCornerRegion(corner, w, h, r);
        if (inCornerRegion && dist + this.r > r) {
          // Collision with corner circle
          const overlap = r - (dist - this.r);
          if (overlap > 0 && dist > 0) {
            const nx = dx / dist;
            const ny = dy / dist;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity
            const dot = this.vx * nx + this.vy * ny;
            this.vx -= 2 * dot * nx * REST;
            this.vy -= 2 * dot * ny * REST;
            // Squash aligned to corner normal, proportional to impact
            const impact = Math.min(1, Math.abs(dot) / (this.r * 90));
            this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
            this.squash = 1 - this.squashAmount;
            this.squashNormalAngle = Math.atan2(ny, nx);
          }
        }
      }
      
      // Handle straight wall collisions (outside corner regions)
      // Bottom wall
      if (this.y + this.r > h && (this.x < r || this.x > w - r)) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      
      // Top wall
      if (this.y - this.r < 0 && (this.x < r || this.x > w - r)) {
        this.y = this.r;
        this.vy = -this.vy * REST;
      }
      
      // Right wall
      if (this.x + this.r > w && (this.y < r || this.y > h - r)) {
        this.x = w - this.r;
        // Wall contact: add spin from tangential slip (vertical normal)
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash aligned to wall normal
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(getSquashMax(), impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // normal leftwards
      }
      
      // Left wall
      if (this.x - this.r < 0 && (this.y < r || this.y > h - r)) {
        this.x = this.r;
        {
          const slip = this.vy - this.omega * this.r;
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(getSquashMax(), impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = 0; // normal rightwards
      }
      
      // Handle straight sections of walls
      if (this.y + this.r > h && this.x >= r && this.x <= w - r) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.y - this.r < 0 && this.x >= r && this.x <= w - r) {
        this.y = this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x + this.r > w && this.y >= r && this.y <= h - r) {
        this.x = w - this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x - this.r < 0 && this.y >= r && this.y <= h - r) {
        this.x = this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
    }
    
    // Check if ball is in a corner region
    isInCornerRegion(corner, w, h, r) {
      // Top-left corner
      if (corner.x === r && corner.y === r) {
        return this.x <= r && this.y <= r;
      }
      // Top-right corner
      if (corner.x === w - r && corner.y === r) {
        return this.x >= w - r && this.y <= r;
      }
      // Bottom-right corner
      if (corner.x === w - r && corner.y === h - r) {
        return this.x >= w - r && this.y >= h - r;
      }
      // Bottom-left corner
      if (corner.x === r && corner.y === h - r) {
        return this.x <= r && this.y >= h - r;
      }
      return false;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);

      // World-aligned squash/stretch only for larger balls (performance optimization)
      // Small balls (<15px radius) don't show visible squash, so skip expensive transforms
        const amt = Math.min(getSquashMax(), Math.max(0, this.squashAmount));
      if (this.r > 15 && amt > 0.001) {
        // Area-preserving squash: s * (1/s) maintains roundness perception
        const s = 1 + amt;
        const inv = 1 / s;
        ctx.rotate(this.squashNormalAngle);
        ctx.scale(s, inv);
        ctx.rotate(-this.squashNormalAngle);
      }
      
      // Draw main ball first
        ctx.beginPath();
        ctx.arc(0, 0, this.r, 0, Math.PI*2);
        
        // Speed-based coloring for Vortex mode
        let finalColor = this.color;
        if (currentMode === MODES.VORTEX && vortexSpeedColorEnabled) {
          const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
          const maxSpeed = 800; // Reference speed for color mapping
          const speedRatio = Math.min(speed / maxSpeed, 1);
          
          // Shift color based on speed (blue=slow, red=fast)
          const hue = 220 - speedRatio * 220; // 220 (blue) to 0 (red)
          finalColor = `hsl(${hue}, 70%, 55%)`;
        }
        
        ctx.fillStyle = finalColor;
      ctx.fill();

      ctx.restore();
    }
  }

  const balls = [];

  // Vortex mode: gravity well system
  let gravityWells = []; // Array of {x, y, strength} objects
  let permanentWells = []; // User-placed permanent wells
  const MAX_PERMANENT_WELLS = 3;

  // Helpers
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function randBetween(a, b) { return a + Math.random() * (b - a); }
  // Compute mass from radius using current weight slider as density baseline
  // Removed radius-based mass; shared mass is used instead
  
  // Draw rounded boundary visualization
  function drawRoundedBoundary(ctx, w, h) {
    const r = cornerRadius;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    // Start from top-left corner (after the curve)
    ctx.moveTo(r, 0);
    
    // Top edge
    ctx.lineTo(w - r, 0);
    
    // Top-right corner
    ctx.arcTo(w, 0, w, r, r);
    
    // Right edge
    ctx.lineTo(w, h - r);
    
    // Bottom-right corner
    ctx.arcTo(w, h, w - r, h, r);
    
    // Bottom edge
    ctx.lineTo(r, h);
    
    // Bottom-left corner
    ctx.arcTo(0, h, 0, h - r, r);
    
    // Left edge
    ctx.lineTo(0, r);
    
    // Top-left corner
    ctx.arcTo(0, 0, r, 0, r);
    
    ctx.closePath();
    ctx.stroke();
  }
  
  function spawnBall(x, y, color = pickRandomColor()) {
    // Calculate size range with variation (ensure positive values)
    const baseSize = (R_MIN + R_MAX) / 2;
    
    let r;
    if (sizeVariation === 0) {
      // No variation: all balls exactly the same size
      r = baseSize;
    } else {
      // Apply limited variation (max 10% from global ball size)
      const maxVariation = baseSize * 0.1; // 10% of global ball size
      const minR = Math.max(1, baseSize - maxVariation);
      const maxR = baseSize + maxVariation;
      r = randBetween(minR, maxR);
    }
    
    const ball = new Ball(x, y, r, color);

    // Natural entry throw with size-aware impulse and sweep-aware direction
    const centerX = canvas.width * 0.5;
    // Prefer current sweep direction if enabled; otherwise side-based
    const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((x < centerX) ? 1 : -1);
    const sizeInfluence = clamp((r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
    const baseKick = 140 * sizeInfluence;  // scale with size
    const randKick = 180 * sizeInfluence;  // scale with size
    const upwardKick = 120;                // small upward speed to soften entry
    ball.vx = dir * (baseKick + Math.random() * randKick);
    ball.vy = -Math.random() * upwardKick;

    // Short lived lateral acceleration to feel like being pushed from the side (size-aware)
    ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence; // px/s^2
    ball.driftTime = 0.22 + Math.random() * 0.28;                    // 0.22‚Äì0.5s of drift

    balls.push(ball);
    return ball;
  }
  

  // Continuous emitter within a vw/vh-defined rectangle
  let emitterTimer = 0;
  function pickSpawnPoint() {
    const wCss = canvas.clientWidth;
    const hCss = canvas.clientHeight;
    const widthCss = clamp((SPAWN_W_VW / 100) * wCss, 0, wCss);
    let xCenterCss = clamp((SPAWN_X_CENTER_VW / 100) * wCss, 0, wCss);
    // Apply sweeping emitter motion across the band for natural hand-like movement
    if (EMITTER_SWEEP_ENABLED) {
      const amplPx = (EMITTER_SWEEP_AMPL_VW / 100) * wCss;
      const sweepOffset = Math.sin(emitterPhase) * amplPx;
      const prevX = xCenterCss;
      xCenterCss = clamp(xCenterCss + sweepOffset, 0, wCss);
      emitterSweepDir = (xCenterCss >= prevX) ? 1 : -1;
    }
    // Allow slight offscreen horizontal spawn for natural side entry feel
    const offX = Math.min(40, widthCss * 0.1); // up to 40px or 10% width
    const xLeftCss = clamp(xCenterCss - widthCss / 2 - offX, -offX, wCss);
    const xRightCss = clamp(xCenterCss + widthCss / 2 + offX, -offX, wCss);
    const yTopCss = (SPAWN_Y_VH / 100) * hCss;
    const yBotCss = yTopCss + (SPAWN_H_VH / 100) * hCss;
    // Slight bias along sweep direction to emit closer to the leading edge
    const bias = 0.3; // 0 = uniform, 1 = fully biased to leading edge
    const u = Math.random();
    const biased = bias > 0 ? (emitterSweepDir > 0 ? Math.pow(u, 1 - bias) : 1 - Math.pow(1 - u, 1 - bias)) : u;
    const x = (xLeftCss + (xRightCss - xLeftCss) * biased) * DPR;
    // Add slight upward randomness to spawn height for organic feel
    const y = randBetween(yTopCss * DPR, yBotCss * DPR) - (R_MAX + CONSTANTS.BALL_SPAWN_OFFSET + randBetween(0, 10 * DPR));
    return { x, y };
  }
  
  function emit(dt) {
    // All modes: no continuous spawning
    // Ball Pit: all balls drop at once on mode init
    // Flies, Zero-G, Pulse Grid, Vortex: balls are distributed at initialization
    if (currentMode === MODES.PIT || currentMode === MODES.FLIES || currentMode === MODES.WEIGHTLESS || currentMode === MODES.PULSE_GRID || currentMode === MODES.VORTEX) {
      return;
    }
    
    // No modes use continuous emitter anymore
    emitterTimer += dt;
    while (emitterTimer >= EMIT_INTERVAL) {
      // Jitter emissions slightly for organic timing
      const jitter = (Math.random() - 0.5) * EMIT_INTERVAL * 0.5; // ¬±25%
      emitterTimer -= (EMIT_INTERVAL + jitter);
      // Advance sweep phase based on elapsed time segment (approx)
      emitterPhase += (2 * Math.PI) * EMITTER_SWEEP_HZ * (EMIT_INTERVAL + jitter);
      const p = pickSpawnPoint();
      // Occasionally emit small clusters to mimic handful tosses
      const drops = (Math.random() < 0.35 ? 3 : 1);
      for (let i=0; i<drops; i++) {
        if (balls.length < MAX_BALLS) {
          // Slight horizontal staggering to suggest sideways motion
          const xOffset = i * CONSTANTS.BALL_CLUSTER_SPACING * (Math.random() < 0.5 ? 1 : -1);
          spawnBall(p.x + xOffset, p.y - i * CONSTANTS.BALL_CLUSTER_Y_OFFSET);
        }
      }
    }
  }

  // Spatial hash grid to accelerate broad-phase (optimized)
  const spatialGrid = new Map();
  
  function collectPairsSorted() {
    const n = balls.length;
    if (n < 2) return []; // Early exit for trivial cases
    const cellSize = Math.max(1, R_MAX * 2); // Optimized cell size
    const gridWidth = Math.ceil(canvas.width / cellSize) + 1; // Dynamic grid width
    spatialGrid.clear(); // Reuse map
    
    // Build grid with numeric keys (faster than string concatenation)
    for (let i = 0; i < n; i++) {
      const b = balls[i];
      const cx = (b.x / cellSize) | 0;
      const cy = (b.y / cellSize) | 0;
      const key = cy * gridWidth + cx; // Numeric key
      let arr = spatialGrid.get(key);
      if (!arr) { arr = []; spatialGrid.set(key, arr); }
      arr.push(i);
    }
    
    const pairs = [];
    for (const [key, arr] of spatialGrid) {
      const cy = (key / gridWidth) | 0;
      const cx = key % gridWidth;
      
      // Check 9 neighboring cells (including self)
      for (let oy = -1; oy <= 1; oy++) {
        for (let ox = -1; ox <= 1; ox++) {
          const neighborKey = (cy + oy) * gridWidth + (cx + ox);
          const nb = spatialGrid.get(neighborKey);
          if (!nb) continue;
          
          for (let ii = 0; ii < arr.length; ii++) {
            const i = arr[ii];
            for (let jj = 0; jj < nb.length; jj++) {
              const j = nb[jj];
              if (j <= i) continue;
              
              const A = balls[i], B = balls[j];
              const dx = B.x - A.x, dy = B.y - A.y;
              const rSum = A.r + B.r;
              const dist2 = dx*dx + dy*dy;
              
              if (dist2 < rSum*rSum) {
                const dist = Math.sqrt(Math.max(dist2, CONSTANTS.MIN_DISTANCE_EPSILON));
                const overlap = rSum - dist;
                pairs.push({ i, j, overlap });
              }
            }
          }
        }
      }
    }
    
    // Sort by overlap (most overlapping first for stability)
    pairs.sort((a, b) => b.overlap - a.overlap);
    return pairs;
  }

  // Circle‚Äìcircle collisions: sequential impulses + Baumgarte positional correction
  function resolveCollisions(iterations = SOLVER_ITERS) {
    const pairs = collectPairsSorted();
    for (let iter = 0; iter < iterations; iter++) {
      for (let k = 0; k < pairs.length; k++) {
        const { i, j } = pairs[k];
        const A = balls[i];
        const B = balls[j];
        const dx = B.x - A.x;
        const dy = B.y - A.y;
        const rSum = A.r + B.r;
        const dist2 = dx * dx + dy * dy;
        if (dist2 === 0 || dist2 > rSum * rSum) continue;
        const dist = Math.sqrt(dist2);
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = rSum - dist;
        const invA = 1 / Math.max(A.m, 0.001);
        const invB = 1 / Math.max(B.m, 0.001);

        // Positional correction
        const correctionMag = POS_CORRECT_PERCENT * Math.max(overlap - POS_CORRECT_SLOP, 0) / (invA + invB);
        const cx = correctionMag * nx;
        const cy = correctionMag * ny;
        A.x -= cx * invA; A.y -= cy * invA;
        B.x += cx * invB; B.y += cy * invB;

        // Velocity impulse along the normal
        const rvx = B.vx - A.vx;
        const rvy = B.vy - A.vy;
        const velAlongNormal = rvx * nx + rvy * ny;
        if (velAlongNormal < 0) {
          const e = Math.abs(velAlongNormal) < REST_VEL_THRESHOLD ? 0 : REST;
          const j = -(1 + e) * velAlongNormal / (invA + invB);
          const ix = j * nx;
          const iy = j * ny;
          A.vx -= ix * invA; A.vy -= iy * invA;
          B.vx += ix * invB; B.vy += iy * invB;

          // Tangential slip to spin (approximate rolling/spin transfer)
          const tvx = rvx - velAlongNormal * nx;
          const tvy = rvy - velAlongNormal * ny;
          const slipMag = Math.hypot(tvx, tvy);
          if (slipMag > 1e-3) {
            const tangentSign = (tvx * -ny + tvy * nx) >= 0 ? 1 : -1; // right-hand tangent
            const gain = CONSTANTS.SPIN_GAIN_TANGENT;
            A.omega -= tangentSign * gain * slipMag / Math.max(A.r, 1);
            B.omega += tangentSign * gain * slipMag / Math.max(B.r, 1);
          }
          // Visual squash aligned to contact normal based on impact
          const impact = Math.min(1, Math.abs(velAlongNormal) / ((A.r + B.r) * 50));
          const sAmt = Math.min(getSquashMax(), impact * 0.8);
          A.squashAmount = Math.max(A.squashAmount, sAmt * 0.8);
          A.squashNormalAngle = Math.atan2(-ny, -nx);
          B.squashAmount = Math.max(B.squashAmount, sAmt * 0.8);
          B.squashNormalAngle = Math.atan2(ny, nx);
        }
      }
    }
  }

  // Main loop optimized for 120fps physics with cross-browser compatibility
  let last = performance.now() / 1000;
  let acc = 0;
  const DT = 1/120; // Target 120fps physics (fixed timestep)
  function frame(nowMs) {
    const now = nowMs / 1000;
    // Cap dt at 33ms (30fps min) to handle browser timing differences
    // Safari (WebKit) runs at ~60fps (16.7ms), Chrome (Blink) can hit 120fps (8ms)
    // Fixed timestep handles variance, but cap prevents spiral of death
    let dt = Math.min(0.033, now - last); // Cap at 30fps minimum (cross-browser compatible)
    last = now;
    acc += dt;

  // FPS counters (render and physics) - only update if elements exist
    if (renderFpsElement || physicsFpsElement) {
      renderFrameCount++; // Only increment when FPS display elements exist (saves 60 ops/sec when panel hidden)
    }
    if ((renderFpsElement || physicsFpsElement) && now - lastFPSTime >= CONSTANTS.FPS_UPDATE_INTERVAL) {
      if (renderFpsElement && renderFrameCount !== currentRenderFPS) {
        currentRenderFPS = renderFrameCount;
        renderFpsElement.textContent = currentRenderFPS.toString();
      }
      if (physicsFpsElement && physicsStepCount !== currentPhysicsFPS) {
        currentPhysicsFPS = physicsStepCount;
        physicsFpsElement.textContent = currentPhysicsFPS.toString();
      }
      
      renderFrameCount = 0;
      physicsStepCount = 0;
      lastFPSTime = now;
      
      // Update adaptive quality based on current FPS
      updateAdaptiveQuality(now);
    }

    emit(dt);
    
    // Update pulse grid mode (rhythmic movement)
    if (currentMode === MODES.PULSE_GRID) {
      updatePulseGrid(dt);
    }
    
    // Update text colliders periodically (every ~60 frames for performance)
    if (renderFrameCount % 60 === 0) {
      updateTextColliders();
    }
    
    // Update gravity wells for Vortex mode
    if (currentMode === MODES.VORTEX) {
      updateGravityWells();
    }

    // Physics iterations optimized for realistic, stable simulation
    let physicsSteps = 0;
    while (acc >= DT && physicsSteps < CONSTANTS.MAX_PHYSICS_STEPS) {
      // Skip physics step for pulse grid mode (movement handled by updatePulseGrid)
      if (currentMode !== MODES.PULSE_GRID) {
        const len = balls.length; // Cache length (saves 300+ lookups per frame at max balls)
        for (let i=0; i<len; i++) {
          balls[i].step(DT);
          
          // Apply gravity well forces in Vortex mode
          if (currentMode === MODES.VORTEX) {
            applyGravityWellForces(balls[i], DT);
          }
        }
      }
      
      // Ball-to-ball collisions (disabled for Flies, Pulse Grid, and Vortex modes)
      if (currentMode !== MODES.FLIES && currentMode !== MODES.PULSE_GRID && currentMode !== MODES.VORTEX) {
        resolveCollisions(currentCollisionIters); // Dynamic iterations based on adaptive quality
      }
      
      // Wall collisions (all modes except Pulse Grid)
      if (currentMode !== MODES.PULSE_GRID) {
      const wallRestitution = (currentMode === MODES.WEIGHTLESS) ? weightlessBounce : REST;
      const len = balls.length; // Cache length for wall collision loop
      for (let i=0; i<len; i++) balls[i].walls(canvas.width, canvas.height, DT, wallRestitution);
      }
      
      acc -= DT;
      physicsSteps++;
      physicsStepCount++; // Count physics steps for FPS measurement
    }
    
    // Reset accumulator if we're falling behind
    if (acc > DT * CONSTANTS.ACCUMULATOR_RESET_THRESHOLD) acc = 0;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // CANVAS 2D RENDERING (Transparent - allows #bravia-balls background to show)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Clear canvas with transparency (shows container background color)
    ctx.clearRect(0,0,canvas.width,canvas.height);
    
    // Draw rounded boundary if corner radius > 0 (cache boundary path for performance)
    if (cornerRadius > 0) {
      drawRoundedBoundary(ctx, canvas.width, canvas.height);
    }
    
    // Render balls with individual colors
    const len = balls.length; // Cache length for render loop (60 fps * 300 balls = 18k lookups/sec)
    for (let i=0; i<len; i++) balls[i].draw(ctx);
    // Draw cursor ball last
    drawCursorBall(ctx);
    
    // Draw current mode indicator (desktop only)
    if (!isTouchDevice) {
      ctx.save();
      ctx.font = '14px system-ui, -apple-system, sans-serif';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      const modeName = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      ctx.fillText(modeName + ' Mode', 10, canvas.height - 10);
      ctx.restore();
    }

    // Use requestAnimationFrame for proper vsync
    requestAnimationFrame(frame);
  }
  
  // Start the main loop with requestAnimationFrame
  console.log('High refresh mode enabled - using requestAnimationFrame');
  requestAnimationFrame(frame);

  // Reset ball sizes to global setting when switching modes
  function resetBallSizeToGlobal() {
    // Update size scale from slider (if needed)
    const globalScale = parseFloat(sizeSliderGlobal.value);
    sizeScale = globalScale;
    
    // Recalculate the actual size range based on sizeScale
    updateEffectiveScaleAndBallSizes();
    
    // Update all existing balls to use proper global size
    const baseSize = (R_MIN + R_MAX) / 2;
    for (let i = 0; i < balls.length; i++) {
      // Apply size variation if set, otherwise use base size
      if (sizeVariation === 0) {
        balls[i].r = baseSize;
        balls[i].rBase = baseSize;
      } else {
        // Apply limited variation (max 10% from global ball size)
        const maxVariation = baseSize * 0.1;
        const minR = Math.max(1, baseSize - maxVariation);
        const maxR = baseSize + maxVariation;
        balls[i].r = randBetween(minR, maxR);
        balls[i].rBase = balls[i].r;
      }
    }
  }

  // Reset balls to spawn positions (preserves all settings)
  function resetBallsToSpawn() {
    if (currentMode === MODES.WEIGHTLESS) {
      // For weightless mode, reinitialize with even distribution
      initializeWeightlessScene();
    } else {
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      const p = pickSpawnPoint();
      ball.x = p.x;
      ball.y = p.y;
      // Re-apply natural entry throw on reset (sweep-aware, size-aware)
      const centerX = canvas.width * 0.5;
      const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((ball.x < centerX) ? 1 : -1);
      const sizeInfluence = clamp((ball.r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
      const baseKick = 140 * sizeInfluence;
      const randKick = 180 * sizeInfluence;
      const upwardKick = 120;
      ball.vx = dir * (baseKick + Math.random() * randKick);
      ball.vy = -Math.random() * upwardKick;
      ball.age = 0;
      ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence;
      ball.driftTime = 0.22 + Math.random() * 0.28;
      }
    }
  }

  // Keyboard: reset balls to spawn, toggle panel
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // DRAGGABLE PANEL FUNCTIONALITY
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const panelHeader = document.getElementById('panelHeader');
  const minimizeBtn = document.getElementById('minimizePanel');
  
  // Configuration: Initial panel visibility (true = visible, false = hidden)
  const PANEL_INITIALLY_VISIBLE = true;
  
  // Apply initial visibility
  if (!PANEL_INITIALLY_VISIBLE && panel) {
    panel.classList.add('hidden');
  }
  
  // Minimize/maximize button
  if (minimizeBtn && panel) {
    minimizeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      panel.classList.toggle('hidden');
    });
  }
  
  // Drag functionality
  if (panelHeader && panel) {
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;
    
    panelHeader.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);
    
    // Touch support
    panelHeader.addEventListener('touchstart', dragStart);
    document.addEventListener('touchmove', drag);
    document.addEventListener('touchend', dragEnd);
    
    function dragStart(e) {
      if (e.type === 'touchstart') {
        initialX = e.touches[0].clientX - xOffset;
        initialY = e.touches[0].clientY - yOffset;
      } else {
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
      }
      
      if (e.target === panelHeader || panelHeader.contains(e.target)) {
        isDragging = true;
        panel.style.cursor = 'grabbing';
      }
    }
    
    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        
        if (e.type === 'touchmove') {
          currentX = e.touches[0].clientX - initialX;
          currentY = e.touches[0].clientY - initialY;
        } else {
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
        }
        
        xOffset = currentX;
        yOffset = currentY;
        
        // Convert fixed position to transform for smooth dragging
        const rect = panel.getBoundingClientRect();
        const computedStyle = window.getComputedStyle(panel);
        const initialTop = parseFloat(computedStyle.top) || 0;
        const initialRight = parseFloat(computedStyle.right) || 0;
        
        panel.style.top = `${initialTop + yOffset}px`;
        panel.style.right = `${initialRight - xOffset}px`;
        panel.style.left = 'auto';
        panel.style.bottom = 'auto';
        
        // Reset offsets after applying position
        xOffset = 0;
        yOffset = 0;
        initialX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        initialY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
      }
    }
    
    function dragEnd(e) {
      if (isDragging) {
        isDragging = false;
        panel.style.cursor = 'move';
        initialX = currentX;
        initialY = currentY;
      }
    }
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // VORTEX MODE UI LISTENERS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  const vortexBallCountSlider = document.getElementById('vortexBallCountSlider');
  const vortexBallCountVal = document.getElementById('vortexBallCountVal');
  const vortexWellStrengthSlider = document.getElementById('vortexWellStrengthSlider');
  const vortexWellStrengthVal = document.getElementById('vortexWellStrengthVal');
  const vortexMouseStrengthSlider = document.getElementById('vortexMouseStrengthSlider');
  const vortexMouseStrengthVal = document.getElementById('vortexMouseStrengthVal');
  const vortexInitialSpeedSlider = document.getElementById('vortexInitialSpeedSlider');
  const vortexInitialSpeedVal = document.getElementById('vortexInitialSpeedVal');
  const vortexDecaySlider = document.getElementById('vortexDecaySlider');
  const vortexDecayVal = document.getElementById('vortexDecayVal');
  const vortexSpeedColorCheckbox = document.getElementById('vortexSpeedColorCheckbox');
  
  vortexBallCountSlider && vortexBallCountSlider.addEventListener('input', () => {
    vortexBallCount = parseInt(vortexBallCountSlider.value, 10);
    vortexBallCountVal && (vortexBallCountVal.textContent = vortexBallCount.toString());
    if (currentMode === MODES.VORTEX) initializeVortexScene();
    autoSaveSettings();
  });
  
  vortexWellStrengthSlider && vortexWellStrengthSlider.addEventListener('input', () => {
    vortexWellStrength = parseInt(vortexWellStrengthSlider.value, 10);
    vortexWellStrengthVal && (vortexWellStrengthVal.textContent = vortexWellStrength.toString());
    if (currentMode === MODES.VORTEX && gravityWells.length > 0) {
      gravityWells[0].strength = vortexWellStrength;
      permanentWells[0].strength = vortexWellStrength;
    }
    autoSaveSettings();
  });
  
  vortexMouseStrengthSlider && vortexMouseStrengthSlider.addEventListener('input', () => {
    vortexMouseWellStrength = parseInt(vortexMouseStrengthSlider.value, 10);
    vortexMouseStrengthVal && (vortexMouseStrengthVal.textContent = vortexMouseWellStrength.toString());
    autoSaveSettings();
  });
  
  vortexInitialSpeedSlider && vortexInitialSpeedSlider.addEventListener('input', () => {
    vortexInitialSpeed = parseInt(vortexInitialSpeedSlider.value, 10);
    vortexInitialSpeedVal && (vortexInitialSpeedVal.textContent = vortexInitialSpeed.toString());
    autoSaveSettings();
  });
  
  vortexDecaySlider && vortexDecaySlider.addEventListener('input', () => {
    vortexDecayRate = parseFloat(vortexDecaySlider.value);
    vortexDecayVal && (vortexDecayVal.textContent = vortexDecayRate.toFixed(4));
    autoSaveSettings();
  });
  
  vortexSpeedColorCheckbox && vortexSpeedColorCheckbox.addEventListener('change', () => {
    vortexSpeedColorEnabled = vortexSpeedColorCheckbox.checked;
    autoSaveSettings();
  });
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // KEYBOARD SHORTCUTS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k === 'r') {
      // Move balls back to spawn area - preserve all parameter settings
      resetBallsToSpawn();
      e.preventDefault(); // Prevent any default browser behavior
    }
    if (k === '/' && panel) {
      e.preventDefault();
      panel.classList.toggle('hidden');
    }
    // Quick mode switches 1-5
    if (k === '1') setMode(MODES.PIT);
    if (k === '2') setMode(MODES.FLIES);
    if (k === '3') setMode(MODES.WEIGHTLESS);
    if (k === '4') setMode(MODES.PULSE_GRID);
    if (k === '5') setMode(MODES.VORTEX);
  });

  // Note: Ball seeding removed - all modes initialize via setMode() which calls their respective init functions

  // Mouse input (unified handler for repeller + trail recording + boulder dragging)
  let lastTrailRecordTime = 0;
  let lastMousePosition = { x: 0, y: 0 };
  let mouseStoppedTime = 0;
  
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * DPR;
      mouseY = (e.clientY - rect.top) * DPR;
      mouseInCanvas = true; // track mouse over canvas
    
    // Ball Pit: enable repeller when power and radius are set
    if (currentMode === MODES.PIT && repelPower > 0 && repelRadius > 0) {
      repellerEnabled = true;
    }


  });
  canvas.addEventListener('mouseleave', () => {
    mouseX = CONSTANTS.OFFSCREEN_MOUSE;
    mouseY = CONSTANTS.OFFSCREEN_MOUSE;
    mouseInCanvas = false; // track mouse leaving canvas
  });


  // Draw a cursor as a ball matching the simulation style
  // Renders the cursor as a simulation-like ball for desktop. Hidden on touch.
  function drawCursorBall(ctx) {
    // Don't show cursor ball on touch devices (mobile)
    if (isTouchDevice) return;
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    
    const x = mouseX, y = mouseY;
    const baseSize = (R_MIN + R_MAX) / 2;
    const r = baseSize * 1.3; // 1.3x larger cursor
    
    const color = 'rgba(255, 255, 255, 0.9)';
    
    // Draw main cursor ball first
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    // Add subtle white outline for visibility
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function applyRepeller(b, dt) {
    // Respect "Off" template by treating zero or near-zero params as disabled
    if (!repellerEnabled) return;
    if (repelPower <= 0 || repelRadius <= 0) return;
    const rPx = repelRadius * DPR;
    const dx = b.x - mouseX;
    const dy = b.y - mouseY;
    const d2 = dx*dx + dy*dy;
    const r2 = rPx * rPx;
    if (d2 > r2) return;
    const d = Math.max(Math.sqrt(d2), CONSTANTS.MIN_REPEL_DISTANCE);
    const nx = dx / d;
    const ny = dy / d;
    const q = Math.max(0, 1 - d / rPx);
    const strength = (repelPower * REPELLER_GLOBAL_MULTIPLIER) * Math.pow(q, repelSoft);
    // Heavier balls respond less to the same field
    const massScale = Math.max(0.25, b.m / MASS_BASELINE_KG);
    b.vx += (nx * strength * dt) / massScale;
    b.vy += (ny * strength * dt) / massScale;
    // Add subtle air turbulence for realism (micro perturbations)
    const turbulence = 10; // subtle random force
    b.vx += (Math.random() - 0.5) * turbulence * dt;
    b.vy += (Math.random() - 0.5) * turbulence * dt;
  }

  // Behavior-mode external forces dispatcher
  function applyExternalForces(b, dt) {
    if (currentMode === MODES.PIT) {
      applyRepeller(b, dt);
      return;
    }
    if (currentMode === MODES.FLIES) {
      applyAttractor(b, dt);
      return;
    }
    if (currentMode === MODES.WEIGHTLESS) {
      applyWeightlessRepeller(b, dt);
      return;
    }
    if (currentMode === MODES.PULSE_GRID) {
      // No external forces in grid mode - movement controlled by updatePulseGrid
      return;
    }
  }
  
  // Subtle mouse repeller for Weightless mode
  function applyWeightlessRepeller(b, dt) {
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    if (weightlessRepellerPower <= 0 || weightlessRepellerRadius <= 0) return;
    
    const rPx = weightlessRepellerRadius * DPR;
    const dx = b.x - mouseX;
    const dy = b.y - mouseY;
    const d2 = dx*dx + dy*dy;
    const r2 = rPx * rPx;
    if (d2 > r2) return;
    
    const d = Math.max(Math.sqrt(d2), CONSTANTS.MIN_REPEL_DISTANCE);
    const nx = dx / d;
    const ny = dy / d;
    const q = Math.max(0, 1 - d / rPx);
    const strength = weightlessRepellerPower * q; // linear falloff, gentle
    
    b.vx += nx * strength * dt;
    b.vy += ny * strength * dt;
  }

  // Mouse attractor for Flies-to-Light mode - REALISTIC INSECT FLIGHT
  // Reference: Mosquitoes fly 1-2 m/s with quick acceleration and erratic patterns
  function applyAttractor(b, dt) {
    // Idle swarm center (viewport center) when mouse is outside
    const swarmCenterX = (mouseX === CONSTANTS.OFFSCREEN_MOUSE) ? canvas.width * 0.5 : mouseX;
    const swarmCenterY = (mouseY === CONSTANTS.OFFSCREEN_MOUSE) ? canvas.height * 0.5 : mouseY;
    
    const dx = swarmCenterX - b.x;
    const dy = swarmCenterY - b.y;
    const d2 = dx*dx + dy*dy;
    const d = Math.sqrt(d2 + 1);
    
    // Direction to target (mouse or swarm center)
    const dirX = dx / d;
    const dirY = dy / d;
    
    // 1. VERY STRONG ATTRACTION - insects have incredible acceleration relative to size
    // Mosquitoes can accelerate at 50+ g's in short bursts
    const attractForce = attractionPower * swarmSpeed * 2.0; // Use swarmSpeed multiplier
    b.vx += dirX * attractForce * dt;
    b.vy += dirY * attractForce * dt;
    
    // 2. SEPARATION from nearby flies (looser swarm - insects don't stick together)
    const separationRadius = 120 * DPR; // Much larger separation for natural spread
    let sepX = 0, sepY = 0;
    let neighborCount = 0;
    for (let i = 0; i < balls.length; i++) {
      const other = balls[i];
      if (other === b) continue;
      const dx2 = b.x - other.x;
      const dy2 = b.y - other.y;
      const d2_other = dx2*dx2 + dy2*dy2;
      if (d2_other < separationRadius * separationRadius && d2_other > 0) {
        const d_other = Math.sqrt(d2_other);
        const strength = 1 - (d_other / separationRadius);
        sepX += (dx2 / d_other) * strength;
        sepY += (dy2 / d_other) * strength;
            neighborCount++;
          }
        }
    if (neighborCount > 0) {
      const separationForce = 15000; // Stronger separation for more spread
      b.vx += (sepX / neighborCount) * separationForce * dt;
      b.vy += (sepY / neighborCount) * separationForce * dt;
    }
    
    // 3. INTENSE ERRATIC JITTER - mosquitos dart unpredictably with bursts
    // Real mosquitoes change direction constantly and have explosive acceleration
    const jitterBase = 2500 * swarmSpeed; // Scale jitter with swarm speed
    const burstChance = 0.08; // 8% chance per frame for sudden burst
    if (Math.random() < burstChance) {
      // Sudden burst in random direction (mimics insect reflex)
      const burstAngle = Math.random() * Math.PI * 2;
      const burstStrength = 1500 * swarmSpeed;
      b.vx += Math.cos(burstAngle) * burstStrength;
      b.vy += Math.sin(burstAngle) * burstStrength;
    }
    // Constant erratic jitter (insects never fly perfectly straight)
    b.vx += (Math.random() - 0.5) * jitterBase * dt;
    b.vy += (Math.random() - 0.5) * jitterBase * dt;
    
    // 4. CHAOTIC ORBITAL MOTION - insects spiral unpredictably
    // Orbital force varies wildly based on distance and random factor
    const orbitVariation = 0.3 + Math.random() * 2.0; // 0.3x to 2.3x variation
    const orbitStrength = swarmSpeed * 2000 * orbitVariation * dt; // Strong orbital
    b.vx += -dirY * orbitStrength;
    b.vy += dirX * orbitStrength;
    
    // 5. VERY HIGH speed limit - insects are remarkably fast for their size
    const maxSpeed = 2200 * swarmSpeed; // Scale max speed with swarm speed
    const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
    if (speed > maxSpeed) {
      b.vx = (b.vx / speed) * maxSpeed;
      b.vy = (b.vy / speed) * maxSpeed;
    }
    
    // Minimal damping - insects maintain energy through constant wing beats
    b.vx *= 0.995; // Very light damping for sustained high energy
    b.vy *= 0.995;
  }


  // UI elements
  const restitutionSlider = document.getElementById('restitutionSlider');
  const frictionSlider = document.getElementById('frictionSlider');
  const emitterSlider = document.getElementById('emitterSlider');
  // Mode-specific ball properties controls
  // Global ball properties
  const sizeSliderGlobal = document.getElementById('sizeSliderGlobal');
  const sizeVariationSliderGlobal = document.getElementById('sizeVariationSliderGlobal');
  const weightSliderGlobal = document.getElementById('weightSliderGlobal');
  const ballSoftnessSliderGlobal = document.getElementById('ballSoftnessSliderGlobal');
  const sizeValGlobal = document.getElementById('sizeValGlobal');
  const sizeVariationValGlobal = document.getElementById('sizeVariationValGlobal');
  const weightValGlobal = document.getElementById('weightValGlobal');
  const ballSoftnessValGlobal = document.getElementById('ballSoftnessValGlobal');
  
  // Mode-specific sliders (kept for backward compatibility)
  const sizeSliderPit = document.getElementById('sizeSliderPit');
  const sizeVariationSliderPit = document.getElementById('sizeVariationSliderPit');
  const weightSliderPit = document.getElementById('weightSliderPit');
  const ballSoftnessSliderPit = document.getElementById('ballSoftnessSliderPit');
  const sizeValPit = document.getElementById('sizeValPit');
  const sizeVariationValPit = document.getElementById('sizeVariationValPit');
  const weightValPit = document.getElementById('weightValPit');
  const ballSoftnessValPit = document.getElementById('ballSoftnessValPit');

  const sizeSliderFlies = document.getElementById('sizeSliderFlies');
  const sizeVariationSliderFlies = document.getElementById('sizeVariationSliderFlies');
  const weightSliderFlies = document.getElementById('weightSliderFlies');
  const ballSoftnessSliderFlies = document.getElementById('ballSoftnessSliderFlies');
  const sizeValFlies = document.getElementById('sizeValFlies');
  const sizeVariationValFlies = document.getElementById('sizeVariationValFlies');
  const weightValFlies = document.getElementById('weightValFlies');
  const ballSoftnessValFlies = document.getElementById('ballSoftnessValFlies');

  const sizeSliderZeroG = document.getElementById('sizeSliderZeroG');
  const sizeVariationSliderZeroG = document.getElementById('sizeVariationSliderZeroG');
  const weightSliderZeroG = document.getElementById('weightSliderZeroG');
  const ballSoftnessSliderZeroG = document.getElementById('ballSoftnessSliderZeroG');
  const sizeValZeroG = document.getElementById('sizeValZeroG');
  const sizeVariationValZeroG = document.getElementById('sizeVariationValZeroG');
  const weightValZeroG = document.getElementById('weightValZeroG');
  const ballSoftnessValZeroG = document.getElementById('ballSoftnessValZeroG');

  const maxBallsSlider = document.getElementById('maxBallsSlider');
  const spawnYSlider = document.getElementById('spawnYSlider');
  const spawnWidthSlider = document.getElementById('spawnWidthSlider');
  const spawnCenterSlider = document.getElementById('spawnCenterSlider');
  const spawnHeightSlider = document.getElementById('spawnHeightSlider');
  const repelSizeSlider = document.getElementById('repelSizeSlider');
  const repelPowerSlider = document.getElementById('repelPowerSlider');
  const repelSoftSlider = document.getElementById('repelSoftSlider');
  // Color controls
  const colorSelect = document.getElementById('colorSelect');
  const color1 = document.getElementById('color1');
  const color2 = document.getElementById('color2');
  const color3 = document.getElementById('color3');
  const color4 = document.getElementById('color4');
  const color5 = document.getElementById('color5');
  const color6 = document.getElementById('color6');
  const color7 = document.getElementById('color7');
  const color8 = document.getElementById('color8');
  const cursorColorSelect = document.getElementById('cursorColorSelect');
  // Hex spans
  const color1Val = document.getElementById('color1Val');
  const color2Val = document.getElementById('color2Val');
  const color3Val = document.getElementById('color3Val');
  const color4Val = document.getElementById('color4Val');
  const color5Val = document.getElementById('color5Val');
  const color6Val = document.getElementById('color6Val');
  const color7Val = document.getElementById('color7Val');
  const color8Val = document.getElementById('color8Val');
  // Tooltip hint for copy action
  [color1Val, color2Val, color3Val, color4Val, color5Val, color6Val, color7Val, color8Val].forEach(el => {
    if (el) el.setAttribute('title', 'Click to copy');
  });
  // Scene controls
  const cornerRadiusSlider = document.getElementById('cornerRadiusSlider');
  const cornerRadiusVal = document.getElementById('cornerRadiusVal');
  const motionBlurFadeSlider = document.getElementById('trailFadeSlider'); // motion blur uses old trailFade ID
  const motionBlurFadeVal = document.getElementById('trailFadeVal');
  const trailSubtletySlider = document.getElementById('trailSubtletySlider');
  const trailSubtletyVal = document.getElementById('trailSubtletyVal');

  const restitutionVal = document.getElementById('restitutionVal');
  const frictionVal = document.getElementById('frictionVal');
  const emitterVal = document.getElementById('emitterVal');
  // const sizeVal = document.getElementById('sizeVal'); // Removed - using global controls
  const maxBallsVal = document.getElementById('maxBallsVal');
  // const sizeVariationVal = document.getElementById('sizeVariationVal'); // Removed - using global controls
  // const weightVal = document.getElementById('weightVal'); // Removed - using global controls
  const spawnYVal = document.getElementById('spawnYVal');
  const spawnWidthVal = document.getElementById('spawnWidthVal');
  const spawnCenterVal = document.getElementById('spawnCenterVal');
  const spawnHeightVal = document.getElementById('spawnHeightVal');
  const repelSizeVal = document.getElementById('repelSizeVal');
  const repelPowerVal = document.getElementById('repelPowerVal');
  const repelSoftVal = document.getElementById('repelSoftVal');
  // Scene controls vals (shadows removed)

  // Config capture and build functionality (restored)
  function captureCurrentConfig() {
    return {
      gravityMultiplier,
      restitution: REST,
      friction: FRICTION,
      ballMass: ballMassKg,
      emitRate: EMIT_INTERVAL,
      maxBalls: MAX_BALLS,
      ballScale: sizeScale,
      ballVariation: sizeVariation,
      spawnX: SPAWN_X_CENTER_VW,
      spawnY: SPAWN_Y_VH,
      spawnWidth: SPAWN_W_VW,
      spawnHeight: SPAWN_H_VH,
      sweepEnabled: EMITTER_SWEEP_ENABLED,
      repelRadius,
      repelPower,
      repelSoftness: repelSoft,
      trailFade: motionBlurFade,
      trailSubtlety,
      colors: currentColors.slice(),
      colorWeights: COLOR_WEIGHTS.slice(),
      currentTemplate,
      cursorColorIndex: cursorBallIndex,
      // Performance optimization settings
      performanceMode,
      targetFPS,
      enableLOD
    };
  }
  function generateConfigCode(config) {
    return `// Generated configuration from frontend\nconst CONFIG = ${JSON.stringify(config, null, 2)};`;
  }
  const saveConfigBtn = document.getElementById('saveConfigBtn');
  const buildBtn = document.getElementById('buildBtn');
  const configOutput = document.getElementById('configOutput');
  if (saveConfigBtn && buildBtn && configOutput) {
    saveConfigBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      
      // Download as current-config.json (overwrites the default)
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'current-config.json';
      a.click();
      URL.revokeObjectURL(url);
      
      // Show success message
      configOutput.style.display = 'block';
      configOutput.innerHTML = `
<strong>üíæ Config Saved!</strong><br>
Replace <code>source/current-config.json</code> with the downloaded file.<br>
Then rebuild: <code>npm run build-production</code>`;
      
      const old = saveConfigBtn.textContent;
      saveConfigBtn.textContent = '‚úÖ Downloaded!';
      setTimeout(() => { saveConfigBtn.textContent = old; }, 2000);
    });
    buildBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      configOutput.style.display = 'block';
      configOutput.innerHTML = `
<strong>üöÄ Build Instructions:</strong><br>
1. Run: <code>npm run build</code><br>
2. Your current config will be baked into <code>public/js/bouncy-balls-embed.js</code>`;
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'current-config.json'; a.click();
      URL.revokeObjectURL(url);
    });
  }

  // Click-to-copy helper
  function bindCopyOnClick(el, getText) {
    if (!el) return;
    el.addEventListener('click', async () => {
      const text = typeof getText === 'function' ? getText() : String(getText || '').trim();
      try {
        await navigator.clipboard.writeText(text);
        const old = el.textContent;
        el.textContent = 'COPIED';
        el.style.color = '#3ddc84';
        setTimeout(() => { el.textContent = old; el.style.color = '#888'; }, 900);
      } catch (e) {
        console.warn('Clipboard unavailable');
      }
    });
  }

  // Sliders (with auto-save)
  restitutionSlider && restitutionSlider.addEventListener('input', () => { REST = parseFloat(restitutionSlider.value); restitutionVal && (restitutionVal.textContent = REST.toFixed(2)); autoSaveSettings(); });
  frictionSlider && frictionSlider.addEventListener('input', () => { FRICTION = parseFloat(frictionSlider.value); frictionVal && (frictionVal.textContent = FRICTION.toFixed(4)); autoSaveSettings(); });
  emitterSlider && emitterSlider.addEventListener('input', () => { EMIT_INTERVAL = parseFloat(emitterSlider.value); emitterVal && (emitterVal.textContent = EMIT_INTERVAL.toFixed(3)); autoSaveSettings(); });

  // Mode-specific ball properties listeners (apply values globally but source UI is per-mode)
  function bindBallProps(sliders) {
    if (!sliders) return;
    const { size, sizeVal, sizeVar, sizeVarVal, soft, softVal } = sliders;
    size && size.addEventListener('input', () => {
      const newScale = parseFloat(size.value);
    sizeVal && (sizeVal.textContent = newScale.toFixed(1));
    sizeScale = newScale;
    updateEffectiveScaleAndBallSizes();
      
      // CRITICAL: Directly update all ball sizes to the new base (don't call resetBallSizeToGlobal)
      const baseSize = (R_MIN + R_MAX) / 2;
      for (let i = 0; i < balls.length; i++) {
        balls[i].r = baseSize;
        balls[i].rBase = baseSize;
      }
      
      // Apply mass to all balls
      for (let i=0; i<balls.length; i++) {
        balls[i].m = ballMassKg;
      }
      autoSaveSettings();
    });
    sizeVar && sizeVar.addEventListener('input', () => {
      const v = parseFloat(sizeVar.value);
      sizeVarVal && (sizeVarVal.textContent = v.toFixed(1));
      sizeVariation = v;
      autoSaveSettings();
    });
    soft && soft.addEventListener('input', () => {
      const s = parseInt(soft.value, 10);
      softVal && (softVal.textContent = String(s));
      ballSoftness = s;
      autoSaveSettings();
    });
  }

  // Global ball properties (apply to all modes)
  bindBallProps({
    size: sizeSliderGlobal, sizeVal: sizeValGlobal,
    sizeVar: sizeVariationSliderGlobal, sizeVarVal: sizeVariationValGlobal,
    soft: ballSoftnessSliderGlobal, softVal: ballSoftnessValGlobal
  });
  maxBallsSlider && maxBallsSlider.addEventListener('input', () => {
    MAX_BALLS = parseInt(maxBallsSlider.value, 10);
    maxBallsVal && (maxBallsVal.textContent = MAX_BALLS.toString());
    // Remove excess balls if current count exceeds new limit (remove from end for better performance)
    if (balls.length > MAX_BALLS) {
      balls.length = MAX_BALLS; // Truncate array efficiently
    }
  });
  sizeVariationSliderGlobal && sizeVariationSliderGlobal.addEventListener('input', () => {
    sizeVariation = parseFloat(sizeVariationSliderGlobal.value);
    sizeVariationValGlobal && (sizeVariationValGlobal.textContent = sizeVariation.toFixed(1));
    
    // Update existing ball sizes to reflect new variation
    updateExistingBallSizes();
  });
  // Mode-specific weight controls
  const weightPitSlider = document.getElementById('weightPitSlider');
  const weightPitVal = document.getElementById('weightPitVal');
  const weightWeightlessSlider = document.getElementById('weightWeightlessSlider');
  const weightWeightlessVal = document.getElementById('weightWeightlessVal');
  // removed legacy rainbow weight controls (replaced by boulderWeight controls)
  
  // Function to update existing ball sizes based on current sizeVariation
  function updateExistingBallSizes() {
    const baseSize = (R_MIN + R_MAX) / 2;
    
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      
      if (sizeVariation === 0) {
        // No variation: all balls exactly the same size
        ball.r = baseSize;
      } else {
        // Apply limited variation (max 10% from global ball size)
        const maxVariation = baseSize * 0.1; // 10% of global ball size
        const minR = Math.max(1, baseSize - maxVariation);
        const maxR = baseSize + maxVariation;
        ball.r = randBetween(minR, maxR);
      }
      
      // Keep shared mass model (no per-ball recompute)
      ball.m = ballMassKg;
    }
  }
  spawnYSlider && spawnYSlider.addEventListener('input', () => {
    SPAWN_Y_VH = parseFloat(spawnYSlider.value);
    spawnYVal && (spawnYVal.textContent = SPAWN_Y_VH.toFixed(0));
    setCSSSize(); resize();
  });
  spawnWidthSlider && spawnWidthSlider.addEventListener('input', () => { SPAWN_W_VW = parseFloat(spawnWidthSlider.value); spawnWidthVal && (spawnWidthVal.textContent = SPAWN_W_VW.toFixed(0)); });
  spawnCenterSlider && spawnCenterSlider.addEventListener('input', () => { SPAWN_X_CENTER_VW = parseFloat(spawnCenterSlider.value); spawnCenterVal && (spawnCenterVal.textContent = SPAWN_X_CENTER_VW.toFixed(0)); });
  spawnHeightSlider && spawnHeightSlider.addEventListener('input', () => { SPAWN_H_VH = parseFloat(spawnHeightSlider.value); spawnHeightVal && (spawnHeightVal.textContent = SPAWN_H_VH.toFixed(0)); });
  repelSizeSlider && repelSizeSlider.addEventListener('input', () => {
    repelRadius = parseFloat(repelSizeSlider.value);
    repelSizeVal && (repelSizeVal.textContent = repelRadius.toFixed(0));
    repellerEnabled = repellerEnabled || (repelPower > 0 && repelRadius > 0); 
  });
  repelPowerSlider && repelPowerSlider.addEventListener('input', () => {
    repelPower = repelSliderToPower(repelPowerSlider.value);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    // Do not auto-enable when template is Off; only enable via template or size/power explicit >0 with mouse over
    if (repellerSelect && repellerSelect.value !== 'off') {
      repellerEnabled = repelPower > 0 && repelRadius > 0; 
    }
  });
  repelSoftSlider && repelSoftSlider.addEventListener('input', () => {
    repelSoft = parseFloat(repelSoftSlider.value);
    repelSoftVal && (repelSoftVal.textContent = repelSoft.toFixed(1));
  });
  
  // Performance Mode Controls
  const performanceModeToggleEl = document.getElementById('performanceModeToggle');
  const performanceModeStatusEl = document.getElementById('performanceModeStatus');
  
  performanceModeToggleEl && performanceModeToggleEl.addEventListener('change', () => {
    togglePerformanceMode();
  });
  
  // Dark Mode Controls
  const darkModeToggleEl = document.getElementById('darkModeToggle');
  const darkModeStatusEl = document.getElementById('darkModeStatus');
  
  darkModeToggleEl && darkModeToggleEl.addEventListener('change', () => {
    toggleAutoDarkMode();
    autoSaveSettings();
  });
  
  // Canvas Shadow Controls
  const canvasShadowEnabledEl = document.getElementById('canvasShadowEnabled');
  const shadowOffsetXEl = document.getElementById('shadowOffsetX');
  const shadowOffsetXVal = document.getElementById('shadowOffsetXVal');
  const shadowOffsetYEl = document.getElementById('shadowOffsetY');
  const shadowOffsetYVal = document.getElementById('shadowOffsetYVal');
  const shadowBlurEl = document.getElementById('shadowBlur');
  const shadowBlurVal = document.getElementById('shadowBlurVal');
  const shadowOpacityEl = document.getElementById('shadowOpacity');
  const shadowOpacityVal = document.getElementById('shadowOpacityVal');
  const shadowColorEl = document.getElementById('shadowColor');
  const shadowColorVal = document.getElementById('shadowColorVal');
  const shadow2EnabledEl = document.getElementById('shadow2Enabled');
  const shadow2BlurEl = document.getElementById('shadow2Blur');
  const shadow2BlurVal = document.getElementById('shadow2BlurVal');
  const shadow2OpacityEl = document.getElementById('shadow2Opacity');
  const shadow2OpacityVal = document.getElementById('shadow2OpacityVal');
  
  canvasShadowEnabledEl && canvasShadowEnabledEl.addEventListener('change', () => {
    canvasShadowEnabled = canvasShadowEnabledEl.checked;
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadowOffsetXEl && shadowOffsetXEl.addEventListener('input', () => {
    shadowOffsetX = parseFloat(shadowOffsetXEl.value);
    shadowOffsetXVal && (shadowOffsetXVal.textContent = shadowOffsetX.toFixed(1));
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadowOffsetYEl && shadowOffsetYEl.addEventListener('input', () => {
    shadowOffsetY = parseFloat(shadowOffsetYEl.value);
    shadowOffsetYVal && (shadowOffsetYVal.textContent = shadowOffsetY.toFixed(1));
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadowBlurEl && shadowBlurEl.addEventListener('input', () => {
    shadowBlur = parseFloat(shadowBlurEl.value);
    shadowBlurVal && (shadowBlurVal.textContent = shadowBlur.toFixed(1));
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadowOpacityEl && shadowOpacityEl.addEventListener('input', () => {
    shadowOpacity = parseFloat(shadowOpacityEl.value);
    shadowOpacityVal && (shadowOpacityVal.textContent = shadowOpacity.toFixed(2));
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadowColorEl && shadowColorEl.addEventListener('input', () => {
    shadowColor = shadowColorEl.value;
    shadowColorVal && (shadowColorVal.textContent = shadowColor.toUpperCase());
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadow2EnabledEl && shadow2EnabledEl.addEventListener('change', () => {
    shadow2Enabled = shadow2EnabledEl.checked;
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadow2BlurEl && shadow2BlurEl.addEventListener('input', () => {
    shadow2Blur = parseInt(shadow2BlurEl.value, 10);
    shadow2BlurVal && (shadow2BlurVal.textContent = shadow2Blur.toString());
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  shadow2OpacityEl && shadow2OpacityEl.addEventListener('input', () => {
    shadow2Opacity = parseFloat(shadow2OpacityEl.value);
    shadow2OpacityVal && (shadow2OpacityVal.textContent = shadow2Opacity.toFixed(2));
    updateCanvasShadow();
    autoSaveSettings();
  });
  
  // Mouse tracking for cursor ball and repeller (removed duplicate - already handled above with mouseInCanvas tracking)
  
  canvas.addEventListener('mouseleave', () => {
    mouseX = CONSTANTS.OFFSCREEN_MOUSE;
    mouseY = CONSTANTS.OFFSCREEN_MOUSE;
    mouseInCanvas = false; // track mouse leaving canvas
  });
  
  // Color controls
  colorSelect && colorSelect.addEventListener('change', () => {
    applyColorTemplate(colorSelect.value);
  });

  // Mode switcher wiring
  const modeButtons = Array.from(document.querySelectorAll('.mode-button'));
  const pitControls = document.getElementById('pitControls');
  const fliesControls = document.getElementById('fliesControls');
  const weightlessControls = document.getElementById('weightlessControls');
  const gravityPitSlider = document.getElementById('gravityPitSlider');
  const gravityPitVal = document.getElementById('gravityPitVal');
  const repellerEnabledPitEl = document.getElementById('repellerEnabledPit');
  const attractPowerSlider = document.getElementById('attractPowerSlider');
  const attractPowerVal = document.getElementById('attractPowerVal');
  const orbitRadiusSlider = document.getElementById('orbitRadiusSlider');
  const orbitRadiusVal = document.getElementById('orbitRadiusVal');
  const swarmSpeedSlider = document.getElementById('swarmSpeedSlider');
  const swarmSpeedVal = document.getElementById('swarmSpeedVal');
  
  // Weightless controls
  const weightlessCountSlider = document.getElementById('weightlessCountSlider');
  const weightlessCountVal = document.getElementById('weightlessCountVal');
  const weightlessSpeedSlider = document.getElementById('weightlessSpeedSlider');
  const weightlessSpeedVal = document.getElementById('weightlessSpeedVal');
  const weightlessBounceSlider = document.getElementById('weightlessBounceSlider');
  const weightlessBounceVal = document.getElementById('weightlessBounceVal');
  const weightlessRepelSlider = document.getElementById('weightlessRepelSlider');
  const weightlessRepelVal = document.getElementById('weightlessRepelVal');
  const weightlessRepelRadiusSlider = document.getElementById('weightlessRepelRadiusSlider');
  const weightlessRepelRadiusVal = document.getElementById('weightlessRepelRadiusVal');

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PROFESSIONAL WEIGHTLESS SCENE INITIALIZATION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  /**
   * Initialize Ball Pit scene with all balls dropping from above viewport
   * @description Spawns all MAX_BALLS at once above the viewport, distributed horizontally
   * @returns {void}
   * @modifies {balls}
   */
  function initializeBallPitScene() {
    balls.length = 0;
    
    const targetBalls = MAX_BALLS;
    const w = canvas.width;
    const hCss = canvas.clientHeight;
    
    // Spawn all balls at once above the viewport
    // Use SPAWN_Y_VH and SPAWN_W_VW for positioning
    const spawnYTop = (SPAWN_Y_VH / 100) * hCss * DPR;
    const spawnYBottom = spawnYTop + (SPAWN_H_VH / 100) * hCss * DPR;
    const widthCss = (SPAWN_W_VW / 100) * (canvas.clientWidth);
    const xCenterCss = (SPAWN_X_CENTER_VW / 100) * (canvas.clientWidth);
    const xLeftCss = xCenterCss - widthCss / 2;
    const xRightCss = xCenterCss + widthCss / 2;
    
    for (let i = 0; i < targetBalls; i++) {
      // Random position across spawn area
      const x = (xLeftCss + Math.random() * widthCss) * DPR;
      const y = spawnYTop + Math.random() * (spawnYBottom - spawnYTop);
      
      const ball = spawnBall(x, y);
      
      // Small random initial velocity for natural spread (no strong sideways kick)
      ball.vx = (Math.random() - 0.5) * 100; // Small horizontal variation
      ball.vy = Math.random() * 50; // Small downward variation
      ball.driftAx = 0;
      ball.driftTime = 0;
    }
  }
  
  // Initialize flies in idle swarm at viewport center
  function initializeFliesScene() {
    balls.length = 0;
    
    const targetBalls = 60; // Good swarm size for flies
    const w = canvas.width;
    const h = canvas.height;
    const centerX = w * 0.5;
    const centerY = h * 0.5;
    
    // Spawn flies in a loose cluster at center with randomized positions
    const swarmRadius = 150 * DPR; // Initial spread radius
    
    for (let i = 0; i < targetBalls; i++) {
      // Random position within swarm radius from center
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * swarmRadius;
      const x = centerX + Math.cos(angle) * distance;
      const y = centerY + Math.sin(angle) * distance;
      
      const ball = spawnBall(x, y);
      
      // Initial erratic velocity (flies are already moving in idle state)
      const speedVariation = 0.5 + Math.random() * 0.5;
      const vAngle = Math.random() * Math.PI * 2;
      const speed = 300 * speedVariation; // Moderate initial speed
      ball.vx = Math.cos(vAngle) * speed;
      ball.vy = Math.sin(vAngle) * speed;
      ball.driftAx = 0;
      ball.driftTime = 0;
    }
  }
  
  /**
   * Initialize Zero-G scene with random ball distribution
   * @description Spawns balls randomly across entire viewport with random velocities
   * @returns {void}
   * @modifies {balls}
   */
  function initializeWeightlessScene() {
    balls.length = 0;
    
    // Fixed count from UI control
    const targetBalls = weightlessCount;
    const w = canvas.width;
    const h = canvas.height;
    
    // Random distribution across entire viewport (no grid)
    const margin = 40 * DPR; // Safe margin from edges
    
    for (let i = 0; i < targetBalls; i++) {
      // Completely random position within viewport
      const x = margin + Math.random() * (w - 2 * margin);
      const y = margin + Math.random() * (h - 2 * margin);
      
      const ball = spawnBall(x, y);
      
      // Random velocity in any direction
      const angle = Math.random() * Math.PI * 2;
      const speed = weightlessInitialSpeed * (0.7 + Math.random() * 0.3);
      ball.vx = Math.cos(angle) * speed;
      ball.vy = Math.sin(angle) * speed;
      ball.driftAx = 0;
      ball.driftTime = 0;
    }
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PULSE GRID MODE - RHYTHMIC GRID-BASED MOVEMENT
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  // Grid state
  let gridCellSize = 0;
  let gridRows = 0;
  let gridCols = 0;
  let gridOffsetX = 0;
  let gridOffsetY = 0;
  
  /**
   * Calculate grid dimensions based on canvas size and column count
   * @description Computes cell size, row count, and centering offsets for grid layout
   * @returns {void}
   * @modifies {gridCols, gridCellSize, gridRows, gridOffsetX, gridOffsetY}
   */
  function calculateGridDimensions() {
    const w = canvas.width;
    const h = canvas.height;
    
    // Calculate cell size based on columns and 1:1 aspect ratio
    gridCols = gridColumns;
    gridCellSize = w / gridCols;
    gridRows = Math.floor(h / gridCellSize);
    
    // Center grid in viewport
    gridOffsetX = (w - (gridCols * gridCellSize)) / 2;
    gridOffsetY = (h - (gridRows * gridCellSize)) / 2;
  }
  
  function gridCellToPixel(gridX, gridY) {
    return {
      x: gridOffsetX + (gridX + 0.5) * gridCellSize,
      y: gridOffsetY + (gridY + 0.5) * gridCellSize
    };
  }
  
  /**
   * Initialize gravity wells for vortex mode
   * @description Creates central gravity well and resets permanent wells array
   * @returns {void}
   * @modifies {gravityWells, permanentWells}
   */
  function initializeGravityWells() {
    gravityWells = [];
    permanentWells = [];
    
    // Central gravity well at canvas center (in DPR-scaled coordinates)
    const centralWell = {
      x: canvas.width / 2,
      y: canvas.height / 2,
      strength: vortexWellStrength,
      isPermanent: true
    };
    gravityWells.push(centralWell);
    permanentWells.push(centralWell);
  }

  /**
   * Update gravity wells (move central well to mouse position when cursor is in canvas)
   * @description Updates central well to follow mouse, or stays at viewport center
   * @returns {void}
   * @modifies {gravityWells}
   */
  function updateGravityWells() {
    const w = canvas.width;
    const h = canvas.height;
    const centerX = w / 2;
    const centerY = h / 2;
    
    // If mouse is in canvas, move central well to mouse position
    // Otherwise, keep it at viewport center
    // Note: mouseX and mouseY are already in canvas coordinates (scaled by DPR)
    const wellX = mouseInCanvas ? mouseX : centerX;
    const wellY = mouseInCanvas ? mouseY : centerY;
    
    // Update the central well position
    gravityWells = [{
      x: wellX,
      y: wellY,
      strength: vortexWellStrength,
      isPermanent: false // Dynamic position based on mouse
    }];
    
    // Update permanent wells reference for UI consistency
    if (permanentWells.length > 0) {
      permanentWells[0].x = wellX;
      permanentWells[0].y = wellY;
    }
  }

  /**
   * Apply gravitational forces from all wells to a ball
   * @description Calculates and applies inverse-square gravitational forces with orbital decay
   * @param {Ball} ball - Ball to apply forces to
   * @param {number} dt - Physics timestep (seconds)
   * @returns {void}
   * @modifies {ball.vx, ball.vy}
   */
  function applyGravityWellForces(ball, dt) {
    for (const well of gravityWells) {
      const dx = well.x - ball.x;
      const dy = well.y - ball.y;
      const distSq = dx * dx + dy * dy;
      const dist = Math.sqrt(distSq);
      
      // Prevent division by zero and extreme forces
      if (dist < 5) continue;
      
      // Calculate normalized direction vectors
      const nx = dx / dist;  // Normalized x (toward well)
      const ny = dy / dist;  // Normalized y (toward well)
      
      // VORTEX PHYSICS: Create spinning motion around the mouse
      // The key is to balance radial (inward) and tangential (spinning) forces
      
      // 1. Radial force - pulls balls toward center (inverse square law)
      const radialForce = (well.strength / distSq) * dt * 0.6; // Reduced to 60% for less aggressive pull
      
      // 2. Tangential force - makes balls spin around the center
      // Perpendicular to radial: rotate direction 90¬∞ counter-clockwise
      // If radial is (nx, ny), perpendicular is (-ny, nx)
      const tangentialStrength = well.strength * 1.2; // 120% of base strength for strong spin
      const tangentialForce = (tangentialStrength / dist) * dt; // Use 1/r instead of 1/r¬≤ for more consistent spin
      
      // 3. Spatial effect - create depth by varying speed based on distance
      // Closer balls spin faster (like inner planets), far balls spin slower (like outer planets)
      const spatialMultiplier = 1.0 - Math.min(dist / 600, 0.5); // 0.5 to 1.0 based on distance
      
      // Apply forces: radial (pull in) + tangential (spin) with spatial variation
      ball.vx += nx * radialForce + (-ny) * tangentialForce * (0.8 + spatialMultiplier * 0.4);
      ball.vy += ny * radialForce + (nx) * tangentialForce * (0.8 + spatialMultiplier * 0.4);
      
      // 4. Velocity damping for stability (prevents balls from flying away)
      const dampingFactor = 0.997; // Slight damping to keep orbits stable
      ball.vx *= dampingFactor;
      ball.vy *= dampingFactor;
    }
    
    // Apply orbital decay (energy loss/gain over time)
    if (vortexDecayRate !== 0) {
      ball.vx *= (1 - vortexDecayRate);
      ball.vy *= (1 - vortexDecayRate);
    }
  }

  /**
   * Initialize Vortex mode scene with circular distribution and orbital velocities
   * @description Creates balls in ring around center with tangential velocities for orbits
   * @returns {void}
   * @modifies {balls, gravityWells}
   */
  function initializeVortexScene() {
    balls.length = 0;
    initializeGravityWells();
    
    const w = canvas.width;
    const h = canvas.height;
    const centerX = w / 2;
    const centerY = h / 2;
    
    // Distribute balls in circular ring around center (wider ring for more dramatic effect)
    const minRadius = Math.min(w, h) * 0.20; // Inner ring radius (increased from 0.15)
    const maxRadius = Math.min(w, h) * 0.45; // Outer ring radius (increased from 0.35)
    
    for (let i = 0; i < vortexBallCount; i++) {
      // Random position in ring
      const angle = (Math.PI * 2 * i) / vortexBallCount + (Math.random() - 0.5) * 0.5;
      const radius = minRadius + Math.random() * (maxRadius - minRadius);
      const x = centerX + Math.cos(angle) * radius;
      const y = centerY + Math.sin(angle) * radius;
      
      // Calculate tangential velocity for circular orbit
      // v = sqrt(GM/r) for stable orbit, with some randomness
      const orbitalSpeed = vortexInitialSpeed * (0.8 + Math.random() * 0.4); // More consistent speed
      const vx = -Math.sin(angle) * orbitalSpeed;
      const vy = Math.cos(angle) * orbitalSpeed;
      
      // Random ball size with variation
      const baseRadius = (R_MIN + R_MAX) / 2;
      const r = baseRadius * (0.9 + Math.random() * 0.2);
      
      // Pick vibrant color for each ball
      const color = pickRandomColor();
      
      // Create ball with proper color (constructor expects: x, y, r, color)
      const ball = new Ball(x, y, r, color);
      
      // Set orbital velocity after creation
      ball.vx = vx;
      ball.vy = vy;
      
      balls.push(ball);
    }
    
    log(`üåÄ Vortex scene initialized: ${vortexBallCount} balls in orbital ring`);
  }

  /**
   * Initialize Pulse Grid scene with rhythmic ball placement
   * @description Clears existing balls and spawns new ones in unique grid cells with staggered jump times.
   * Uses random distribution to ensure balls are spread across entire viewport.
   * @returns {void}
   * @modifies {balls}
   * @example
   * initializePulseGridScene(); // Creates 120 balls on 40-column grid
   */
  function initializePulseGridScene() {
    balls.length = 0;
    calculateGridDimensions();
    
    const maxCells = gridCols * gridRows;
    const targetBalls = Math.min(gridBallCount, maxCells); // Cap at grid capacity
    
    // Create array of all possible cells
    const allCells = [];
    for (let row = 0; row < gridRows; row++) {
      for (let col = 0; col < gridCols; col++) {
        allCells.push({ gridX: col, gridY: row });
      }
    }
    
    // Shuffle array for random distribution
    for (let i = allCells.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [allCells[i], allCells[j]] = [allCells[j], allCells[i]];
    }
    
    // Take first N cells for even random distribution across viewport
    for (let i = 0; i < targetBalls; i++) {
      const cell = allCells[i];
      const pos = gridCellToPixel(cell.gridX, cell.gridY);
      
      const ball = spawnBall(pos.x, pos.y);
      
      // Grid-specific properties
      ball.gridX = cell.gridX;
      ball.gridY = cell.gridY;
      ball.targetX = pos.x;
      ball.targetY = pos.y;
      ball.jumpProgress = 1.0; // Start at rest
      ball.vx = 0;
      ball.vy = 0;
      ball.driftAx = 0;
      ball.driftTime = 0;
      
      // Stagger initial jump times based on synchronicity
      const baseDelay = pulseInterval;
      const phaseOffset = pulseSynchronicity * Math.random() * baseDelay;
      ball.nextJumpTime = baseDelay + phaseOffset;
    }
  }
  
  /**
   * Update grid ball positions with rhythmic movement
   * @description Handles beat timing, direction selection, and jump animation for all balls in grid mode
   * @param {number} dt - Delta time in seconds since last update
   * @returns {void}
   * @modifies {balls[].x, balls[].y, balls[].gridX, balls[].gridY, balls[].jumpProgress}
   */
  function updatePulseGrid(dt) {
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      
      // Check if it's time for a new jump
      ball.nextJumpTime -= dt;
      
      if (ball.nextJumpTime <= 0 && ball.jumpProgress >= 1.0) {
        // Initiate new jump
        const directions = [
          { dx: 0, dy: -1 },  // up
          { dx: 0, dy: 1 },   // down
          { dx: -1, dy: 0 },  // left
          { dx: 1, dy: 0 }    // right
        ];
        
        // Pick random direction
        const dir = directions[Math.floor(Math.random() * directions.length)];
        
        // Pick random step count
        const stepRange = pulseMaxSteps - pulseMinSteps + 1;
        const steps = pulseMinSteps + Math.floor(Math.random() * stepRange);
        
        // Apply randomness to step count
        const randomizedSteps = Math.max(1, Math.round(steps * (1 - pulseRandomness * 0.5 + pulseRandomness * Math.random())));
        
        // Calculate new grid position
        let newGridX = ball.gridX + dir.dx * randomizedSteps;
        let newGridY = ball.gridY + dir.dy * randomizedSteps;
        
        // Clamp to grid bounds
        newGridX = Math.max(0, Math.min(gridCols - 1, newGridX));
        newGridY = Math.max(0, Math.min(gridRows - 1, newGridY));
        
        // Update target
        ball.gridX = newGridX;
        ball.gridY = newGridY;
        const newPos = gridCellToPixel(newGridX, newGridY);
        ball.targetX = newPos.x;
        ball.targetY = newPos.y;
        
        // Start jump animation
        ball.jumpProgress = 0.0;
        ball.jumpStartX = ball.x;
        ball.jumpStartY = ball.y;
        
        // Schedule next jump with rhythm interval and randomness
        const intervalJitter = pulseRandomness * pulseInterval * (Math.random() - 0.5);
        const syncJitter = pulseSynchronicity * pulseInterval * Math.random();
        ball.nextJumpTime = pulseInterval + intervalJitter + syncJitter;
      }
      
      // Animate jump if in progress
      if (ball.jumpProgress < 1.0) {
        ball.jumpProgress += dt / pulseSpeed;
        
        if (ball.jumpProgress >= 1.0) {
          ball.jumpProgress = 1.0;
          ball.x = ball.targetX;
          ball.y = ball.targetY;
          ball.vx = 0;
          ball.vy = 0;
        } else {
          const t = ball.jumpProgress;
          let eased = t;
          
          // Apply easing based on style
          if (pulseEasingStyle === 'linear') {
            // Constant speed
            eased = t;
          } else if (pulseEasingStyle === 'snap') {
            // Robotic snap with overshoot and bounce-back
            if (t < 0.6) {
              // Fast acceleration to overshoot point
              const t1 = t / 0.6;
              eased = t1 * t1 * pulseOvershoot;
            } else {
              // Bounce back to final position
              const t2 = (t - 0.6) / 0.4;
              const bounceAmount = (pulseOvershoot - 1.0) * (1 - t2);
              eased = 1.0 + bounceAmount - pulseBounceIntensity * Math.sin(t2 * Math.PI);
            }
          } else if (pulseEasingStyle === 'bounce') {
            // Elastic bounce effect
            if (t < 0.7) {
              eased = (t / 0.7) * (t / 0.7);
            } else {
              const t2 = (t - 0.7) / 0.3;
              eased = 1.0 - pulseBounceIntensity * 0.5 * Math.sin(t2 * Math.PI * 2);
            }
          } else if (pulseEasingStyle === 'smooth') {
            // Classic ease-in-out
            eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
          }
          
          // Interpolate position (STRAIGHT LINE - no arc)
          ball.x = ball.jumpStartX + (ball.targetX - ball.jumpStartX) * eased;
          ball.y = ball.jumpStartY + (ball.targetY - ball.jumpStartY) * eased;
          
          // Zero velocity during animation
          ball.vx = 0;
          ball.vy = 0;
        }
      }
    }
  }

  /**
   * Update UI to reflect current mode selection
   * @description Toggles active class on mode controls and updates ARIA states
   * @returns {void}
   */
  function updateModeControlsUI() {
    const pulseGridControls = document.getElementById('pulseGridControls');
    const vortexControls = document.getElementById('vortexControls');
    if (pitControls) pitControls.classList.toggle('active', currentMode === MODES.PIT);
    if (fliesControls) fliesControls.classList.toggle('active', currentMode === MODES.FLIES);
    if (weightlessControls) weightlessControls.classList.toggle('active', currentMode === MODES.WEIGHTLESS);
    if (pulseGridControls) pulseGridControls.classList.toggle('active', currentMode === MODES.PULSE_GRID);
    if (vortexControls) vortexControls.classList.toggle('active', currentMode === MODES.VORTEX);
    
    // Update mode buttons and ARIA states
    modeButtons.forEach(btn => {
      const isActive = btn.getAttribute('data-mode') === currentMode;
      btn.classList.toggle('active', isActive);
      btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    });
  }
  
  /**
   * Announce message to screen readers via live region
   * @param {string} message - Message to announce
   * @returns {void}
   */
  function announceToScreenReader(message) {
    const announcer = document.getElementById('announcer');
    if (announcer) {
      announcer.textContent = ''; // Clear first for re-announcement
      setTimeout(() => announcer.textContent = message, 100);
    }
  }

  /**
   * Switch to a different simulation mode
   * @description Changes physics behavior, initializes mode-specific scene, and updates UI
   * @param {string} mode - Mode constant from MODES enum ('pit'|'flies'|'weightless'|'pulse-grid')
   * @returns {void}
   * @modifies {currentMode, balls, gravityMultiplier, G, repellerEnabled}
   * @example
   * setMode(MODES.PULSE_GRID); // Switch to grid mode
   */
  function setMode(mode) {
    currentMode = mode;
    
    // Announce mode change to screen readers
    const modeNames = {
      [MODES.PIT]: 'Ball Pit',
      [MODES.FLIES]: 'Flies to Light',
      [MODES.WEIGHTLESS]: 'Zero Gravity',
      [MODES.PULSE_GRID]: 'Pulse Grid',
      [MODES.VORTEX]: 'Vortex Spiral'
    };
    announceToScreenReader(`Switched to ${modeNames[mode]} mode`);
    
    // Update container CSS class for mode-specific styling (canvas height)
    container.className = ''; // Clear all mode classes
    if (currentMode === MODES.PIT) {
      container.classList.add('mode-pit'); // 150vh height
    }
    // Other modes use default 100svh (no class needed)
    
    // CRITICAL: Reapply dark mode state (preserves dark/light mode across mode switches)
    if (autoDarkModeEnabled) {
      applyDarkMode(isNightTime());
    } else {
      // Maintain current dark mode state even if auto is disabled
      if (isDarkMode) {
        container.classList.add('dark-mode');
      }
    }
    
    // Resize canvas to match new mode's height
    resize();
    
    // Apply per-mode high-level toggles and initialization
    if (currentMode === MODES.PIT) {
      gravityMultiplier = gravityMultiplierPit;
      G = GE * gravityMultiplier;
      repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0);
      EMITTER_SWEEP_ENABLED = false; // Disable continuous emitter - balls drop all at once
      // Apply heavy physics preset for realistic ball pit feel
      applyPhysicsPreset('rubberHeavy');
      // Reset scene when entering Ball Pit: spawn all balls at once above viewport
      balls.length = 0;
      emitterTimer = 0;
      // Spawn all balls at once from above the viewport
      initializeBallPitScene();
      // Reset ball sizes to global (after initialization)
      resetBallSizeToGlobal();
    } else if (currentMode === MODES.FLIES) {
      gravityMultiplier = 0.0; // no gravity
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
      // Initialize flies scene with idle swarm at center
      initializeFliesScene();
      // Reset ball sizes to global (after initialization)
      resetBallSizeToGlobal();
    } else if (currentMode === MODES.WEIGHTLESS) {
      gravityMultiplier = 0.0; // zero gravity (weightless)
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
      // Initialize weightless scene with even distribution
      initializeWeightlessScene();
      // Reset ball sizes to global (after initialization)
      resetBallSizeToGlobal();
    } else if (currentMode === MODES.PULSE_GRID) {
      gravityMultiplier = 0.0; // no physics gravity in grid mode
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
      // Initialize pulse grid scene with rhythmic movement
      initializePulseGridScene();
      // Reset ball sizes to global (after initialization)
      resetBallSizeToGlobal();
    } else if (currentMode === MODES.VORTEX) {
      gravityMultiplier = 0.0; // no world gravity in vortex mode
      G = GE * gravityMultiplier;
      repellerEnabled = false; // mouse acts as gravity well instead
      EMITTER_SWEEP_ENABLED = false;
      // Initialize vortex scene with orbital distribution
      initializeVortexScene();
      // Reset ball sizes to global (after initialization)
      resetBallSizeToGlobal();
    }
    updateModeControlsUI();
  }

  // Reset to Defaults button
  const resetBtn = document.getElementById('resetBtn');
  if (resetBtn) {
    resetBtn.addEventListener('click', () => {
      if (confirm('Reset all settings to defaults? This will reload the page with default values.')) {
        if (LOCALSTORAGE_ENABLED) {
          localStorage.removeItem(STORAGE_KEY);
        }
        log('üîÑ Reloading with defaults...');
        location.reload();
      }
    });
  }

  // Hook up UI listeners (with auto-save on changes)
  modeButtons.forEach(btn => btn.addEventListener('click', () => {
    setMode(btn.getAttribute('data-mode'));
    // Note: resetBallSizeToGlobal() is now called inside setMode() for each mode
    autoSaveSettings();
  }));
  gravityPitSlider && gravityPitSlider.addEventListener('input', () => {
    gravityMultiplierPit = parseFloat(gravityPitSlider.value);
    gravityPitVal && (gravityPitVal.textContent = gravityMultiplierPit.toFixed(1));
    autoSaveSettings();
    if (currentMode === MODES.PIT) { gravityMultiplier = gravityMultiplierPit; G = GE * gravityMultiplier; }
  });
  
  // Mode-specific weight controls
  weightPitSlider && weightPitSlider.addEventListener('input', () => {
    ballMassKg = parseFloat(weightPitSlider.value);
    weightPitVal && (weightPitVal.textContent = ballMassKg.toFixed(2));
    // Apply shared mass to all balls
    for (let i=0; i<balls.length; i++) {
      balls[i].m = ballMassKg;
    }
    // Recompute derived scaling so gravity visibly changes with weight
    recomputeMassDerivedScales();
    autoSaveSettings();
  });
  repellerEnabledPitEl && repellerEnabledPitEl.addEventListener('change', () => {
    repellerEnabledPit = !!repellerEnabledPitEl.checked;
    if (currentMode === MODES.PIT) repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0);
  });
  attractPowerSlider && attractPowerSlider.addEventListener('input', () => {
    attractionPower = parseFloat(attractPowerSlider.value);
    attractPowerVal && (attractPowerVal.textContent = Math.round(attractionPower).toString());
  });
  orbitRadiusSlider && orbitRadiusSlider.addEventListener('input', () => {
    orbitRadius = parseFloat(orbitRadiusSlider.value);
    orbitRadiusVal && (orbitRadiusVal.textContent = Math.round(orbitRadius).toString());
  });
  swarmSpeedSlider && swarmSpeedSlider.addEventListener('input', () => {
    swarmSpeed = parseFloat(swarmSpeedSlider.value);
    swarmSpeedVal && (swarmSpeedVal.textContent = swarmSpeed.toFixed(1));
  });
  
  // Weightless controls
  weightlessCountSlider && weightlessCountSlider.addEventListener('input', () => {
    weightlessCount = parseInt(weightlessCountSlider.value, 10);
    weightlessCountVal && (weightlessCountVal.textContent = weightlessCount.toString());
    if (currentMode === MODES.WEIGHTLESS) initializeWeightlessScene();
  });
  weightlessSpeedSlider && weightlessSpeedSlider.addEventListener('input', () => {
    weightlessInitialSpeed = parseFloat(weightlessSpeedSlider.value);
    weightlessSpeedVal && (weightlessSpeedVal.textContent = Math.round(weightlessInitialSpeed).toString());
  });
  weightlessBounceSlider && weightlessBounceSlider.addEventListener('input', () => {
    weightlessBounce = parseFloat(weightlessBounceSlider.value);
    weightlessBounceVal && (weightlessBounceVal.textContent = weightlessBounce.toFixed(2));
  });
  weightlessRepelSlider && weightlessRepelSlider.addEventListener('input', () => {
    weightlessRepellerPower = parseFloat(weightlessRepelSlider.value);
    weightlessRepelVal && (weightlessRepelVal.textContent = Math.round(weightlessRepellerPower).toString());
    autoSaveSettings();
  });
  weightlessRepelRadiusSlider && weightlessRepelRadiusSlider.addEventListener('input', () => {
    weightlessRepellerRadius = parseFloat(weightlessRepelRadiusSlider.value);
    weightlessRepelRadiusVal && (weightlessRepelRadiusVal.textContent = Math.round(weightlessRepellerRadius).toString());
    autoSaveSettings();
  });

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PULSE GRID MODE CONTROLS
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  const gridPresetSelect = document.getElementById('gridPresetSelect');
  const gridBallCountSlider = document.getElementById('gridBallCountSlider');
  const gridBallCountVal = document.getElementById('gridBallCountVal');
  const gridColumnsSlider = document.getElementById('gridColumnsSlider');
  const gridColumnsVal = document.getElementById('gridColumnsVal');
  const pulseIntervalSlider = document.getElementById('pulseIntervalSlider');
  const pulseIntervalVal = document.getElementById('pulseIntervalVal');
  const pulseSpeedSlider = document.getElementById('pulseSpeedSlider');
  const pulseSpeedVal = document.getElementById('pulseSpeedVal');
  const pulseMinStepsSlider = document.getElementById('pulseMinStepsSlider');
  const pulseMinStepsVal = document.getElementById('pulseMinStepsVal');
  const pulseMaxStepsSlider = document.getElementById('pulseMaxStepsSlider');
  const pulseMaxStepsVal = document.getElementById('pulseMaxStepsVal');
  const pulseSynchronicitySlider = document.getElementById('pulseSynchronicitySlider');
  const pulseSynchronicityVal = document.getElementById('pulseSynchronicityVal');
  const pulseRandomnessSlider = document.getElementById('pulseRandomnessSlider');
  const pulseRandomnessVal = document.getElementById('pulseRandomnessVal');
  
  // Preset configurations
  const gridPresets = {
    synchronized: {
      interval: 0.6,
      speed: 0.2,
      minSteps: 1,
      maxSteps: 2,
      synchronicity: 0.1,
      randomness: 0.2,
      easingStyle: 'snap',
      overshoot: 1.12,
      bounce: 0.18
    },
    organic: {
      interval: 0.8,
      speed: 0.25,
      minSteps: 1,
      maxSteps: 3,
      synchronicity: 0.3,
      randomness: 0.4,
      easingStyle: 'smooth',
      overshoot: 1.05,
      bounce: 0.1
    },
    chaotic: {
      interval: 0.4,
      speed: 0.15,
      minSteps: 2,
      maxSteps: 4,
      synchronicity: 0.7,
      randomness: 0.8,
      easingStyle: 'bounce',
      overshoot: 1.15,
      bounce: 0.25
    }
  };
  
  /**
   * Apply animation preset to Pulse Grid mode
   * @description Updates all grid animation parameters from preset configuration
   * @param {string} presetName - Preset key ('synchronized'|'organic'|'chaotic')
   * @returns {void}
   * @modifies {pulseInterval, pulseSpeed, pulseMinSteps, pulseMaxSteps, pulseSynchronicity, pulseRandomness, pulseEasingStyle, pulseOvershoot, pulseBounceIntensity}
   */
  function applyGridPreset(presetName) {
    const preset = gridPresets[presetName];
    if (!preset) return;
    
    pulseInterval = preset.interval;
    pulseSpeed = preset.speed;
    pulseMinSteps = preset.minSteps;
    pulseMaxSteps = preset.maxSteps;
    pulseSynchronicity = preset.synchronicity;
    pulseRandomness = preset.randomness;
    pulseEasingStyle = preset.easingStyle;
    pulseOvershoot = preset.overshoot;
    pulseBounceIntensity = preset.bounce;
    
    // Update UI
    if (pulseIntervalSlider) pulseIntervalSlider.value = preset.interval;
    if (pulseIntervalVal) pulseIntervalVal.textContent = preset.interval.toFixed(1);
    if (pulseSpeedSlider) pulseSpeedSlider.value = preset.speed;
    if (pulseSpeedVal) pulseSpeedVal.textContent = preset.speed.toFixed(2);
    if (pulseMinStepsSlider) pulseMinStepsSlider.value = preset.minSteps;
    if (pulseMinStepsVal) pulseMinStepsVal.textContent = preset.minSteps.toString();
    if (pulseMaxStepsSlider) pulseMaxStepsSlider.value = preset.maxSteps;
    if (pulseMaxStepsVal) pulseMaxStepsVal.textContent = preset.maxSteps.toString();
    if (pulseSynchronicitySlider) pulseSynchronicitySlider.value = preset.synchronicity;
    if (pulseSynchronicityVal) pulseSynchronicityVal.textContent = preset.synchronicity.toFixed(2);
    if (pulseRandomnessSlider) pulseRandomnessSlider.value = preset.randomness;
    if (pulseRandomnessVal) pulseRandomnessVal.textContent = preset.randomness.toFixed(2);
    
    const pulseEasingSelect = document.getElementById('pulseEasingSelect');
    const pulseOvershootSlider = document.getElementById('pulseOvershootSlider');
    const pulseOvershootVal = document.getElementById('pulseOvershootVal');
    const pulseBounceSlider = document.getElementById('pulseBounceSlider');
    const pulseBounceVal = document.getElementById('pulseBounceVal');
    
    if (pulseEasingSelect) pulseEasingSelect.value = preset.easingStyle;
    if (pulseOvershootSlider) pulseOvershootSlider.value = preset.overshoot;
    if (pulseOvershootVal) pulseOvershootVal.textContent = preset.overshoot.toFixed(2);
    if (pulseBounceSlider) pulseBounceSlider.value = preset.bounce;
    if (pulseBounceVal) pulseBounceVal.textContent = preset.bounce.toFixed(2);
    
    // Reinitialize if in grid mode
    if (currentMode === MODES.PULSE_GRID) {
      initializePulseGridScene();
    }
  }
  
  // Preset selector
  gridPresetSelect && gridPresetSelect.addEventListener('change', () => {
    applyGridPreset(gridPresetSelect.value);
    autoSaveSettings();
  });
  
  // Ball count
  gridBallCountSlider && gridBallCountSlider.addEventListener('input', () => {
    gridBallCount = parseInt(gridBallCountSlider.value, 10);
    gridBallCountVal && (gridBallCountVal.textContent = gridBallCount.toString());
    if (currentMode === MODES.PULSE_GRID) initializePulseGridScene();
    autoSaveSettings();
  });
  
  // Grid columns
  gridColumnsSlider && gridColumnsSlider.addEventListener('input', () => {
    gridColumns = parseInt(gridColumnsSlider.value, 10);
    gridColumnsVal && (gridColumnsVal.textContent = gridColumns.toString());
    if (currentMode === MODES.PULSE_GRID) {
      calculateGridDimensions();
      initializePulseGridScene();
    }
    autoSaveSettings();
  });
  
  // Beat interval
  pulseIntervalSlider && pulseIntervalSlider.addEventListener('input', () => {
    pulseInterval = parseFloat(pulseIntervalSlider.value);
    pulseIntervalVal && (pulseIntervalVal.textContent = pulseInterval.toFixed(1));
    autoSaveSettings();
  });
  
  // Jump speed
  pulseSpeedSlider && pulseSpeedSlider.addEventListener('input', () => {
    pulseSpeed = parseFloat(pulseSpeedSlider.value);
    pulseSpeedVal && (pulseSpeedVal.textContent = pulseSpeed.toFixed(2));
    autoSaveSettings();
  });
  
  // Min steps
  pulseMinStepsSlider && pulseMinStepsSlider.addEventListener('input', () => {
    pulseMinSteps = parseInt(pulseMinStepsSlider.value, 10);
    pulseMinStepsVal && (pulseMinStepsVal.textContent = pulseMinSteps.toString());
    // Ensure min <= max
    if (pulseMinSteps > pulseMaxSteps) {
      pulseMaxSteps = pulseMinSteps;
      if (pulseMaxStepsSlider) pulseMaxStepsSlider.value = pulseMinSteps;
      if (pulseMaxStepsVal) pulseMaxStepsVal.textContent = pulseMinSteps.toString();
    }
    autoSaveSettings();
  });
  
  // Max steps
  pulseMaxStepsSlider && pulseMaxStepsSlider.addEventListener('input', () => {
    pulseMaxSteps = parseInt(pulseMaxStepsSlider.value, 10);
    pulseMaxStepsVal && (pulseMaxStepsVal.textContent = pulseMaxSteps.toString());
    // Ensure min <= max
    if (pulseMaxSteps < pulseMinSteps) {
      pulseMinSteps = pulseMaxSteps;
      if (pulseMinStepsSlider) pulseMinStepsSlider.value = pulseMaxSteps;
      if (pulseMinStepsVal) pulseMinStepsVal.textContent = pulseMaxSteps.toString();
    }
    autoSaveSettings();
  });
  
  // Synchronicity
  pulseSynchronicitySlider && pulseSynchronicitySlider.addEventListener('input', () => {
    pulseSynchronicity = parseFloat(pulseSynchronicitySlider.value);
    pulseSynchronicityVal && (pulseSynchronicityVal.textContent = pulseSynchronicity.toFixed(2));
    autoSaveSettings();
  });
  
  // Randomness
  pulseRandomnessSlider && pulseRandomnessSlider.addEventListener('input', () => {
    pulseRandomness = parseFloat(pulseRandomnessSlider.value);
    pulseRandomnessVal && (pulseRandomnessVal.textContent = pulseRandomness.toFixed(2));
    autoSaveSettings();
  });
  
  // Animation style controls
  const pulseEasingSelect = document.getElementById('pulseEasingSelect');
  const pulseOvershootSlider = document.getElementById('pulseOvershootSlider');
  const pulseOvershootVal = document.getElementById('pulseOvershootVal');
  const pulseBounceSlider = document.getElementById('pulseBounceSlider');
  const pulseBounceVal = document.getElementById('pulseBounceVal');
  
  pulseEasingSelect && pulseEasingSelect.addEventListener('change', () => {
    pulseEasingStyle = pulseEasingSelect.value;
    autoSaveSettings();
  });
  
  pulseOvershootSlider && pulseOvershootSlider.addEventListener('input', () => {
    pulseOvershoot = parseFloat(pulseOvershootSlider.value);
    pulseOvershootVal && (pulseOvershootVal.textContent = pulseOvershoot.toFixed(2));
    autoSaveSettings();
  });
  
  pulseBounceSlider && pulseBounceSlider.addEventListener('input', () => {
    pulseBounceIntensity = parseFloat(pulseBounceSlider.value);
    pulseBounceVal && (pulseBounceVal.textContent = pulseBounceIntensity.toFixed(2));
    autoSaveSettings();
  });

  /**
   * Update existing ball colors to use new color palette
   * @returns {void}
   */
  function updateExistingBallColors() {
    for (let i = 0; i < balls.length; i++) {
      balls[i].color = pickRandomColor();
    }
  }
  
  /**
   * Update color picker UI elements to show current palette
   * @returns {void}
   */
  function updateColorPickersUI() {
    const color1 = document.getElementById('color1');
    const color2 = document.getElementById('color2');
    const color3 = document.getElementById('color3');
    const color4 = document.getElementById('color4');
    const color5 = document.getElementById('color5');
    const color6 = document.getElementById('color6');
    const color7 = document.getElementById('color7');
    const color8 = document.getElementById('color8');
    const color1Val = document.getElementById('color1Val');
    const color2Val = document.getElementById('color2Val');
    const color3Val = document.getElementById('color3Val');
    const color4Val = document.getElementById('color4Val');
    const color5Val = document.getElementById('color5Val');
    const color6Val = document.getElementById('color6Val');
    const color7Val = document.getElementById('color7Val');
    const color8Val = document.getElementById('color8Val');
    
    if (color1 && color1Val) { color1.value = currentColors[0]; color1Val.textContent = currentColors[0].toUpperCase(); }
    if (color2 && color2Val) { color2.value = currentColors[1]; color2Val.textContent = currentColors[1].toUpperCase(); }
    if (color3 && color3Val) { color3.value = currentColors[2]; color3Val.textContent = currentColors[2].toUpperCase(); }
    if (color4 && color4Val) { color4.value = currentColors[3]; color4Val.textContent = currentColors[3].toUpperCase(); }
    if (color5 && color5Val) { color5.value = currentColors[4]; color5Val.textContent = currentColors[4].toUpperCase(); }
    if (color6 && color6Val) { color6.value = currentColors[5]; color6Val.textContent = currentColors[5].toUpperCase(); }
    if (color7 && color7Val) { color7.value = currentColors[6]; color7Val.textContent = currentColors[6].toUpperCase(); }
    if (color8 && color8Val) { color8.value = currentColors[7]; color8Val.textContent = currentColors[7].toUpperCase(); }
  }
  
  color1 && color1.addEventListener('input', () => { currentColors[0] = color1.value; color1Val && (color1Val.textContent = color1.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color2 && color2.addEventListener('input', () => { currentColors[1] = color2.value; color2Val && (color2Val.textContent = color2.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color3 && color3.addEventListener('input', () => { currentColors[2] = color3.value; color3Val && (color3Val.textContent = color3.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color4 && color4.addEventListener('input', () => { currentColors[3] = color4.value; color4Val && (color4Val.textContent = color4.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color5 && color5.addEventListener('input', () => { currentColors[4] = color5.value; color5Val && (color5Val.textContent = color5.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color6 && color6.addEventListener('input', () => { currentColors[5] = color6.value; color6Val && (color6Val.textContent = color6.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color7 && color7.addEventListener('input', () => { currentColors[6] = color7.value; color7Val && (color7Val.textContent = color7.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color8 && color8.addEventListener('input', () => { currentColors[7] = color8.value; color8Val && (color8Val.textContent = color8.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  cursorColorSelect && cursorColorSelect.addEventListener('change', () => { 
    const idx = Math.max(1, Math.min(8, parseInt(cursorColorSelect.value, 10))) - 1; 
    cursorBallIndex = idx; 
    cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor;
    autoSaveSettings();
  });

  // Bind click-to-copy on hex badges
  bindCopyOnClick(color1Val, () => color1.value.toUpperCase());
  bindCopyOnClick(color2Val, () => color2.value.toUpperCase());
  bindCopyOnClick(color3Val, () => color3.value.toUpperCase());
  bindCopyOnClick(color4Val, () => color4.value.toUpperCase());
  bindCopyOnClick(color5Val, () => color5.value.toUpperCase());
  bindCopyOnClick(color6Val, () => color6.value.toUpperCase());
  bindCopyOnClick(color7Val, () => color7.value.toUpperCase());
  bindCopyOnClick(color8Val, () => color8.value.toUpperCase());
  // If the user changes any color, keep the cursor color stable unless it was the one changed
  // To keep behavior simple, we do not auto-switch the cursor color here.
  
  // Scene control event listeners
  cornerRadiusSlider && cornerRadiusSlider.addEventListener('input', () => { 
    cornerRadius = parseFloat(cornerRadiusSlider.value); 
    cornerRadiusVal && (cornerRadiusVal.textContent = cornerRadius.toFixed(0)); 
  });
  motionBlurFadeSlider && motionBlurFadeSlider.addEventListener('input', () => { 
    motionBlurFade = parseFloat(motionBlurFadeSlider.value); 
    motionBlurFadeVal && (motionBlurFadeVal.textContent = motionBlurFade.toFixed(3)); 
  });
  trailSubtletySlider && trailSubtletySlider.addEventListener('input', () => {
    trailSubtlety = parseFloat(trailSubtletySlider.value);
    trailSubtletyVal && (trailSubtletyVal.textContent = trailSubtlety.toFixed(2) + '√ó');
  });

  // Presets (10 each)
  // Rubber-focused physics presets under Earth gravity (‚âà1960 px/s¬≤)
  const PHYSICS_PRESETS = {
    rubberPlayground: { label: 'Rubber ‚Äì Playground', G: 1960, REST: 0.90, FRICTION: 0.0025, sizeScale: 1.2, maxBalls: 450, sizeVariation: 0.20 },
    rubberRacquet:    { label: 'Rubber ‚Äì Racquetball', G: 3320, REST: 0.97, FRICTION: 0.0035, sizeScale: 1.2, maxBalls: 350, sizeVariation: 0.30 },
    rubberSuperball:  { label: 'Rubber ‚Äì Superball', G: 1960, REST: 0.95, FRICTION: 0.0015, sizeScale: 1.2, maxBalls: 450, sizeVariation: 0.05 },
    rubberSoft:       { label: 'Rubber ‚Äì Soft', G: 1960, REST: 0.86, FRICTION: 0.0035, sizeScale: 1.2, maxBalls: 350, sizeVariation: 0.25 },
    rubberHeavy:      { label: 'Rubber ‚Äì Heavy', G: 1960, REST: 0.88, FRICTION: 0.0030, sizeScale: 1.2, maxBalls: 400, sizeVariation: 0.15 }
  };

  const SPAWN_PRESETS = {
    fullRain:       { label: 'Full Rain (top-half)', EMIT_INTERVAL: 0.030, xCenter: 50, y: -50, w: 100, h: 50 },
    narrowStrip:    { label: 'Narrow Strip Top', EMIT_INTERVAL: 0.050, xCenter: 50, y: -40, w: 20,  h: 10 },
    leftGutter:     { label: 'Left Gutter', EMIT_INTERVAL: 0.045, xCenter: 10, y: -60, w: 18,  h: 20 },
    rightGutter:    { label: 'Right Gutter', EMIT_INTERVAL: 0.045, xCenter: 90, y: -60, w: 18,  h: 20 },
    centerFountain: { label: 'Center Fountain', EMIT_INTERVAL: 0.020, xCenter: 50, y: -30, w: 30,  h: 20 },
    stormBurst:     { label: 'Storm Burst', EMIT_INTERVAL: 0.005, xCenter: 50, y: -80, w: 100, h: 30 },
    slowSnow:       { label: 'Slow Snow', EMIT_INTERVAL: 0.200, xCenter: 50, y: -30, w: 100, h: 20 },
    edgeDrizzle:    { label: 'Edge Drizzle', EMIT_INTERVAL: 0.080, xCenter: 15, y: -40, w: 30,  h: 15 },
    twinColumns:    { label: 'Twin Columns', EMIT_INTERVAL: 0.030, xCenter: 30, y: -50, w: 10,  h: 40 },
    focusedBeam:    { label: 'Focused Beam', EMIT_INTERVAL: 0.015, xCenter: 50, y: -70, w: 6,   h: 12 }
  };

  const REPELLER_PRESETS = {
    off:         { label: 'Off', r: 710,   p: 27400 * 10, s: 4.4 },
    gentle:      { label: 'Gentle Breeze', r: 120, p: 2500, s: 2.5 },
    pushField:   { label: 'Push Field', r: 240, p: 8000 * 10, s: 2.0 },
    tractor:     { label: 'Tractor Push', r: 320, p: 14000 * 10, s: 1.6 },
    magnet:      { label: 'Magnet Repel', r: 200, p: 18000 * 10, s: 3.0 },
    pulse:       { label: 'Pulse Strong', r: 280, p: 22000 * 10, s: 1.2 },
    wideSoft:    { label: 'Wide Soft', r: 500, p: 8000 * 10, s: 4.5 },
    needle:      { label: 'Needle Point', r: 80,  p: 26000 * 10, s: 0.8 },
    wall:        { label: 'Invisible Wall', r: 700, p: 16000 * 10, s: 5.0 },
    singularity: { label: 'Singularity', r: 600, p: 30000 * 10, s: 0.5 }
  };

  // Populate selects
  function fillSelect(select, dict, selectedKey) {
    select.innerHTML = '';
    for (const [key, val] of Object.entries(dict)) {
      const opt = document.createElement('option');
      opt.value = key; opt.textContent = val.label || key; if (key === selectedKey) opt.selected = true;
      select.appendChild(opt);
    }
  }

  const physicsSelect = document.getElementById('physicsSelect');
  const spawnSelect = document.getElementById('spawnSelect');
  const repellerSelect = document.getElementById('repellerSelect');

  if (physicsSelect) fillSelect(physicsSelect, PHYSICS_PRESETS, 'rubberRacquet');
  if (spawnSelect) fillSelect(spawnSelect, SPAWN_PRESETS, 'fullRain');
  if (repellerSelect) fillSelect(repellerSelect, REPELLER_PRESETS, 'off');
  // Populate color template dropdown
  if (colorSelect) fillSelect(colorSelect, COLOR_TEMPLATES, 'industrialTeal');

  // Helper function for UI updates
  function updateSliderAndValue(slider, valueElement, value, decimals = 0) {
    if (slider) slider.value = String(value);
    if (valueElement) valueElement.textContent = decimals > 0 ? value.toFixed(decimals) : value.toString();
  }

  // Reusable event listener factory for sliders
  // Removed unused slider listener factory

  // Apply preset helpers
  function applyPhysicsPreset(key) {
    const p = PHYSICS_PRESETS[key]; if (!p) return;
    // Keep gravity constant (1.1x Earth). Only apply REST and FRICTION from preset.
    REST = p.REST; FRICTION = p.FRICTION;
    MAX_BALLS = p.maxBalls; sizeVariation = p.sizeVariation;
    const newScale = p.sizeScale;
    sizeScale = newScale;
    // Recompute effective scale and proportionally resize existing balls
    updateEffectiveScaleAndBallSizes();
    // Apply mass to all balls
    for (let i=0; i<balls.length; i++) {
        balls[i].m = ballMassKg;
    }
    
    // Remove excess balls if new limit is lower (truncate efficiently)
    if (balls.length > MAX_BALLS) { balls.length = MAX_BALLS; }
    
    // Update UI efficiently (gravity is fixed; no slider to update)
    updateSliderAndValue(restitutionSlider, restitutionVal, REST, 2);
    updateSliderAndValue(frictionSlider, frictionVal, FRICTION, 4);
    updateSliderAndValue(sizeSliderGlobal, sizeValGlobal, sizeScale, 1);
    updateSliderAndValue(maxBallsSlider, maxBallsVal, MAX_BALLS, 0);
    updateSliderAndValue(sizeVariationSliderGlobal, sizeVariationValGlobal, sizeVariation, 1);
    
    // Apply the new size variation to existing balls
    updateExistingBallSizes();
  }
  function applySpawnPreset(key) {
    const s = SPAWN_PRESETS[key]; if (!s) return;
    EMIT_INTERVAL = s.EMIT_INTERVAL; SPAWN_X_CENTER_VW = s.xCenter; SPAWN_Y_VH = s.y; SPAWN_W_VW = s.w; SPAWN_H_VH = s.h;
    updateSliderAndValue(emitterSlider, emitterVal, EMIT_INTERVAL, 3);
    updateSliderAndValue(spawnCenterSlider, spawnCenterVal, SPAWN_X_CENTER_VW, 0);
    updateSliderAndValue(spawnYSlider, spawnYVal, SPAWN_Y_VH, 0);
    updateSliderAndValue(spawnWidthSlider, spawnWidthVal, SPAWN_W_VW, 0);
    updateSliderAndValue(spawnHeightSlider, spawnHeightVal, SPAWN_H_VH, 0);
  }
  function applyRepellerPreset(key) {
    const r = REPELLER_PRESETS[key]; if (!r) return;
    repelRadius = r.r; repelPower = r.p * (REPELLER_GLOBAL_MULTIPLIER / 20.0); // keep perceived strength consistent after global doubling
    repellerEnabled = (key !== 'off');
    updateSliderAndValue(repelSizeSlider, repelSizeVal, repelRadius, 0);
    // Sync slider to mapped power and label
    const sliderPos = powerToRepelSlider(repelPower);
    if (repelPowerSlider) repelPowerSlider.value = String(sliderPos);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    updateSliderAndValue(repelSoftSlider, repelSoftVal, repelSoft, 1);
  }

  // Apply sane defaults FIRST (before event listeners to avoid triggering them)
  applyPhysicsPreset('rubberHeavy'); // Heavy preset for Ball Pit mode
  applySpawnPreset('fullRain');
  applyRepellerPreset('off');
  
  // Load saved settings from localStorage FIRST (before initializing colors)
  const settingsLoaded = loadSettings();
  
  // Initialize dark mode BEFORE loading colors (critical for correct palette variant)
  console.log('üîç Initializing dark mode system...');
  isDarkMode = determineDarkMode(); // Synchronously determine dark/light mode
  console.log(`‚úÖ Dark mode determined: ${isDarkMode ? 'DARK' : 'LIGHT'} mode`);
  
  // Apply dark mode styling to container (must happen before color loading)
  if (isDarkMode) {
    container.classList.add('dark-mode');
  } else {
    container.classList.remove('dark-mode');
  }
  console.log(`   Container classes: ${container.classList.toString()}`);
  console.log(`   Background should be: ${isDarkMode ? '#0a0a0a (dark)' : '#cecece (light)'}`);
  
  // NOW initialize color system with correct dark/light variant
  applyColorTemplate(currentTemplate); // Applies correct palette based on isDarkMode
  console.log(`   Color template applied: ${currentTemplate} (${isDarkMode ? 'dark' : 'light'} variant)`);
  
  // Check dark mode every minute for time transitions
  const darkModeInterval = setInterval(checkAndApplyDarkMode, 60000); // Every 60 seconds
  
  // Cleanup intervals on page unload (prevents memory leak in SPA contexts)
  window.addEventListener('unload', () => {
    if (darkModeInterval) clearInterval(darkModeInterval);
  });

  // Hook presets to selects AFTER applying defaults
  physicsSelect && physicsSelect.addEventListener('change', () => applyPhysicsPreset(physicsSelect.value));
  spawnSelect && spawnSelect.addEventListener('change', () => applySpawnPreset(spawnSelect.value));
  repellerSelect && repellerSelect.addEventListener('change', () => applyRepellerPreset(repellerSelect.value));

  // Now that sizeScale is set by presets, compute responsive scale once
  updateEffectiveScaleAndBallSizes();
  
  // Initialize text colliders
  updateTextColliders();
  
  // Apply canvas shadow with loaded or default settings
  updateCanvasShadow();
  
  // Apply device-specific mode visibility (hide Trail on mobile)
  applyDeviceSpecificModeVisibility();
  
  // Initialize mode: random mode on each page load
  if (!settingsLoaded || true) { // Always randomize mode
    const availableModes = Object.values(MODES);
    const randomMode = availableModes[Math.floor(Math.random() * availableModes.length)];
    currentMode = randomMode;
    console.log(`üé≤ Random mode selected: ${randomMode}`);
  }
  setMode(currentMode);
  
  // Save settings on mode change or slider change
  window.addEventListener('beforeunload', saveSettings);
})();
</script>
</body>
</html>

