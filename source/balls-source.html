<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Refined Bravia Balls â€“ Canvas Physics</title>
<style>
  html, body { height: 100%; margin: 0; background: #cecece; overflow:hidden; }
  /* Scoped wrapper for embed friendliness and interaction hygiene */
  #bravia-balls {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 100svh; /* Default height for most modes */
    overscroll-behavior: contain;
    -webkit-tap-highlight-color: transparent;
    user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
  }
  /* Ball Pit mode needs extra height for spawning above viewport */
  #bravia-balls.mode-pit {
    height: 150vh;
  }
  #bravia-balls canvas { 
    display: block; 
    width: 100%; 
    height: 100%; /* Match parent height */
    position: absolute;
    bottom: 0;
    left: 0;
    -webkit-user-drag: none;
    user-select: none; 
    -webkit-user-select: none;
    touch-action: none;
    cursor: none;
  }
  @media (prefers-reduced-motion: reduce) { 
    #bravia-balls canvas { filter: none; } 
  }
  #bravia-balls .panel {
    position: fixed;
    top: 5vh;
    right: 5vh;
    color: #fff;
    font: 10px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    background: rgba(0,0,0,0.45);
    padding: 6px;
    border-radius: 6px;
    user-select: none;
    display: flex;
    flex-direction: column;
    gap: 4px;
    z-index: 10;
    max-height: 90vh;
    overflow: auto;
    backdrop-filter: blur(6px);
    cursor: move;
    min-width: 200px;
  }
  #bravia-balls .panel.hidden { display: none; }
  #bravia-balls .panel .panel-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 6px;
    background: rgba(255,255,255,0.05);
    border-radius: 4px;
    margin-bottom: 4px;
    cursor: move;
    font-weight: 600;
    font-size: 11px;
  }
  #bravia-balls .panel .panel-header .drag-handle {
    opacity: 0.5;
    margin-right: 6px;
  }
  #bravia-balls .panel label {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 4px;
    width: 200px;
    font-size: 9px;
  }
  #bravia-balls .panel label span:first-child {
    flex-shrink: 0;
    max-width: 90px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  #bravia-balls .panel input[type="range"] {
    flex: 1;
    min-width: 60px;
    height: 12px;
  }
  #bravia-balls .panel span.val {
    width: 42px;
    text-align: right;
    font-family: monospace;
    font-size: 9px;
  }
  #bravia-balls .panel span.hex-val {
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    font-size: 10px;
    color: #888;
    background: rgba(0,0,0,0.05);
    padding: 1px 4px;
    border-radius: 2px;
    margin-left: 4px;
    text-transform: uppercase;
    cursor: pointer;
  }
  #bravia-balls .panel code {
    font-family: monospace;
    background: rgba(255,255,255,0.1);
    padding: 1px 3px;
    border-radius: 3px;
    font-size: 9px;
  }
  #bravia-balls .panel details { background: rgba(255,255,255,0.04); border-radius: 4px; padding: 4px; }
  #bravia-balls .panel summary { cursor: pointer; list-style: none; outline: none; font-size: 10px; }
  #bravia-balls .panel summary::-webkit-details-marker { display: none; }
  #bravia-balls .panel summary { display:flex; align-items:center; justify-content:space-between; color:#b8c2c7; padding: 2px; }
  #bravia-balls .panel .group { display:flex; flex-direction:column; gap:4px; margin-top:4px; }
  #bravia-balls .panel button {
    font-size: 9px;
    padding: 4px 8px;
  }
  #bravia-balls .panel select {
    font-size: 9px;
    padding: 2px 4px;
  }
  #bravia-balls .panel input[type="color"] {
    width: 28px;
    height: 20px;
    border: none;
    border-radius: 3px;
    padding: 0;
  }
  
  /* Mode switcher - segmented control */
  #bravia-balls .mode-switcher {
    display: flex;
    background: rgba(0,0,0,0.3);
    border-radius: 4px;
    padding: 1px;
    gap: 1px;
    margin-bottom: 6px;
  }
  #bravia-balls .mode-button {
    flex: 1;
    padding: 4px 6px;
    background: transparent;
    border: none;
    border-radius: 3px;
    color: rgba(255,255,255,0.6);
    font-size: 9px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
  }
  #bravia-balls .mode-button:hover {
    background: rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.8);
  }
  #bravia-balls .mode-button.active {
    background: rgba(255,255,255,0.15);
    color: #ffffff;
    font-weight: 600;
  }
  #bravia-balls .mode-controls { display: none; }
  #bravia-balls .mode-controls.active { display: block; }
  
  /* Palette variables (defaults match 'industrialTeal') */
  :root {
    --ball-1: #b7bcb7;
    --ball-2: #e4e9e4;
    --ball-3: #ffffff;
    --ball-4: #00695c;
    --ball-5: #000000;
    --ball-6: #ff4013;
    --ball-7: #0d5cb6;
    --ball-8: #ffa000;
  }
  /* Utility classes for using the palette elsewhere on the page */
  .text-ball-1 { color: var(--ball-1); }
  .text-ball-2 { color: var(--ball-2); }
  .text-ball-3 { color: var(--ball-3); }
  .text-ball-4 { color: var(--ball-4); }
  .text-ball-5 { color: var(--ball-5); }
  .text-ball-6 { color: var(--ball-6); }
  .text-ball-7 { color: var(--ball-7); }
  .text-ball-8 { color: var(--ball-8); }
  .bg-ball-1 { background-color: var(--ball-1); }
  .bg-ball-2 { background-color: var(--ball-2); }
  .bg-ball-3 { background-color: var(--ball-3); }
  .bg-ball-4 { background-color: var(--ball-4); }
  .bg-ball-5 { background-color: var(--ball-5); }
  .bg-ball-6 { background-color: var(--ball-6); }
  .bg-ball-7 { background-color: var(--ball-7); }
  .bg-ball-8 { background-color: var(--ball-8); }
  .border-ball-1 { border-color: var(--ball-1); }
  .border-ball-2 { border-color: var(--ball-2); }
  .border-ball-3 { border-color: var(--ball-3); }
  .border-ball-4 { border-color: var(--ball-4); }
  .border-ball-5 { border-color: var(--ball-5); }
  .border-ball-6 { border-color: var(--ball-6); }
  .border-ball-7 { border-color: var(--ball-7); }
  .border-ball-8 { border-color: var(--ball-8); }
</style>
</head>
<body>
<div id="bravia-balls">
  <canvas id="c" aria-label="Bouncy balls simulation" role="img" draggable="false"></canvas>
  <div class="panel" id="controlPanel">
  
  <!-- Draggable header -->
  <div class="panel-header" id="panelHeader">
    <span><span class="drag-handle">â‹®â‹®</span>Controls</span>
    <span style="cursor: pointer; opacity: 0.7;" id="minimizePanel" title="Toggle panel (/)">âˆ’</span>
  </div>
  
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <!-- GLOBAL SETTINGS (apply to ALL modes) - ABOVE MODE SWITCHER             -->
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  
  <details open>
    <summary>ğŸŒ Global Ball Properties</summary>
    <div class="group">
        <label title="Global ball size scale (0.1-6.0). Smaller = more balls fit, larger = more dramatic collisions">Size: <span class="val" id="sizeValGlobal">0.7</span><input type="range" id="sizeSliderGlobal" min="0.1" max="6.0" step="0.05" value="0.7"></label>
        <label title="Size variation from base size (0.0-1.0). 0 = identical sizes, 1.0 = up to 100% variation">Size variation: <span class="val" id="sizeVariationValGlobal">1.0</span><input type="range" id="sizeVariationSliderGlobal" min="0.0" max="1.0" step="0.05" value="1.0"></label>
        <label title="Ball deformation on collision (0-100). 0 = rigid/hard, 100 = very soft/squishy">Softness: <span class="val" id="ballSoftnessValGlobal">40</span><input type="range" id="ballSoftnessSliderGlobal" min="0" max="100" step="1" value="40"></label>
        <div style="font-size: 9px; opacity: 0.7; margin-top: 4px;">Softness: 0 = rigid, 40 = normal, 100 = very squishy</div>
    </div>
  </details>
  
  <!-- Build Controls -->
  <div style="margin-bottom: 12px; padding: 8px; background: rgba(0,255,0,0.1); border-radius: 4px; text-align: center;">
    <button id="saveConfigBtn" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold; margin-right: 8px;">ğŸ’¾ Save Config</button>
    <button id="buildBtn" style="background: #2196F3; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">ğŸš€ Build Embed</button>
    <div id="configOutput" style="margin-top: 8px; font-family: monospace; font-size: 10px; color: #333; max-height: 120px; overflow-y: auto; display: none; text-align: left; background: rgba(255,255,255,0.8); padding: 6px; border-radius: 3px;"></div>
    </div>
  
  <details open>
    <summary>ğŸ¨ Colors</summary>
    <div class="group">
        <label>Color template: <select id="colorSelect"></select></label>
        <label>Color 1 (50%): <input type="color" id="color1" value="#ffffff"> <span class="hex-val" id="color1Val">#ffffff</span></label>
        <label>Color 2 (25%): <input type="color" id="color2" value="#f8f9fa"> <span class="hex-val" id="color2Val">#f8f9fa</span></label>
        <label>Color 3 (12%): <input type="color" id="color3" value="#e9ecef"> <span class="hex-val" id="color3Val">#e9ecef</span></label>
        <label>Color 4 (6%): <input type="color" id="color4" value="#d90429"> <span class="hex-val" id="color4Val">#d90429</span></label>
        <label>Color 5 (3%): <input type="color" id="color5" value="#000000"> <span class="hex-val" id="color5Val">#000000</span></label>
        <label>Color 6 (2%): <input type="color" id="color6" value="#54d4ff"> <span class="hex-val" id="color6Val">#54d4ff</span></label>
        <label>Color 7 (1%): <input type="color" id="color7" value="#b589ff"> <span class="hex-val" id="color7Val">#b589ff</span></label>
        <label>Color 8 (1%): <input type="color" id="color8" value="#ffc27a"> <span class="hex-val" id="color8Val">#ffc27a</span></label>
        <label>Cursor color:
          <select id="cursorColorSelect">
            <option value="1">Color 1</option>
            <option value="2">Color 2</option>
            <option value="3">Color 3</option>
            <option value="4">Color 4</option>
            <option value="5">Color 5</option>
            <option value="6" selected>Color 6 (highlight)</option>
            <option value="7">Color 7</option>
            <option value="8">Color 8</option>
          </select>
        </label>
        <div style="font-size: 9px; opacity: 0.7; margin-top: 4px;">Colors appear by weight: 1 is most common, 8 is rarest</div>
    </div>
  </details>
  
  <details open>
    <summary>âœ¨ 3D Shader & Lighting</summary>
    <div class="group">
      <label title="Enable/disable 3D gradient shader effect">
        <span>Shader enabled</span>
        <input type="checkbox" id="shaderEnabled" checked>
      </label>
      
      <label title="Ball roundness (0-100%). 0=flat, 50=casino chip with beveled edges, 100=full sphere">
        <span>Roundness</span>
        <input type="range" id="ballRoundness" min="0" max="100" step="5" value="0">
        <span class="val" id="ballRoundnessVal">0%</span>
      </label>
      
      <div style="font-size: 9px; opacity: 0.7; margin: 4px 0;">
        0% = Flat Â· 50% = Casino Chip Â· 100% = Sphere
      </div>
      
      <label title="Light direction angle (0-360 degrees). -135Â° = top-left (default), -90Â° = top, 0Â° = right">
        <span>Light angle</span>
        <input type="range" id="lightAngle" min="-180" max="180" step="15" value="-135">
        <span class="val" id="lightAngleVal">-135Â°</span>
      </label>
      
      <details>
        <summary style="font-size: 11px; opacity: 0.8; cursor: pointer; margin-top: 6px;">âš™ï¸ Advanced settings</summary>
        <div class="group" style="margin-top: 6px;">
          <label title="Width of the beveled edge on casino chips (0-50%). Higher = wider bevel">
            <span>Edge bevel width</span>
            <input type="range" id="edgeBevelWidth" min="0" max="50" step="5" value="15">
            <span class="val" id="edgeBevelWidthVal">15%</span>
          </label>
          
          <label title="Sharpness of the bevel transition (0.5-5.0). Lower = softer, higher = sharper">
            <span>Edge sharpness</span>
            <input type="range" id="edgeSharpness" min="0.5" max="5.0" step="0.5" value="2.0">
            <span class="val" id="edgeSharpnessVal">2.0</span>
          </label>
          
          <label title="Intensity of the specular highlight (0-100%). Glass reflection strength">
            <span>Specular intensity</span>
            <input type="range" id="specularIntensity" min="0" max="100" step="5" value="70">
            <span class="val" id="specularIntensityVal">70%</span>
          </label>
        </div>
      </details>
    </div>
  </details>
  
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  <!--                        MODE SWITCHER & MODE SETTINGS                     -->
  <!-- â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
  
  <div style="margin: 20px 0; padding: 12px 0; border-top: 1px solid rgba(255,255,255,0.15);">
    <div style="text-align: center; font-size: 10px; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; opacity: 0.6; margin-bottom: 12px;">
      Mode Settings
    </div>
    
    <!-- Mode Switcher -->
    <div class="mode-switcher" style="margin-bottom: 16px;">
      <button class="mode-button active" data-mode="pit">ğŸ¯ Pit</button>
      <button class="mode-button" data-mode="flies">ğŸ•Šï¸ Flies</button>
      <button class="mode-button" data-mode="weightless">ğŸŒŒ Zero-G</button>
    </div>
  </div>
  
  <div id="pitControls" class="mode-controls active">
    <details open>
      <summary>ğŸ¯ Ball Pit Mode</summary>
      <div class="group">
        <label title="Choose physics preset (Rubber, Bouncy, etc.)">
          <span>Physics template</span>
          <select id="physicsSelect"></select>
        </label>
        <label title="Gravity strength (0.0-2.0Ã— Earth gravity). 1.0 = realistic, 0 = no gravity, 2.0 = very strong">
          <span>Gravity (Ã—Earth)</span>
          <input type="range" id="gravityPitSlider" min="0.0" max="2.0" step="0.05" value="1.15">
          <span class="val" id="gravityPitVal">1.15</span>
        </label>
        <label title="Ball mass/weight (50-200 grams). Realistic rubber ball: 100-150g. Heavier = more weight feel">
          <span>Weight (grams)</span>
          <input type="range" id="weightPitSlider" min="50.0" max="200.0" step="5.0" value="120.0">
          <span class="val" id="weightPitVal">120.0</span>
        </label>
        <label title="Bounce restitution (0.0-1.0). Realistic rubber: 0.75-0.85. 0 = no bounce, 1.0 = perfect elastic">
          <span>Bounciness</span>
          <input type="range" id="restitutionSlider" min="0.00" max="1.00" step="0.01" value="0.80">
          <span class="val" id="restitutionVal">0.80</span>
        </label>
        <label title="Air resistance/friction (0.000-0.010). Realistic: 0.003-0.005. 0 = no drag, 0.010 = high drag">
          <span>Air friction</span>
          <input type="range" id="frictionSlider" min="0.000" max="0.010" step="0.0005" value="0.0045">
          <span class="val" id="frictionVal">0.0045</span>
        </label>
      </div>
    </details>
    <details open>
      <summary>ğŸ–¼ï¸ Scene & Effects</summary>
      <div class="group">
        <label title="Maximum number of balls in simulation (50-800). Higher = more crowded. Recommended: 150 for 90+ FPS">
          <span>Max balls</span>
          <input type="range" id="maxBallsSlider" min="50" max="800" step="25" value="150">
          <span class="val" id="maxBallsVal">150</span>
        </label>
        <label title="Rounded corner radius for viewport (0-50 pixels). 0 = sharp corners">
          <span>Corner radius (px)</span>
          <input type="range" id="cornerRadiusSlider" min="0" max="50" step="2" value="0">
          <span class="val" id="cornerRadiusVal">0</span>
        </label>
        <label title="Motion blur trail length (0.0-0.5). 0 = no blur, 0.5 = long trails">
          <span>Motion blur</span>
          <input type="range" id="trailFadeSlider" min="0.000" max="0.500" step="0.005" value="0.000">
          <span class="val" id="trailFadeVal">0.000</span>
        </label>
        <label title="Motion blur intensity (0.5-2.0Ã—). Higher = more pronounced trails">
          <span>Blur intensity</span>
          <input type="range" id="trailSubtletySlider" min="0.50" max="2.00" step="0.05" value="1.00">
          <span class="val" id="trailSubtletyVal">1.00Ã—</span>
        </label>
        <div style="font-size: 9px; opacity: 0.7; margin-top: 4px;">Motion blur works in all modes</div>
      </div>
    </details>
    <details open>
      <summary>ğŸ¯ Spawn Settings</summary>
      <div class="group">
        <label title="Choose spawn behavior preset">
          <span>Spawn template</span>
          <select id="spawnSelect"></select>
        </label>
        <label title="Time between ball spawns (0.01-0.5 seconds). Lower = more frequent">
          <span>Emit interval (s)</span>
          <input type="range" id="emitterSlider" min="0.010" max="0.500" step="0.005" value="0.04">
          <span class="val" id="emitterVal">0.04</span>
        </label>
        <label title="Vertical spawn position (-100 to 100% viewport height). Negative = above viewport">
          <span>Spawn Y position (%)</span>
          <input type="range" id="spawnYSlider" min="-100" max="100" step="5" value="-50">
          <span class="val" id="spawnYVal">-50</span>
        </label>
        <label title="Horizontal spawn area width (10-100% viewport width). 100% = full width">
          <span>Spawn width (%)</span>
          <input type="range" id="spawnWidthSlider" min="10" max="100" step="5" value="100">
          <span class="val" id="spawnWidthVal">100</span>
        </label>
        <label title="Horizontal spawn center position (0-100% viewport width). 50% = center">
          <span>Spawn X center (%)</span>
          <input type="range" id="spawnCenterSlider" min="0" max="100" step="5" value="50">
          <span class="val" id="spawnCenterVal">50</span>
        </label>
        <label title="Vertical spawn area height (10-100% viewport height)">
          <span>Spawn height (%)</span>
          <input type="range" id="spawnHeightSlider" min="10" max="100" step="5" value="50">
          <span class="val" id="spawnHeightVal">50</span>
        </label>
      </div>
    </details>
    <details open>
      <summary>ğŸ§² Mouse Repeller</summary>
      <div class="group">
        <label title="Choose repeller behavior preset">
          <span>Repeller template</span>
          <select id="repellerSelect"></select>
        </label>
        <label title="Enable/disable mouse repeller effect">
          <span>Repeller active</span>
          <input type="checkbox" id="repellerEnabledPit" checked>
        </label>
        <label title="Repeller influence radius (50-400 pixels). Larger = affects more balls">
          <span>Repel size (px)</span>
          <input type="range" id="repelSizeSlider" min="50" max="400" step="5" value="200">
          <span class="val" id="repelSizeVal">200</span>
        </label>
        <label title="Repulsion strength (0-10000). Higher = stronger push away from mouse">
          <span>Repel power</span>
          <input type="range" id="repelPowerSlider" min="0" max="10000" step="100" value="500">
          <span class="val" id="repelPowerVal">500</span>
        </label>
        <label title="Repeller field softness (0.5-5.0). Lower = sharper cutoff, higher = gradual fade">
          <span>Repel softness</span>
          <input type="range" id="repelSoftSlider" min="0.5" max="5.0" step="0.1" value="2.0">
          <span class="val" id="repelSoftVal">2.0</span>
        </label>
      </div>
    </details>
  </div>
  
  <div id="fliesControls" class="mode-controls">
    <details open>
      <summary>ğŸ•Šï¸ Flies to Light Mode</summary>
      <div class="group">
        <label title="Attraction strength toward mouse (100-8000). Higher = stronger pull toward cursor">
          <span>Attraction power</span>
          <input type="range" id="attractPowerSlider" min="100" max="8000" step="50" value="5000">
          <span class="val" id="attractPowerVal">5000</span>
        </label>
        <label title="Orbit distance around mouse (50-400 pixels). Larger = wider swarm formation">
          <span>Orbit radius (px)</span>
          <input type="range" id="orbitRadiusSlider" min="50" max="400" step="10" value="180">
          <span class="val" id="orbitRadiusVal">180</span>
        </label>
        <label title="Swarm movement speed (0.2-5.0Ã—). Higher = faster, more responsive">
          <span>Swarm speed (Ã—)</span>
          <input type="range" id="swarmSpeedSlider" min="0.2" max="5.0" step="0.1" value="3.5">
          <span class="val" id="swarmSpeedVal">3.5</span>
        </label>
      </div>
    </details>
  </div>
  
  <!-- Weightless Mode Controls -->
  <div id="weightlessControls" class="mode-controls">
    <details open>
      <summary>ğŸŒŒ Zero-G Mode</summary>
      <div class="group">
        <label title="Number of balls in scene (20-200). Fixed count, no spawning">
          <span>Ball count</span>
          <input type="range" id="weightlessCountSlider" min="20" max="200" step="10" value="80">
          <span class="val" id="weightlessCountVal">80</span>
        </label>
        <label title="Initial velocity magnitude (100-600 pixels/second). Realistic space: 200-300. Higher = faster motion">
          <span>Initial speed (px/s)</span>
          <input type="range" id="weightlessSpeedSlider" min="100" max="600" step="25" value="250">
          <span class="val" id="weightlessSpeedVal">250</span>
        </label>
        <label title="Wall bounce elasticity (0.8-1.0). Realistic space: 0.95-0.98. 1.0 = perfect energy conservation">
          <span>Bounce elasticity</span>
          <input type="range" id="weightlessBounceSlider" min="0.8" max="1.0" step="0.01" value="0.97">
          <span class="val" id="weightlessBounceVal">0.97</span>
        </label>
      </div>
    </details>
    <details open>
      <summary>ğŸ§² Mouse Repeller</summary>
      <div class="group">
        <label title="Repeller strength (0-10000). 0 = disabled. Controls how strongly balls are pushed away from cursor">
          <span>Repeller power</span>
          <input type="range" id="weightlessRepelSlider" min="0" max="10000" step="100" value="300">
          <span class="val" id="weightlessRepelVal">300</span>
        </label>
        <label title="Repeller radius (50-300 pixels). Larger = wider push area around cursor">
          <span>Repeller radius (px)</span>
          <input type="range" id="weightlessRepelRadiusSlider" min="50" max="300" step="10" value="150">
          <span class="val" id="weightlessRepelRadiusVal">150</span>
        </label>
      </div>
    </details>
  </div>
  
    <div style="font-size:10px; opacity:0.8;">Press <code>R</code> to reset â€¢ <code>/</code> toggle panel â€¢ <code>1-3</code> switch modes</div>
  </div>
  
  <!-- FPS Counter -->
  <div id="fps-counter" style="position: fixed; top: 5vh; left: 5vh; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 4px; font-family: monospace; font-size: 12px; z-index: 1001; backdrop-filter: blur(6px); line-height: 1.4;">
    Render: <span id="render-fps">--</span> fps<br>
    Physics: <span id="physics-fps">--</span> fps<br>
  </div>
</div>
<script>
// Version: 2024-09-30 - Added 3-mode system (Ball Pit, Flies to Light, Mouse Trail)
(() => {
  // Behavior modes with device availability
  const MODES = {
    PIT: 'pit',          // Ball Pit: gravity + repeller
    FLIES: 'flies',      // Flies to Light: attraction to mouse, no gravity
    WEIGHTLESS: 'weightless'  // Weightless Bounce: zero-G bouncing balls
  };
  
  // Mode availability by device type
  const MODE_AVAILABILITY = {
    [MODES.PIT]: { desktop: true, mobile: true },
    [MODES.FLIES]: { desktop: true, mobile: true },
    [MODES.WEIGHTLESS]: { desktop: true, mobile: true }
  };
  
  let currentMode = MODES.PIT;
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // GLOBAL PARAMETERS (apply to all modes)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let ballSoftness = 40; // 0-100: controls squash/stretch on collision (0=hard, 100=very squishy)
  
  // Mode-specific parameters
  // Ball Pit mode parameters - REALISTIC RUBBER BALL PHYSICS
  let gravityMultiplierPit = 1.15; // Slightly heavier feel for realism
  let repellerEnabledPit = true;
  
  // Flies mode parameters - REALISTIC INSECT FLIGHT (mosquitoes/gnats)
  let attractionPower = 5000; // Much faster: insects dart quickly toward light
  let orbitRadius = 180; // Wider: insects don't cluster tightly
  let swarmSpeed = 3.5; // 3.5x faster: insects are quick and erratic
  
  // Weightless mode parameters - REALISTIC SPACE PHYSICS
  let weightlessCount = 80; // fixed number of balls
  let weightlessInitialSpeed = 250; // Slightly faster for visible motion in zero-g
  let weightlessBounce = 0.97; // Very elastic but not perfect (micro-imperfections)
  let weightlessRepellerPower = 300; // subtle mouse repeller strength
  let weightlessRepellerRadius = 150; // repeller radius (px)
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // 3D SHADER SYSTEM - Roundness Dial (Casino Chip â†’ Sphere)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let shaderEnabled = true;           // Master toggle for shader effect
  let ballRoundness = 0;              // 0-100: 0=flat, 50=chip, 100=sphere
  let lightAngle = -135;              // Light direction in degrees (top-left by default)
  let edgeBevelWidth = 0.15;          // Width of chip bevel edge (0.0-0.5)
  let edgeSharpness = 2.0;            // Sharpness of bevel transition (0.5-5.0)
  let specularIntensity = 0.7;        // Glass reflection strength (0.0-1.0)
  
  // Mass constants (needed before CONSTANTS object)
  const MASS_BASELINE_KG = 1.0; // reference mass for scaling drag/forces
  
  // Constants for magic numbers
  const CONSTANTS = {
    CANVAS_HEIGHT_VH_PIT: 1.5,    // 150vh for Ball Pit (spawning above viewport)
    CANVAS_HEIGHT_VH_DEFAULT: 1.0, // 100vh for other modes
    OFFSCREEN_MOUSE: -1e9,        // Offscreen mouse position
    MIN_DISTANCE_EPSILON: 1e-6,   // Minimum distance for collision calculations
    MIN_REPEL_DISTANCE: 1e-4,     // Minimum repeller distance
    ACCUMULATOR_RESET_THRESHOLD: 3, // Reset accumulator if behind by this many frames
    INITIAL_SEED_BALLS: 200,      // Initial balls to seed
    BALL_SPAWN_OFFSET: 2,         // Offset for ball spawning
    BALL_CLUSTER_SPACING: 8,      // Spacing between clustered balls
    BALL_CLUSTER_Y_OFFSET: 12,    // Y offset for clustered balls
    MAX_PHYSICS_STEPS: 2,         // Maximum physics steps per frame
    FPS_UPDATE_INTERVAL: 1.0,     // FPS counter update interval in seconds
    // Spin & squash tuning
    SPIN_DAMP_PER_S: 2.0,         // angular damping per second
    SPIN_GAIN: 0.25,              // how strongly tangential slip converts to spin
    SPIN_GAIN_TANGENT: 0.18,      // ballâ€“ball tangential slip to spin
    ROLL_FRICTION_PER_S: 1.5,     // rolling friction for horizontal speed per second when grounded
    SQUASH_MAX_BASE: 0.20,        // base maximum squash at softness=40 (moderate)
    SQUASH_DECAY_PER_S: 18.0,     // faster relaxation for snappy feel
    WALL_REST_VEL_THRESHOLD: 70,  // below this, wall bounce becomes inelastic (settles)
    GROUND_COUPLING_PER_S: 8.0    // match roll (vx) to spin (omega) when grounded
  };
  
  // Dynamic squash calculation based on ball softness (0-100)
  // 0 = completely hard (no deformation)
  // 40 = normal/default (0.20 squash)
  // 100 = very squishy (0.50 squash)
  function getSquashMax() {
    if (ballSoftness === 0) return 0; // Completely hard - no squash
    // Linear interpolation: softness 40 = base value (0.20)
    // softness 100 = 2.5Ã— base (0.50)
    return CONSTANTS.SQUASH_MAX_BASE * (ballSoftness / 40.0);
  }

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  const panel = document.getElementById('controlPanel');
  const container = document.getElementById('bravia-balls');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WEBGL RENDERER SYSTEM (Phase 2.2)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  let useWebGL = false; // Start with Canvas2D by default
  let pixiApp = null;
  let ballSprites = new Map(); // Map<Ball, PIXI.Graphics>
  
  async function initWebGLRenderer() {
    if (!window.PIXI) {
      console.error('âŒ PixiJS not loaded');
      return false;
    }
    
    try {
      // Create PixiJS application
      pixiApp = new PIXI.Application({
        width: canvas.width,
        height: canvas.height,
        resolution: DPR,
        backgroundColor: 0xCECECE,
        antialias: true,
        autoDensity: true,
      });
      
      // Insert WebGL canvas after Canvas2D
      pixiApp.view.style.position = 'absolute';
      pixiApp.view.style.bottom = '0';
      pixiApp.view.style.left = '0';
      pixiApp.view.style.width = '100%';
      pixiApp.view.style.height = '100%';
      pixiApp.view.style.display = 'block';
      pixiApp.view.style.cursor = 'none';
      pixiApp.view.style.touchAction = 'none';
      pixiApp.view.id = 'webgl-canvas';
      
      container.appendChild(pixiApp.view);
      
      console.log('âœ… WebGL Renderer initialized:', pixiApp.renderer.type === PIXI.RENDERER_TYPE.WEBGL ? 'WebGL' : 'Canvas2D Fallback');
      console.log('ğŸ“Š Resolution:', DPR, '| Viewport:', canvas.width, 'x', canvas.height);
      
      return true;
    } catch (error) {
      console.error('âŒ WebGL initialization failed:', error);
      useWebGL = false;
      return false;
    }
  }
  
  function destroyWebGLRenderer() {
    if (pixiApp) {
      // Clear all sprites
      ballSprites.forEach(sprite => sprite.destroy());
      ballSprites.clear();
      
      // Destroy PixiJS app
      pixiApp.destroy(true, { children: true, texture: true, baseTexture: true });
      pixiApp = null;
      
      console.log('ğŸ—‘ï¸ WebGL Renderer destroyed');
    }
  }
  
  function toggleRenderer() {
    useWebGL = !useWebGL;
    
    if (useWebGL) {
      // Switch to WebGL
      canvas.style.display = 'none';
      initWebGLRenderer();
      console.log('ğŸ”„ Switched to WebGL Renderer');
    } else {
      // Switch back to Canvas2D
      destroyWebGLRenderer();
      canvas.style.display = 'block';
      console.log('ğŸ”„ Switched to Canvas2D Renderer');
    }
    
    // Update toggle checkbox if it exists
    const toggle = document.getElementById('useWebGLToggle');
    if (toggle) toggle.checked = useWebGL;
  }
  
  function createBallSprite(ball) {
    if (!pixiApp) return null;
    
    const sprite = new PIXI.Graphics();
    sprite.zIndex = 0;
    sprite._lastRadius = -1;
    sprite._lastColor = '';
    sprite._lastRoundness = -1;
    sprite._lastSquash = -1;
    pixiApp.stage.addChild(sprite);
    ballSprites.set(ball, sprite);
    
    return sprite;
  }
  
  function renderBallWebGL(ball) {
    if (!pixiApp) return;
    
    let sprite = ballSprites.get(ball);
    if (!sprite) {
      sprite = createBallSprite(ball);
      if (!sprite) return;
    }
    
    // Check if visual properties changed (performance optimization)
    const colorNum = parseInt(ball.color.replace('#', ''), 16);
    const currentSquash = ball.squashAmount || 0;
    const needsRedraw = (
      sprite._lastRadius !== ball.r ||
      sprite._lastColor !== ball.color ||
      sprite._lastRoundness !== ballRoundness ||
      Math.abs(sprite._lastSquash - currentSquash) > 0.01
    );
    
    if (needsRedraw) {
      sprite.clear();
      
      // Apply 3D shader system based on ballRoundness
      if (shaderEnabled && ballRoundness > 0) {
        renderBall3DWebGL(sprite, ball.r, colorNum);
      } else {
        // Flat rendering (original)
        sprite.beginFill(colorNum, 1.0);
        sprite.drawCircle(0, 0, ball.r);
        sprite.endFill();
      }
      
      // Cache current values
      sprite._lastRadius = ball.r;
      sprite._lastColor = ball.color;
      sprite._lastRoundness = ballRoundness;
      sprite._lastSquash = currentSquash;
    }
    
    // Always update position (balls are always moving)
    sprite.x = ball.x;
    sprite.y = ball.y;
    
    // Apply squash/stretch if enabled
    if (ball.r > 15 && ball.squashAmount > 0.001) {
      const amt = Math.min(getSquashMax(), Math.max(0, ball.squashAmount));
      const s = 1 + amt;
      const inv = 1 / s;
      
      // Apply transform to sprite
      sprite.rotation = ball.squashNormalAngle;
      sprite.scale.x = s;
      sprite.scale.y = inv;
    } else {
      // Reset transform
      sprite.rotation = ball.omega ? ball.omega * 0.01 : 0;
      sprite.scale.x = 1;
      sprite.scale.y = 1;
    }
  }
  
  function renderBall3DWebGL(sprite, radius, baseColor) {
    // Extract RGB components from hex color
    const r = (baseColor >> 16) & 0xFF;
    const g = (baseColor >> 8) & 0xFF;
    const b = baseColor & 0xFF;
    
    // Convert light angle to radians
    const lightRad = (lightAngle * Math.PI) / 180;
    const lightX = Math.cos(lightRad);
    const lightY = Math.sin(lightRad);
    
    if (ballRoundness <= 50) {
      // Flat to Casino Chip (0-50%)
      renderChipBevelWebGL(sprite, radius, r, g, b, lightX, lightY);
    } else {
      // Casino Chip to Full Sphere (50-100%)
      const sphereBlend = (ballRoundness - 50) / 50; // 0-1
      renderSphereWebGL(sprite, radius, r, g, b, lightX, lightY, sphereBlend);
    }
  }
  
  function renderChipBevelWebGL(sprite, radius, r, g, b, lightX, lightY) {
    // Create casino chip effect with beveled edges
    const bevelWidth = edgeBevelWidth * radius;
    const intensity = ballRoundness / 50; // 0-1 for chip effect
    
    // Adaptive quality: reduce steps for better performance
    const steps = Math.max(4, Math.floor(16 * adaptiveQuality)); // 4-16 steps based on performance
    for (let i = 0; i < steps; i++) {
      const t = i / (steps - 1); // 0 to 1
      const currentRadius = radius * (1 - t * 0.1); // Slightly smaller each step
      
      // Calculate lighting based on position
      let brightness = 1.0;
      if (t > 0.8) {
        // Edge bevel area
        const edgeT = (t - 0.8) / 0.2; // 0-1 in bevel area
        const edgeAngle = Math.atan2(lightY, lightX);
        brightness = 0.6 + 0.4 * Math.cos(edgeAngle) * (1 - edgeT * 0.5);
        brightness *= (1 + intensity * 0.5); // Enhance with roundness
      } else {
        // Center area - flat lighting
        brightness = 0.85 + intensity * 0.15;
      }
      
      // Apply brightness to color
      const finalR = Math.min(255, r * brightness);
      const finalG = Math.min(255, g * brightness);
      const finalB = Math.min(255, b * brightness);
      const color = (finalR << 16) | (finalG << 8) | finalB;
      
      sprite.beginFill(color, 1.0);
      sprite.drawCircle(0, 0, currentRadius);
      sprite.endFill();
    }
  }
  
  function renderSphereWebGL(sprite, radius, r, g, b, lightX, lightY, sphereBlend) {
    // Create full 3D sphere effect
    // Adaptive quality: reduce steps for better performance
    const steps = Math.max(6, Math.floor(24 * adaptiveQuality)); // 6-24 steps based on performance
    
    for (let i = 0; i < steps; i++) {
      const t = i / (steps - 1); // 0 to 1
      const currentRadius = radius * (1 - t * 0.05); // Subtle size variation
      
      // Calculate sphere normal lighting
      const x = (t - 0.5) * 2; // -1 to 1
      const y = 0; // Center slice
      const z = Math.sqrt(Math.max(0, 1 - x*x - y*y)); // Sphere normal Z
      
      // Calculate lighting (Lambertian + specular)
      const dotProduct = (lightX * x + lightY * y + 0.5 * z);
      const diffuse = Math.max(0.2, dotProduct * 0.8 + 0.2);
      
      // Add specular highlight
      const specular = Math.pow(Math.max(0, dotProduct), 16) * specularIntensity * sphereBlend;
      
      let brightness = diffuse + specular;
      brightness = 0.4 + brightness * 0.6; // Clamp to reasonable range
      
      // Apply brightness to color
      const finalR = Math.min(255, r * brightness);
      const finalG = Math.min(255, g * brightness);
      const finalB = Math.min(255, b * brightness);
      const color = (finalR << 16) | (finalG << 8) | finalB;
      
      sprite.beginFill(color, 1.0);
      sprite.drawCircle(0, 0, currentRadius);
      sprite.endFill();
    }
  }
  
  function cleanupRemovedBalls() {
    // Remove sprites for balls that no longer exist
    const ballSet = new Set(balls);
    for (const [ball, sprite] of ballSprites.entries()) {
      if (!ballSet.has(ball)) {
        sprite.destroy();
        ballSprites.delete(ball);
      }
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WEBGL VISUAL EFFECTS (Phase 2.5)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  let boundarySprite = null;
  
  function renderRoundedBoundaryWebGL() {
    if (!pixiApp || cornerRadius <= 0) return;
    
    // Create boundary sprite if it doesn't exist
    if (!boundarySprite) {
      boundarySprite = new PIXI.Graphics();
      boundarySprite.zIndex = -1; // Behind balls
      pixiApp.stage.addChild(boundarySprite);
    }
    
    boundarySprite.clear();
    boundarySprite.lineStyle(2, 0xffffff, 0.1); // White, 10% opacity
    
    const w = canvas.width;
    const h = canvas.height;
    const r = cornerRadius;
    
    // Draw rounded rectangle path
    boundarySprite.moveTo(r, 0);
    boundarySprite.lineTo(w - r, 0);
    boundarySprite.arcTo(w, 0, w, r, r);
    boundarySprite.lineTo(w, h - r);
    boundarySprite.arcTo(w, h, w - r, h, r);
    boundarySprite.lineTo(r, h);
    boundarySprite.arcTo(0, h, 0, h - r, r);
    boundarySprite.lineTo(0, r);
    boundarySprite.arcTo(0, 0, r, 0, r);
    boundarySprite.closePath();
  }
  
  function renderCursorBallWebGL() {
    if (!pixiApp || !cursorBallVisible) return;
    
    // Create cursor ball sprite if needed
    if (!cursorBallSprite) {
      cursorBallSprite = new PIXI.Graphics();
      cursorBallSprite.zIndex = 1000; // On top of everything
      pixiApp.stage.addChild(cursorBallSprite);
    }
    
    cursorBallSprite.clear();
    
    // Convert cursor ball color
    const colorNum = parseInt(cursorBallColor.replace('#', ''), 16);
    
    // Apply same shader system as regular balls
    if (shaderEnabled && ballRoundness > 0) {
      renderBall3DWebGL(cursorBallSprite, cursorBallRadius, colorNum);
    } else {
      cursorBallSprite.beginFill(colorNum, 0.8); // Slightly transparent
      cursorBallSprite.drawCircle(0, 0, cursorBallRadius);
      cursorBallSprite.endFill();
    }
    
    // Update position
    cursorBallSprite.x = mouseX;
    cursorBallSprite.y = mouseY;
  }
  
  function renderModeIndicatorWebGL() {
    if (!pixiApp || isTouchDevice) return;
    
    // Create mode indicator sprite if needed
    if (!modeIndicatorSprite) {
      modeIndicatorSprite = new PIXI.Text('', {
        fontFamily: 'system-ui, -apple-system, sans-serif',
        fontSize: 14,
        fill: 0xffffff,
        alpha: 0.3
      });
      modeIndicatorSprite.zIndex = 999;
      modeIndicatorSprite.x = 10;
      modeIndicatorSprite.y = canvas.height - 30;
      pixiApp.stage.addChild(modeIndicatorSprite);
    }
    
    // Update text
    const modeName = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
    modeIndicatorSprite.text = modeName + ' Mode';
    modeIndicatorSprite.y = canvas.height - 30; // Update position for canvas resize
  }
  
  let cursorBallSprite = null;
  let modeIndicatorSprite = null;
  
  // Performance monitoring for adaptive quality
  let frameCount = 0;
  let lastFPSCheck = 0;
  let currentFPS = 60;
  let adaptiveQuality = 1.0; // 1.0 = full quality, 0.5 = half quality
  
  function updateAdaptiveQuality() {
    frameCount++;
    const now = performance.now();
    
    if (now - lastFPSCheck >= 1000) { // Check every second
      currentFPS = frameCount;
      frameCount = 0;
      lastFPSCheck = now;
      
      // Adaptive quality based on FPS
      if (currentFPS < 45) {
        adaptiveQuality = Math.max(0.3, adaptiveQuality - 0.1); // Reduce quality
      } else if (currentFPS > 55) {
        adaptiveQuality = Math.min(1.0, adaptiveQuality + 0.05); // Increase quality
      }
      
      console.log(`ğŸ® WebGL FPS: ${currentFPS}, Quality: ${(adaptiveQuality * 100).toFixed(0)}%`);
    }
  }
  
  // Note: Mouse, cursor, device, and mode variables are defined elsewhere in the file

  // Spawn area controls (viewport-relative)
  // Defaults: xCenter = 50vw, y = -50vh, width = 100vw, height = 50vh
  let SPAWN_X_CENTER_VW = 50;
  let SPAWN_Y_VH = -50;
  let SPAWN_W_VW = 100;
  let SPAWN_H_VH = 50;

  // Resize canvas based on current mode
  function resize() {
    // Ball Pit mode uses 150vh (spawning above viewport), others use 100vh
    const heightMultiplier = (currentMode === MODES.PIT) 
      ? CONSTANTS.CANVAS_HEIGHT_VH_PIT 
      : CONSTANTS.CANVAS_HEIGHT_VH_DEFAULT;
    const simHeight = window.innerHeight * heightMultiplier;
    canvas.width  = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(simHeight * DPR);
  }
  const setCSSSize = () => {
    // CSS size is handled by CSS classes (mode-pit gets 150vh, others 100svh)
  };
  
  // Debounced resize handler to prevent expensive operations on every pixel change
  let resizeTimeout;
  function handleResize() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(() => {
      setCSSSize();
      resize();
      updateEffectiveScaleAndBallSizes();
      updateTextColliders();
    }, 150); // 150ms debounce
  }
  
  setCSSSize(); resize();
  window.addEventListener('resize', handleResize);

  // Physics parameters (initial)
  const GE = 1960;        // Earth gravity in px/s^2 at our scale
  let gravityMultiplier = 1.10; // 1.1Ã— Earth
  let G = GE * gravityMultiplier;
  let REST = 0.80;        // restitution (rubber balls: 0.75-0.85, more realistic than 0.88)
  let FRICTION = 0.0045;  // air drag (increased for realistic weight feel)
  let EMIT_INTERVAL = 0.030; // seconds between drops - from screenshot
  let MAX_BALLS = 150;    // Optimized for 90+ FPS performance (was 800)
  const SOLVER_ITERS = 6;    // Optimized for realistic collisions without jitter
  const POS_CORRECT_PERCENT = 0.8; // Reduced for more stable contacts
  const POS_CORRECT_SLOP = 0.5 * DPR; // Slightly more tolerance to prevent jitter
  const REST_VEL_THRESHOLD = 30; // Lower threshold for more realistic settling

  // Base radius values
  const R_MIN_BASE = 6;
  const R_MAX_BASE = 24;
  let sizeScale = 0.7;     // Global ball size (LOCKED - never override in modes)
  let sizeVariation = 1.0; // Global size variation
  // Responsive scale: reduce ball size by 60% on mobile breakpoints (â‰¤768px)
  let responsiveScale = 1.0;
  let lastEffectiveScale = null; // tracks previous (sizeScale * responsiveScale)
  // Global mass model: all balls share the same mass in kg
  // REALISTIC MASS: Rubber bouncy balls are 100-150g (not 19.8g)
  let ballMassKg = 120.0; // 120g rubber ball (realistic weight)
  // Mass influence tuning
  const MASS_GRAVITY_EXP = 0.35; // how much mass influences gravity (perceptual)
  const MASS_REST_EXP = 0.15;    // how much mass influences bounce restitution
  let gravityScale = 1.0;        // computed from mass
  function recomputeMassDerivedScales() {
    gravityScale = Math.max(0.5, Math.min(3.0, Math.pow(ballMassKg / MASS_BASELINE_KG, MASS_GRAVITY_EXP)));
  }
  recomputeMassDerivedScales();
  let R_MIN = R_MIN_BASE * sizeScale;
  let R_MAX = R_MAX_BASE * sizeScale;

  function computeResponsiveScale() {
    // Use canvas container width for proper embed behavior
    const containerWidth = canvas.clientWidth || window.innerWidth;
    return (containerWidth <= 768) ? 0.4 : 1.0;
  }

  // Recomputes the effective pixel radius from global size and responsiveness,
  // then proportionally rescales existing balls so the scene updates smoothly.
  function updateEffectiveScaleAndBallSizes() {
    responsiveScale = computeResponsiveScale();
    const effectiveScale = sizeScale * responsiveScale;
    if (lastEffectiveScale === null) {
      lastEffectiveScale = effectiveScale;
      R_MIN = R_MIN_BASE * effectiveScale;
      R_MAX = R_MAX_BASE * effectiveScale;
      return;
    }
    const ratio = effectiveScale / lastEffectiveScale;
    if (ratio !== 1) {
      for (let i = 0; i < balls.length; i++) {
        balls[i].r *= ratio;
      }
      lastEffectiveScale = effectiveScale;
    }
    R_MIN = R_MIN_BASE * effectiveScale;
    R_MAX = R_MAX_BASE * effectiveScale;
  }

  // Update text collision rectangles by measuring DOM elements
  function updateTextColliders() {
    textColliders = []; // Clear existing colliders
    
    const textElement = document.querySelector(TEXT_SELECTOR);
    if (!textElement) return; // No text element found
    
    const textRect = textElement.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    
    // Calculate cap height (height of capital letters only)
    const capHeight = calculateCapHeight(textElement);
    
    // Center the collision box vertically on the visual text
    const heightDifference = textRect.height - capHeight;
    const verticalOffset = heightDifference * 0.5; // Center the cap height within the full text height
    
    // Convert to canvas coordinates with device pixel ratio
    const collider = {
      x: (textRect.left - canvasRect.left) * DPR,
      y: (textRect.top - canvasRect.top + verticalOffset) * DPR,
      width: textRect.width * DPR,
      height: capHeight * DPR
    };
    
    // Only add collider if it's within canvas bounds and has valid dimensions
    if (collider.width > 0 && collider.height > 0 && 
        collider.x < canvas.width && collider.y < canvas.height &&
        collider.x + collider.width > 0 && collider.y + collider.height > 0) {
      textColliders.push(collider);
    }
  }
  
  // Calculate the cap height of text element (height of capital letters)
  function calculateCapHeight(element) {
    // Create a temporary element with just capital letters to measure cap height
    const tempElement = document.createElement('span');
    tempElement.style.cssText = window.getComputedStyle(element).cssText;
    tempElement.style.position = 'absolute';
    tempElement.style.visibility = 'hidden';
    tempElement.style.whiteSpace = 'nowrap';
    tempElement.textContent = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    
    document.body.appendChild(tempElement);
    const capHeight = tempElement.getBoundingClientRect().height;
    document.body.removeChild(tempElement);
    
    return capHeight;
  }

  // Emitter sweep (natural hand-like motion across the top band)
  let EMITTER_SWEEP_ENABLED = true;
  let emitterPhase = 0;                 // radians
  const EMITTER_SWEEP_HZ = 0.12;        // cycles per second
  const EMITTER_SWEEP_AMPL_VW = 20;     // sweep amplitude in vw
  let emitterSweepDir = 1;              // +1 sweeping right, -1 sweeping left (derived)

  // 8-Color system with weighted distribution (50%, 25%, 12%, 6%, 3%, 2%, 1%, 1%)
  // Color 1 (50%): Dominant/background color
  // Color 2 (25%): Secondary color  
  // Color 3 (15%): Tertiary color
  // Color 4 (7.5%): Accent color
  // Color 5 (2.5%): Rare/special color
  const COLOR_TEMPLATES = {
    // CORE PALETTE - User's favorite (don't change)
    industrialTeal: { label: 'Industrial Teal', colors: ['#b7bcb7', '#e4e9e4', '#ffffff', '#00695c', '#000000', '#ff4013', '#0d5cb6', '#ffa000'] },
    
    // NEW PALETTES - Designed to match Industrial Teal's playful graphic design energy
    // Each has: neutral grays + bold hero color + high contrast + 3 vibrant accents
    
    sunsetCoral: { 
      label: 'Sunset Coral', 
      colors: ['#b8b5b1', '#e5e3df', '#ffffff', '#ff6b6b', '#000000', '#00d4aa', '#2563eb', '#f59e0b'] 
      // Hero: Coral (warm, friendly, energetic) + Teal, Blue, Amber accents
      // Psychology: Optimistic, approachable, creative confidence
    },
    
    violetPunch: { 
      label: 'Violet Punch', 
      colors: ['#b5b4bd', '#e3e2e9', '#ffffff', '#8b5cf6', '#000000', '#ef4444', '#06b6d4', '#fbbf24'] 
      // Hero: Purple (creative, imaginative, bold) + Red, Cyan, Yellow accents
      // Psychology: Innovative, playful sophistication, design-forward
    },
    
    citrusBlast: { 
      label: 'Citrus Blast', 
      colors: ['#b9b7b0', '#e6e4dd', '#ffffff', '#f59e0b', '#000000', '#ec4899', '#3b82f6', '#10b981'] 
      // Hero: Orange (energetic, enthusiastic, fun) + Pink, Blue, Green accents
      // Psychology: Cheerful, dynamic, youthful energy
    },
    
    cobaltSpark: { 
      label: 'Cobalt Spark', 
      colors: ['#b3b6bc', '#e1e4e9', '#ffffff', '#2563eb', '#000000', '#f97316', '#ec4899', '#eab308'] 
      // Hero: Cobalt Blue (confident, intelligent, trustworthy) + Orange, Pink, Yellow accents
      // Psychology: Professional playfulness, sharp and smart
    }
  };

  let currentTemplate = 'industrialTeal';
  let currentColors = COLOR_TEMPLATES.industrialTeal.colors.slice(); // 8 colors
  // Cursor color: default to Color 6 (highlight)
  let cursorBallIndex = 5;
  let cursorBallColor = currentColors[cursorBallIndex] || '#ff4013';

  // Expose palette as CSS variables for use by page elements
  function syncPaletteVars(colors = currentColors) {
    try {
      const root = document.documentElement;
      const list = (colors && colors.length ? colors : currentColors).slice(0, 8);
      for (let i = 0; i < 8; i++) {
        const hex = list[i] || '#ffffff';
        root.style.setProperty(`--ball-${i+1}`, hex);
      }
    } catch (_) { /* no-op */ }
  }

  // Color weights: Color 1: 50%, Color 2: 25%, Color 3: 15%, Color 4: 7.5%, Color 5: 2.5%
  const COLOR_WEIGHTS = [0.50, 0.25, 0.12, 0.06, 0.03, 0.02, 0.01, 0.01];
  
  function pickRandomColor() {
    try {
      if (!currentColors || currentColors.length === 0) {
        console.warn('No colors available, using fallback');
        return '#ffffff'; // Fallback color
      }
      
      // Use weighted random selection
      const random = Math.random();
      let cumulativeWeight = 0;
      
      for (let i = 0; i < Math.min(currentColors.length, COLOR_WEIGHTS.length); i++) {
        cumulativeWeight += COLOR_WEIGHTS[i];
        if (random <= cumulativeWeight) {
          return currentColors[i];
        }
      }
      
      // Fallback to last color if something goes wrong
      return currentColors[Math.min(currentColors.length - 1, 7)];
    } catch (error) {
      console.error('Error picking random color:', error);
      return '#ffffff'; // Fallback color
    }
  }

  // Repeller controls
  let repelRadius = 135;   // px (CSS px) - from screenshot
  let repelPower = 1536000;  // from screenshot (mapped display value)
  let repelSoft = 3.4;     // exponent falloff - from screenshot
  let mouseX = CONSTANTS.OFFSCREEN_MOUSE, mouseY = CONSTANTS.OFFSCREEN_MOUSE; // offscreen until moved
  let repellerEnabled = false; // disabled by default; enabled by preset or sliders
  const REPELLER_GLOBAL_MULTIPLIER = 20.0; // doubled overall repeller strength
  
  // Touch detection - cursor ball only shows on non-touch devices
  let isTouchDevice = false;
  // Check for touch support
  if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
    isTouchDevice = true;
  }
  
  // Hide modes that aren't available on this device
  // All 3 modes are available on all devices
  function applyDeviceSpecificModeVisibility() {
    // No device-specific mode hiding needed
  }
  
  // Settings persistence using localStorage
  const STORAGE_KEY = 'bouncyBallsSettings';
  
  // Persist current UI/simulation settings to localStorage so user preferences
  // survive reloads. Uses a compact single object for easy versioning.
  function saveSettings() {
    const settings = {
      currentMode,
      gravityMultiplierPit,
      repellerEnabledPit,
      attractionPower,
      orbitRadius,
      swarmSpeed,
      weightlessInitialSpeed,
      weightlessBounce,
      weightlessMaxBalls,
      weightlessRepellerPower,
      weightlessRepellerRadius,
      restitution: REST,
      friction: FRICTION,
      sizeScale,
      sizeVariation,
      ballMassKg,
      ballSoftness,
      repelPower,
      repelRadius,
      repelSoft,
      cornerRadius,
      motionBlur: trailFade,
      trailSubtlety,
      currentTemplate,
      cursorBallColor
    };
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      console.log('âœ“ Settings saved');
    } catch (e) {
      console.warn('Could not save settings:', e);
    }
  }
  
  // Load settings from localStorage and safely apply them. Each field is
  // guarded to avoid clobbering defaults if a key is missing or old.
  function loadSettings() {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const settings = JSON.parse(saved);
        // Restore all settings
        if (settings.currentMode) currentMode = settings.currentMode;
        if (settings.gravityMultiplierPit !== undefined) gravityMultiplierPit = settings.gravityMultiplierPit;
        if (settings.repellerEnabledPit !== undefined) repellerEnabledPit = settings.repellerEnabledPit;
        if (settings.attractionPower) attractionPower = settings.attractionPower;
        if (settings.orbitRadius) orbitRadius = settings.orbitRadius;
        if (settings.swarmSpeed) swarmSpeed = settings.swarmSpeed;
        if (settings.weightlessInitialSpeed) weightlessInitialSpeed = settings.weightlessInitialSpeed;
        if (settings.weightlessBounce) weightlessBounce = settings.weightlessBounce;
        if (settings.weightlessMaxBalls) weightlessMaxBalls = settings.weightlessMaxBalls;
        if (settings.weightlessRepellerPower !== undefined) weightlessRepellerPower = settings.weightlessRepellerPower;
        if (settings.weightlessRepellerRadius !== undefined) weightlessRepellerRadius = settings.weightlessRepellerRadius;
        if (settings.restitution) REST = settings.restitution;
        if (settings.friction !== undefined) FRICTION = settings.friction;
        if (settings.sizeScale) sizeScale = settings.sizeScale;
        if (settings.sizeVariation !== undefined) sizeVariation = settings.sizeVariation;
        if (settings.ballMassKg) ballMassKg = settings.ballMassKg;
        if (settings.repelPower) repelPower = settings.repelPower;
        if (settings.repelRadius) repelRadius = settings.repelRadius;
        if (settings.repelSoft) repelSoft = settings.repelSoft;
        if (settings.cornerRadius !== undefined) cornerRadius = settings.cornerRadius;
        if (settings.motionBlur !== undefined) trailFade = settings.motionBlur;
        if (settings.trailSubtlety) trailSubtlety = settings.trailSubtlety;
        if (settings.currentTemplate) currentTemplate = settings.currentTemplate;
        if (settings.cursorBallColor) cursorBallColor = settings.cursorBallColor;
        
        console.log('âœ“ Settings loaded');
        return true;
      }
    } catch (e) {
      console.warn('Could not load settings:', e);
    }
    return false;
  }
  
  // Auto-save settings when sliders change
  function autoSaveSettings() {
    // Debounced save (wait 500ms after last change)
    clearTimeout(window.settingsSaveTimeout);
    window.settingsSaveTimeout = setTimeout(saveSettings, 500);
  }

  // Repeller slider mapping (wide dynamic range; midpoint equals 2Ã— previous default)
  const REPEL_BASE_POWER = 12000; // previous default baseline
  const REPEL_SLIDER_MAX = 10000;  // slider range [0..10000]
  const REPEL_CENTER_MULTIPLIER = 2.0; // midpoint = 2Ã— base
  const REPEL_N_OCTAVES = 12; // wide range (~1/32x .. 128x around center)
  function repelSliderToPower(sliderValue) {
    const s = Math.max(0, Math.min(REPEL_SLIDER_MAX, Number(sliderValue))) / REPEL_SLIDER_MAX;
    const mult = REPEL_CENTER_MULTIPLIER * Math.pow(2, (s - 0.5) * REPEL_N_OCTAVES);
    return REPEL_BASE_POWER * mult;
  }
  function powerToRepelSlider(power) {
    const safe = Math.max(1, Number(power));
    const x = safe / (REPEL_BASE_POWER * REPEL_CENTER_MULTIPLIER);
    const s = 0.5 + (Math.log2(x) / REPEL_N_OCTAVES);
    return Math.round(Math.max(0, Math.min(1, s)) * REPEL_SLIDER_MAX);
  }

  // Shadows removed for better performance and realism
  
  // High refresh mode is now default
  let highRefreshMode = true; // Always enabled for best performance
  
  // Rounded corners for simulation area
  let cornerRadius = 0; // Corner radius in pixels (0 = square corners)
  
  // Text collision system
  const TEXT_SELECTOR = '#hero-text'; // ID selector for the main text element
  let textColliders = []; // Array of text collision rectangles
  // Motion blur parameters
  let motionBlurFade = 0.025; // from screenshot (was trailFade)
  let trailSubtlety = 1.80; // from screenshot
  
  // Performance optimizations and FPS tracking
  let renderFrameCount = 0;
  let physicsStepCount = 0;
  let lastFPSTime = 0;
  let currentRenderFPS = 0;
  let currentPhysicsFPS = 0;
  const renderFpsElement = document.getElementById('render-fps');
  const physicsFpsElement = document.getElementById('physics-fps');
  
  // Adaptive Quality System - automatically adjusts settings based on FPS
  let adaptiveQualityEnabled = true;     // Enable/disable adaptive quality
  let currentCollisionIters = 2;         // Dynamic collision iterations (1-3)
  let lastQualityCheck = 0;              // Last time quality was adjusted
  const QUALITY_CHECK_INTERVAL = 2.0;    // Check every 2 seconds
  
  function updateAdaptiveQuality(now) {
    if (!adaptiveQualityEnabled) return;
    if (now - lastQualityCheck < QUALITY_CHECK_INTERVAL) return;
    
    lastQualityCheck = now;
    
    // Adjust collision iterations based on FPS
    if (currentRenderFPS < 50) {
      // Critical: reduce to 1 iteration
      currentCollisionIters = 1;
      console.log('âš¡ Adaptive Quality: LOW (1 collision iter) - FPS:', currentRenderFPS);
    } else if (currentRenderFPS < 70) {
      // Medium: keep at 2 iterations
      currentCollisionIters = 2;
      console.log('âš¡ Adaptive Quality: MEDIUM (2 collision iters) - FPS:', currentRenderFPS);
    } else {
      // High: can afford 3 iterations
      currentCollisionIters = 3;
      console.log('âš¡ Adaptive Quality: HIGH (3 collision iters) - FPS:', currentRenderFPS);
    }
  }
  
  // Shadow system removed for better performance

  // Ball model - updated to remove 3D rendering
  class Ball {
    constructor(x, y, r, color) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random()*2 - 1) * 200; // random lateral kick
      this.vy = -Math.random()*200;          // slight upward variation
      this.r = r;
      this.rBase = r;                         // Store original radius for scaling
      this.m = ballMassKg;                    // all balls share the same mass
      this.color = color;
      this.t = 0;
      // Entry drift state for natural side-throw effect
      this.age = 0;           // seconds since spawn
      this.driftAx = 0;       // lateral acceleration during entry (px/s^2)
      this.driftTime = 0;     // duration of entry drift (s)
      // Spin & squash state
      this.omega = 0;         // angular velocity (rad/s)
      this.squash = 1.0;      // visual squash factor (1 = round)
      this.squashDirX = 1;    // squash direction components (unit vector)
      this.squashDirY = 0;
      // Improved rotation & world-aligned squash
      this.theta = 0;               // integrated angular position (rad)
      this.squashAmount = 0.0;      // 0 = no squash, up to SQUASH_MAX
      this.squashNormalAngle = 0.0; // world-space normal direction for squash
      // Trail mode alpha transparency
      this.alpha = 1.0;       // 1 = opaque, 0 = transparent
    }
    // Integrate motion with simple Euler step
    step(dt) {
      // Advance timers
        this.t += dt;
      this.age += dt;

      // Gravity scaled by mass to make weight perceptible without changing G globally
      // BUT: Zero-G mode has NO gravity or drag (space physics)
      if (currentMode !== MODES.WEIGHTLESS) {
      this.vy += (G * gravityScale) * dt;
      }
      
      // Mass-aware drag (heavier balls lose proportionally less velocity)
      // BUT: Zero-G mode has MINIMAL drag (vacuum of space)
      const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
      const dragAmount = (currentMode === MODES.WEIGHTLESS) ? 0.0001 : FRICTION; // Almost zero in zero-g
      const drag = Math.max(0, 1 - (dragAmount / massScale));
      this.vx *= drag;
      this.vy *= drag;
      // Apply short-lived lateral drift to simulate being thrown from the side above
      if (this.driftAx !== 0 && this.age < this.driftTime) {
        this.vx += (this.driftAx * dt) / massScale;
      } else if (this.driftAx !== 0) {
        this.driftAx = 0; // Clear drift when expired to skip future checks
      }
      applyExternalForces(this, dt);
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      // Angular damping
      const spinDamp = Math.max(0, 1 - CONSTANTS.SPIN_DAMP_PER_S * dt);
      this.omega *= spinDamp;
      // Integrate angular position for visible rotation
      this.theta += this.omega * dt;
      if (this.theta > Math.PI) this.theta -= Math.PI * 2; else if (this.theta < -Math.PI) this.theta += Math.PI * 2;
      // Relax squash amount back to 0 (area-preserving)
      const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
      this.squashAmount += (0 - this.squashAmount) * decay;
      this.squash = 1 - this.squashAmount;
    }
    // Resolve collision with walls (with rounded corners)
    walls(w, h, dt, customRest = REST) {
      // Use custom restitution if provided (for mode-specific bounce behavior)
      const rest = customRest;
      if (cornerRadius === 0) {
        // Standard rectangular collision
      if (this.y + this.r > h) { 
        this.y = h - this.r; 
        // Pre-impact speed for squash amplitude
        const preVy = this.vy;
        // Rolling friction & spin from tangential slip
        const slip = this.vx - this.omega * this.r; // world x is tangential at bottom contact
        const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
        // convert part of slip to spin, reduce horizontal speed (rolling tendency)
        this.omega += (slip / this.r) * CONSTANTS.SPIN_GAIN / massScale;
        const rollDamp = Math.max(0, 1 - CONSTANTS.ROLL_FRICTION_PER_S * dt / massScale);
        this.vx *= rollDamp;
        // Bounce with mass-aware restitution
        const wallRest = Math.abs(preVy) < CONSTANTS.WALL_REST_VEL_THRESHOLD ? 0 : rest;
        this.vy = -this.vy * (wallRest * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash on impact using pre-impact speed
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = -Math.PI / 2; // ground normal upwards
        // Ground coupling: tend towards pure rolling without slipping
        const rollTarget = this.vx / this.r;
        this.omega += (rollTarget - this.omega) * Math.min(1, CONSTANTS.GROUND_COUPLING_PER_S * dt);
      }
      // Top wall collision aligned to the visible viewport top
      // Ball Pit: 150vh canvas, so viewport top is at h/3
      // Other modes: 100vh canvas, so viewport top is at 0
      const viewportTop = (currentMode === MODES.PIT) ? (h / 3) : 0;
      if (this.y - this.r < viewportTop) { 
        this.y = viewportTop + this.r; 
        const preVy = this.vy;
        this.vy = -this.vy * rest; 
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI / 2; // ceiling normal downwards
      }
      if (this.x + this.r > w) { 
        this.x = w - this.r; 
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * rest; 
        const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // right wall normal leftwards
      }
        if (this.x - this.r < 0) { 
          this.x = this.r; 
          {
            const slip = this.vy - this.omega * this.r;
            const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
            this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
          }
          this.vx = -this.vx * rest; 
          const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
          this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
          this.squash = 1 - this.squashAmount;
          this.squashNormalAngle = 0; // left wall normal rightwards
        }
      } else {
        // Rounded corner collision detection
        this.handleRoundedWallCollision(w, h);
      }
      
      // Text collision detection
      this.checkTextCollisions(dt);
    }
    
    // Check collision with text elements
    checkTextCollisions(dt) {
      for (let i = 0; i < textColliders.length; i++) {
        const rect = textColliders[i];
        
        // Check if ball overlaps with text rectangle
        const closestX = Math.max(rect.x, Math.min(this.x, rect.x + rect.width));
        const closestY = Math.max(rect.y, Math.min(this.y, rect.y + rect.height));
        
        const dx = this.x - closestX;
        const dy = this.y - closestY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < this.r) {
          // Collision detected - resolve it
          if (distance === 0) {
            // Ball center is inside rectangle - push out in shortest direction
            const distToLeft = this.x - rect.x;
            const distToRight = (rect.x + rect.width) - this.x;
            const distToTop = this.y - rect.y;
            const distToBottom = (rect.y + rect.height) - this.y;
            
            const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
            
            if (minDist === distToLeft) {
              this.x = rect.x - this.r;
              this.vx = -Math.abs(this.vx) * REST;
            } else if (minDist === distToRight) {
              this.x = rect.x + rect.width + this.r;
              this.vx = Math.abs(this.vx) * REST;
            } else if (minDist === distToTop) {
              this.y = rect.y - this.r;
              this.vy = -Math.abs(this.vy) * REST;
            } else {
              this.y = rect.y + rect.height + this.r;
              this.vy = Math.abs(this.vy) * REST;
            }
          } else {
            // Normal collision resolution
            const overlap = this.r - distance;
            const nx = dx / distance;
            const ny = dy / distance;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity with restitution
            const dotProduct = this.vx * nx + this.vy * ny;
            if (dotProduct < 0) {
              this.vx -= 2 * dotProduct * nx * REST;
              this.vy -= 2 * dotProduct * ny * REST;
              
              // Add squash effect for visual impact
              const impact = Math.min(1, Math.abs(dotProduct) / (this.r * 70));
              this.squash = 1 - getSquashMax() * impact;
              this.squashDirX = Math.abs(nx) > Math.abs(ny) ? 1 : 0;
              this.squashDirY = Math.abs(ny) > Math.abs(nx) ? 1 : 0;
            }
          }
        }
      }
    }
    
    // Handle collision with rounded corner boundaries
    handleRoundedWallCollision(w, h) {
      const r = cornerRadius;
      
      // Check collision with each corner circle
      const corners = [
        { x: r, y: r },           // Top-left
        { x: w - r, y: r },       // Top-right
        { x: w - r, y: h - r },   // Bottom-right
        { x: r, y: h - r }        // Bottom-left
      ];
      
      for (let i = 0; i < corners.length; i++) {
        const corner = corners[i];
        const dx = this.x - corner.x;
        const dy = this.y - corner.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Check if ball is in corner region and colliding with corner circle
        const inCornerRegion = this.isInCornerRegion(corner, w, h, r);
        if (inCornerRegion && dist + this.r > r) {
          // Collision with corner circle
          const overlap = r - (dist - this.r);
          if (overlap > 0 && dist > 0) {
            const nx = dx / dist;
            const ny = dy / dist;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity
            const dot = this.vx * nx + this.vy * ny;
            this.vx -= 2 * dot * nx * REST;
            this.vy -= 2 * dot * ny * REST;
            // Squash aligned to corner normal, proportional to impact
            const impact = Math.min(1, Math.abs(dot) / (this.r * 90));
            this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
            this.squash = 1 - this.squashAmount;
            this.squashNormalAngle = Math.atan2(ny, nx);
          }
        }
      }
      
      // Handle straight wall collisions (outside corner regions)
      // Bottom wall
      if (this.y + this.r > h && (this.x < r || this.x > w - r)) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      
      // Top wall
      if (this.y - this.r < 0 && (this.x < r || this.x > w - r)) {
        this.y = this.r;
        this.vy = -this.vy * REST;
      }
      
      // Right wall
      if (this.x + this.r > w && (this.y < r || this.y > h - r)) {
        this.x = w - this.r;
        // Wall contact: add spin from tangential slip (vertical normal)
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash aligned to wall normal
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(getSquashMax(), impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // normal leftwards
      }
      
      // Left wall
      if (this.x - this.r < 0 && (this.y < r || this.y > h - r)) {
        this.x = this.r;
        {
          const slip = this.vy - this.omega * this.r;
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(getSquashMax(), impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = 0; // normal rightwards
      }
      
      // Handle straight sections of walls
      if (this.y + this.r > h && this.x >= r && this.x <= w - r) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.y - this.r < 0 && this.x >= r && this.x <= w - r) {
        this.y = this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x + this.r > w && this.y >= r && this.y <= h - r) {
        this.x = w - this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x - this.r < 0 && this.y >= r && this.y <= h - r) {
        this.x = this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
    }
    
    // Check if ball is in a corner region
    isInCornerRegion(corner, w, h, r) {
      // Top-left corner
      if (corner.x === r && corner.y === r) {
        return this.x <= r && this.y <= r;
      }
      // Top-right corner
      if (corner.x === w - r && corner.y === r) {
        return this.x >= w - r && this.y <= r;
      }
      // Bottom-right corner
      if (corner.x === w - r && corner.y === h - r) {
        return this.x >= w - r && this.y >= h - r;
      }
      // Bottom-left corner
      if (corner.x === r && corner.y === h - r) {
        return this.x <= r && this.y >= h - r;
      }
      return false;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);

      // World-aligned squash/stretch only for larger balls (performance optimization)
      // Small balls (<15px radius) don't show visible squash, so skip expensive transforms
      const amt = Math.min(getSquashMax(), Math.max(0, this.squashAmount));
      if (this.r > 15 && amt > 0.001) {
        // Area-preserving squash: s * (1/s) maintains roundness perception
        const s = 1 + amt;
        const inv = 1 / s;
        ctx.rotate(this.squashNormalAngle);
        ctx.scale(s, inv);
        ctx.rotate(-this.squashNormalAngle);
      }
      
      // Body rendering
      ctx.beginPath();
      ctx.arc(0, 0, this.r, 0, Math.PI*2);
      ctx.fillStyle = this.color;
      ctx.fill();

      ctx.restore();
    }
  }

  const balls = [];

  // Helpers
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function randBetween(a, b) { return a + Math.random() * (b - a); }
  // Compute mass from radius using current weight slider as density baseline
  // Removed radius-based mass; shared mass is used instead
  
  // Draw rounded boundary visualization
  function drawRoundedBoundary(ctx, w, h) {
    const r = cornerRadius;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    // Start from top-left corner (after the curve)
    ctx.moveTo(r, 0);
    
    // Top edge
    ctx.lineTo(w - r, 0);
    
    // Top-right corner
    ctx.arcTo(w, 0, w, r, r);
    
    // Right edge
    ctx.lineTo(w, h - r);
    
    // Bottom-right corner
    ctx.arcTo(w, h, w - r, h, r);
    
    // Bottom edge
    ctx.lineTo(r, h);
    
    // Bottom-left corner
    ctx.arcTo(0, h, 0, h - r, r);
    
    // Left edge
    ctx.lineTo(0, r);
    
    // Top-left corner
    ctx.arcTo(0, 0, r, 0, r);
    
    ctx.closePath();
    ctx.stroke();
  }
  
  function spawnBall(x, y, color = pickRandomColor()) {
    // Calculate size range with variation (ensure positive values)
    const baseSize = (R_MIN + R_MAX) / 2;
    
    let r;
    if (sizeVariation === 0) {
      // No variation: all balls exactly the same size
      r = baseSize;
    } else {
      // Apply limited variation (max 10% from global ball size)
      const maxVariation = baseSize * 0.1; // 10% of global ball size
      const minR = Math.max(1, baseSize - maxVariation);
      const maxR = baseSize + maxVariation;
      r = randBetween(minR, maxR);
    }
    
    const ball = new Ball(x, y, r, color);

    // Natural entry throw with size-aware impulse and sweep-aware direction
    const centerX = canvas.width * 0.5;
    // Prefer current sweep direction if enabled; otherwise side-based
    const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((x < centerX) ? 1 : -1);
    const sizeInfluence = clamp((r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
    const baseKick = 140 * sizeInfluence;  // scale with size
    const randKick = 180 * sizeInfluence;  // scale with size
    const upwardKick = 120;                // small upward speed to soften entry
    ball.vx = dir * (baseKick + Math.random() * randKick);
    ball.vy = -Math.random() * upwardKick;

    // Short lived lateral acceleration to feel like being pushed from the side (size-aware)
    ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence; // px/s^2
    ball.driftTime = 0.22 + Math.random() * 0.28;                    // 0.22â€“0.5s of drift

    balls.push(ball);
    return ball;
  }
  

  // Continuous emitter within a vw/vh-defined rectangle
  let emitterTimer = 0;
  function pickSpawnPoint() {
    const wCss = canvas.clientWidth;
    const hCss = canvas.clientHeight;
    const widthCss = clamp((SPAWN_W_VW / 100) * wCss, 0, wCss);
    let xCenterCss = clamp((SPAWN_X_CENTER_VW / 100) * wCss, 0, wCss);
    // Apply sweeping emitter motion across the band for natural hand-like movement
    if (EMITTER_SWEEP_ENABLED) {
      const amplPx = (EMITTER_SWEEP_AMPL_VW / 100) * wCss;
      const sweepOffset = Math.sin(emitterPhase) * amplPx;
      const prevX = xCenterCss;
      xCenterCss = clamp(xCenterCss + sweepOffset, 0, wCss);
      emitterSweepDir = (xCenterCss >= prevX) ? 1 : -1;
    }
    // Allow slight offscreen horizontal spawn for natural side entry feel
    const offX = Math.min(40, widthCss * 0.1); // up to 40px or 10% width
    const xLeftCss = clamp(xCenterCss - widthCss / 2 - offX, -offX, wCss);
    const xRightCss = clamp(xCenterCss + widthCss / 2 + offX, -offX, wCss);
    const yTopCss = (SPAWN_Y_VH / 100) * hCss;
    const yBotCss = yTopCss + (SPAWN_H_VH / 100) * hCss;
    // Slight bias along sweep direction to emit closer to the leading edge
    const bias = 0.3; // 0 = uniform, 1 = fully biased to leading edge
    const u = Math.random();
    const biased = bias > 0 ? (emitterSweepDir > 0 ? Math.pow(u, 1 - bias) : 1 - Math.pow(1 - u, 1 - bias)) : u;
    const x = (xLeftCss + (xRightCss - xLeftCss) * biased) * DPR;
    // Add slight upward randomness to spawn height for organic feel
    const y = randBetween(yTopCss * DPR, yBotCss * DPR) - (R_MAX + CONSTANTS.BALL_SPAWN_OFFSET + randBetween(0, 10 * DPR));
    return { x, y };
  }
  
  function emit(dt) {
    // Zero-G mode: no continuous spawning, balls are distributed at initialization
    if (currentMode === MODES.WEIGHTLESS) {
      return;
    }
    
    // Ball Pit & Flies modes: standard top emitter
    emitterTimer += dt;
    while (emitterTimer >= EMIT_INTERVAL) {
      // Jitter emissions slightly for organic timing
      const jitter = (Math.random() - 0.5) * EMIT_INTERVAL * 0.5; // Â±25%
      emitterTimer -= (EMIT_INTERVAL + jitter);
      // Advance sweep phase based on elapsed time segment (approx)
      emitterPhase += (2 * Math.PI) * EMITTER_SWEEP_HZ * (EMIT_INTERVAL + jitter);
      const p = pickSpawnPoint();
      // Occasionally emit small clusters to mimic handful tosses
      const drops = (Math.random() < 0.35 ? 3 : 1);
      for (let i=0; i<drops; i++) {
        if (balls.length < MAX_BALLS) {
          // Slight horizontal staggering to suggest sideways motion
          const xOffset = i * CONSTANTS.BALL_CLUSTER_SPACING * (Math.random() < 0.5 ? 1 : -1);
          spawnBall(p.x + xOffset, p.y - i * CONSTANTS.BALL_CLUSTER_Y_OFFSET);
        }
      }
    }
  }

  // Spatial hash grid to accelerate broad-phase (optimized)
  const spatialGrid = new Map();
  
  function collectPairsSorted() {
    const n = balls.length;
    if (n < 2) return []; // Early exit for trivial cases
    const cellSize = Math.max(1, R_MAX * 2); // Optimized cell size
    const gridWidth = Math.ceil(canvas.width / cellSize) + 1; // Dynamic grid width
    spatialGrid.clear(); // Reuse map
    
    // Build grid with numeric keys (faster than string concatenation)
    for (let i = 0; i < n; i++) {
      const b = balls[i];
      const cx = (b.x / cellSize) | 0;
      const cy = (b.y / cellSize) | 0;
      const key = cy * gridWidth + cx; // Numeric key
      let arr = spatialGrid.get(key);
      if (!arr) { arr = []; spatialGrid.set(key, arr); }
      arr.push(i);
    }
    
    const pairs = [];
    for (const [key, arr] of spatialGrid) {
      const cy = (key / gridWidth) | 0;
      const cx = key % gridWidth;
      
      // Check 9 neighboring cells (including self)
      for (let oy = -1; oy <= 1; oy++) {
        for (let ox = -1; ox <= 1; ox++) {
          const neighborKey = (cy + oy) * gridWidth + (cx + ox);
          const nb = spatialGrid.get(neighborKey);
          if (!nb) continue;
          
          for (let ii = 0; ii < arr.length; ii++) {
            const i = arr[ii];
            for (let jj = 0; jj < nb.length; jj++) {
              const j = nb[jj];
              if (j <= i) continue;
              
              const A = balls[i], B = balls[j];
              const dx = B.x - A.x, dy = B.y - A.y;
              const rSum = A.r + B.r;
              const dist2 = dx*dx + dy*dy;
              
              if (dist2 < rSum*rSum) {
                const dist = Math.sqrt(Math.max(dist2, CONSTANTS.MIN_DISTANCE_EPSILON));
                const overlap = rSum - dist;
                pairs.push({ i, j, overlap });
              }
            }
          }
        }
      }
    }
    
    // Sort by overlap (most overlapping first for stability)
    pairs.sort((a, b) => b.overlap - a.overlap);
    return pairs;
  }

  // Circleâ€“circle collisions: sequential impulses + Baumgarte positional correction
  function resolveCollisions(iterations = SOLVER_ITERS) {
    const pairs = collectPairsSorted();
    for (let iter = 0; iter < iterations; iter++) {
      for (let k = 0; k < pairs.length; k++) {
        const { i, j } = pairs[k];
        const A = balls[i];
        const B = balls[j];
        const dx = B.x - A.x;
        const dy = B.y - A.y;
        const rSum = A.r + B.r;
        const dist2 = dx * dx + dy * dy;
        if (dist2 === 0 || dist2 > rSum * rSum) continue;
        const dist = Math.sqrt(dist2);
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = rSum - dist;
        const invA = 1 / Math.max(A.m, 0.001);
        const invB = 1 / Math.max(B.m, 0.001);

        // Positional correction
        const correctionMag = POS_CORRECT_PERCENT * Math.max(overlap - POS_CORRECT_SLOP, 0) / (invA + invB);
        const cx = correctionMag * nx;
        const cy = correctionMag * ny;
        A.x -= cx * invA; A.y -= cy * invA;
        B.x += cx * invB; B.y += cy * invB;

        // Velocity impulse along the normal
        const rvx = B.vx - A.vx;
        const rvy = B.vy - A.vy;
        const velAlongNormal = rvx * nx + rvy * ny;
        if (velAlongNormal < 0) {
          const e = Math.abs(velAlongNormal) < REST_VEL_THRESHOLD ? 0 : REST;
          const j = -(1 + e) * velAlongNormal / (invA + invB);
          const ix = j * nx;
          const iy = j * ny;
          A.vx -= ix * invA; A.vy -= iy * invA;
          B.vx += ix * invB; B.vy += iy * invB;

          // Tangential slip to spin (approximate rolling/spin transfer)
          const tvx = rvx - velAlongNormal * nx;
          const tvy = rvy - velAlongNormal * ny;
          const slipMag = Math.hypot(tvx, tvy);
          if (slipMag > 1e-3) {
            const tangentSign = (tvx * -ny + tvy * nx) >= 0 ? 1 : -1; // right-hand tangent
            const gain = CONSTANTS.SPIN_GAIN_TANGENT;
            A.omega -= tangentSign * gain * slipMag / Math.max(A.r, 1);
            B.omega += tangentSign * gain * slipMag / Math.max(B.r, 1);
          }
          // Visual squash aligned to contact normal based on impact
          const impact = Math.min(1, Math.abs(velAlongNormal) / ((A.r + B.r) * 50));
          const sAmt = Math.min(getSquashMax(), impact * 0.8);
          A.squashAmount = Math.max(A.squashAmount, sAmt * 0.8);
          A.squashNormalAngle = Math.atan2(-ny, -nx);
          B.squashAmount = Math.max(B.squashAmount, sAmt * 0.8);
          B.squashNormalAngle = Math.atan2(ny, nx);
        }
      }
    }
  }

  // Main loop optimized for 120fps
  let last = performance.now() / 1000;
  let acc = 0;
  const DT = 1/120; // Target 120fps physics
  function frame(nowMs) {
    const now = nowMs / 1000;
    let dt = Math.min(0.008, now - last); // Cap at ~120fps for high refresh displays
    last = now;
    acc += dt;

  // FPS counters (render and physics) - only update if elements exist
    renderFrameCount++;
    if ((renderFpsElement || physicsFpsElement) && now - lastFPSTime >= CONSTANTS.FPS_UPDATE_INTERVAL) {
      if (renderFpsElement && renderFrameCount !== currentRenderFPS) {
        currentRenderFPS = renderFrameCount;
        renderFpsElement.textContent = currentRenderFPS.toString();
      }
      if (physicsFpsElement && physicsStepCount !== currentPhysicsFPS) {
        currentPhysicsFPS = physicsStepCount;
        physicsFpsElement.textContent = currentPhysicsFPS.toString();
      }
      
      renderFrameCount = 0;
      physicsStepCount = 0;
      lastFPSTime = now;
      
      // Update adaptive quality based on current FPS
      updateAdaptiveQuality(now);
    }

    emit(dt);
    
    // Update text colliders periodically (every ~60 frames for performance)
    if (renderFrameCount % 60 === 0) {
      updateTextColliders();
    }

    // Physics iterations optimized for realistic, stable simulation
    let physicsSteps = 0;
    while (acc >= DT && physicsSteps < CONSTANTS.MAX_PHYSICS_STEPS) {
        for (let i=0; i<balls.length; i++) balls[i].step(DT);
      
      // Ball-to-ball collisions (disabled for Flies mode only)
      if (currentMode !== MODES.FLIES) {
        resolveCollisions(currentCollisionIters); // Dynamic iterations based on adaptive quality
      }
      
      // Wall collisions (all modes)
      const wallRestitution = (currentMode === MODES.WEIGHTLESS) ? weightlessBounce : REST;
      for (let i=0; i<balls.length; i++) balls[i].walls(canvas.width, canvas.height, DT, wallRestitution);
      
      acc -= DT;
      physicsSteps++;
      physicsStepCount++; // Count physics steps for FPS measurement
    }
    
    // Reset accumulator if we're falling behind
    if (acc > DT * CONSTANTS.ACCUMULATOR_RESET_THRESHOLD) acc = 0;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // RENDERING (Canvas2D or WebGL based on useWebGL flag)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    if (useWebGL && pixiApp) {
      // WebGL Rendering Path
      updateAdaptiveQuality(); // Monitor performance
      cleanupRemovedBalls(); // Remove sprites for deleted balls
      
      // Render visual effects
      renderRoundedBoundaryWebGL();
      
      // Render all balls with frustum culling
      const margin = 100; // Render balls slightly outside viewport
      for (let i=0; i<balls.length; i++) {
        const ball = balls[i];
        // Frustum culling: skip balls outside viewport
        if (ball.x + ball.r < -margin || ball.x - ball.r > canvas.width + margin ||
            ball.y + ball.r < -margin || ball.y - ball.r > canvas.height + margin) {
          // Hide off-screen sprites
          const sprite = ballSprites.get(ball);
          if (sprite) sprite.visible = false;
          continue;
        }
        
        // Show and render on-screen balls
        renderBallWebGL(ball);
        const sprite = ballSprites.get(ball);
        if (sprite) sprite.visible = true;
      }
      
      // Render cursor ball and mode indicator
      renderCursorBallWebGL();
      renderModeIndicatorWebGL();
      
      // PixiJS handles rendering automatically via its ticker
    } else {
      // Canvas2D Rendering Path (Original)
      ctx.clearRect(0,0,canvas.width,canvas.height);
      
      // Draw rounded boundary if corner radius > 0 (cache boundary path for performance)
      if (cornerRadius > 0) {
        drawRoundedBoundary(ctx, canvas.width, canvas.height);
      }
      
      // Shadow rendering removed for better performance and realism
      
      // Render balls with individual colors
      for (let i=0; i<balls.length; i++) balls[i].draw(ctx);
      // Draw cursor ball last
      drawCursorBall(ctx);
    }
    
    // Draw current mode indicator (desktop only)
    if (!isTouchDevice) {
      ctx.save();
      ctx.font = '14px system-ui, -apple-system, sans-serif';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      const modeName = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      ctx.fillText(modeName + ' Mode', 10, canvas.height - 10);
      ctx.restore();
    }

    // Use requestAnimationFrame for proper vsync
    requestAnimationFrame(frame);
  }
  
  // Start the main loop with requestAnimationFrame
  console.log('High refresh mode enabled - using requestAnimationFrame');
  requestAnimationFrame(frame);

  // Reset ball sizes to global setting when switching modes
  function resetBallSizeToGlobal() {
    // Update size scale from slider (if needed)
    const globalScale = parseFloat(sizeSliderGlobal.value);
    sizeScale = globalScale;
    
    // Recalculate the actual size range based on sizeScale
    updateEffectiveScaleAndBallSizes();
    
    // Update all existing balls to use proper global size
    const baseSize = (R_MIN + R_MAX) / 2;
    for (let i = 0; i < balls.length; i++) {
      // Apply size variation if set, otherwise use base size
      if (sizeVariation === 0) {
        balls[i].r = baseSize;
        balls[i].rBase = baseSize;
      } else {
        // Apply limited variation (max 10% from global ball size)
        const maxVariation = baseSize * 0.1;
        const minR = Math.max(1, baseSize - maxVariation);
        const maxR = baseSize + maxVariation;
        balls[i].r = randBetween(minR, maxR);
        balls[i].rBase = balls[i].r;
      }
    }
  }

  // Reset balls to spawn positions (preserves all settings)
  function resetBallsToSpawn() {
    if (currentMode === MODES.WEIGHTLESS) {
      // For weightless mode, reinitialize with even distribution
      initializeWeightlessScene();
    } else {
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      const p = pickSpawnPoint();
      ball.x = p.x;
      ball.y = p.y;
      // Re-apply natural entry throw on reset (sweep-aware, size-aware)
      const centerX = canvas.width * 0.5;
      const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((ball.x < centerX) ? 1 : -1);
      const sizeInfluence = clamp((ball.r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
      const baseKick = 140 * sizeInfluence;
      const randKick = 180 * sizeInfluence;
      const upwardKick = 120;
      ball.vx = dir * (baseKick + Math.random() * randKick);
      ball.vy = -Math.random() * upwardKick;
      ball.age = 0;
      ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence;
      ball.driftTime = 0.22 + Math.random() * 0.28;
      }
    }
  }

  // Keyboard: reset balls to spawn, toggle panel
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DRAGGABLE PANEL FUNCTIONALITY
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const panelHeader = document.getElementById('panelHeader');
  const minimizeBtn = document.getElementById('minimizePanel');
  
  // Configuration: Initial panel visibility (true = visible, false = hidden)
  const PANEL_INITIALLY_VISIBLE = true;
  
  // Apply initial visibility
  if (!PANEL_INITIALLY_VISIBLE && panel) {
    panel.classList.add('hidden');
  }
  
  // Minimize/maximize button
  if (minimizeBtn && panel) {
    minimizeBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      panel.classList.toggle('hidden');
    });
  }
  
  // Drag functionality
  if (panelHeader && panel) {
    let isDragging = false;
    let currentX;
    let currentY;
    let initialX;
    let initialY;
    let xOffset = 0;
    let yOffset = 0;
    
    panelHeader.addEventListener('mousedown', dragStart);
    document.addEventListener('mousemove', drag);
    document.addEventListener('mouseup', dragEnd);
    
    // Touch support
    panelHeader.addEventListener('touchstart', dragStart);
    document.addEventListener('touchmove', drag);
    document.addEventListener('touchend', dragEnd);
    
    function dragStart(e) {
      if (e.type === 'touchstart') {
        initialX = e.touches[0].clientX - xOffset;
        initialY = e.touches[0].clientY - yOffset;
      } else {
        initialX = e.clientX - xOffset;
        initialY = e.clientY - yOffset;
      }
      
      if (e.target === panelHeader || panelHeader.contains(e.target)) {
        isDragging = true;
        panel.style.cursor = 'grabbing';
      }
    }
    
    function drag(e) {
      if (isDragging) {
        e.preventDefault();
        
        if (e.type === 'touchmove') {
          currentX = e.touches[0].clientX - initialX;
          currentY = e.touches[0].clientY - initialY;
        } else {
          currentX = e.clientX - initialX;
          currentY = e.clientY - initialY;
        }
        
        xOffset = currentX;
        yOffset = currentY;
        
        // Convert fixed position to transform for smooth dragging
        const rect = panel.getBoundingClientRect();
        const computedStyle = window.getComputedStyle(panel);
        const initialTop = parseFloat(computedStyle.top) || 0;
        const initialRight = parseFloat(computedStyle.right) || 0;
        
        panel.style.top = `${initialTop + yOffset}px`;
        panel.style.right = `${initialRight - xOffset}px`;
        panel.style.left = 'auto';
        panel.style.bottom = 'auto';
        
        // Reset offsets after applying position
        xOffset = 0;
        yOffset = 0;
        initialX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX;
        initialY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;
      }
    }
    
    function dragEnd(e) {
      if (isDragging) {
        isDragging = false;
        panel.style.cursor = 'move';
        initialX = currentX;
        initialY = currentY;
      }
    }
  }
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // KEYBOARD SHORTCUTS
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k === 'r') {
      // Move balls back to spawn area - preserve all parameter settings
      resetBallsToSpawn();
      e.preventDefault(); // Prevent any default browser behavior
    }
    if (k === '/' && panel) {
      e.preventDefault();
      panel.classList.toggle('hidden');
    }
    // Quick mode switches 1-3
    if (k === '1') setMode(MODES.PIT);
    if (k === '2') setMode(MODES.FLIES);
    if (k === '3') setMode(MODES.WEIGHTLESS);
  });

  // Seed initial balls across the spawn area for quicker fill
  function seedArea(n = 160) {
    for (let i=0; i<n && balls.length < MAX_BALLS; i++) {
      const p = pickSpawnPoint();
      spawnBall(p.x, p.y);
    }
  }
  seedArea(CONSTANTS.INITIAL_SEED_BALLS);

  // Shadow system removed for better performance



  // Mouse input (unified handler for repeller + trail recording + boulder dragging)
  let lastTrailRecordTime = 0;
  let lastMousePosition = { x: 0, y: 0 };
  let mouseStoppedTime = 0;
  
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * DPR;
      mouseY = (e.clientY - rect.top) * DPR;
    
    // Ball Pit: enable repeller when power and radius are set
    if (currentMode === MODES.PIT && repelPower > 0 && repelRadius > 0) {
      repellerEnabled = true;
    }


  });
  canvas.addEventListener('mouseleave', () => {
    mouseX = CONSTANTS.OFFSCREEN_MOUSE;
    mouseY = CONSTANTS.OFFSCREEN_MOUSE;
  });


  // Draw a cursor as a ball matching the simulation style
  // Renders the cursor as a simulation-like ball for desktop. Hidden on touch.
  function drawCursorBall(ctx) {
    // Don't show cursor ball on touch devices (mobile)
    if (isTouchDevice) return;
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    
    
    // Draw main cursor ball for all other modes (white by default on desktop)
    const x = mouseX, y = mouseY;
    const baseSize = (R_MIN + R_MAX) / 2;
    const r = baseSize;
    const color = 'rgba(255, 255, 255, 0.9)';
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    // Add subtle white outline for visibility
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function applyRepeller(b, dt) {
    // Respect "Off" template by treating zero or near-zero params as disabled
    if (!repellerEnabled) return;
    if (repelPower <= 0 || repelRadius <= 0) return;
    const rPx = repelRadius * DPR;
    const dx = b.x - mouseX;
    const dy = b.y - mouseY;
    const d2 = dx*dx + dy*dy;
    const r2 = rPx * rPx;
    if (d2 > r2) return;
    const d = Math.max(Math.sqrt(d2), CONSTANTS.MIN_REPEL_DISTANCE);
    const nx = dx / d;
    const ny = dy / d;
    const q = Math.max(0, 1 - d / rPx);
    const strength = (repelPower * REPELLER_GLOBAL_MULTIPLIER) * Math.pow(q, repelSoft);
    // Heavier balls respond less to the same field
    const massScale = Math.max(0.25, b.m / MASS_BASELINE_KG);
    b.vx += (nx * strength * dt) / massScale;
    b.vy += (ny * strength * dt) / massScale;
    // Add subtle air turbulence for realism (micro perturbations)
    const turbulence = 10; // subtle random force
    b.vx += (Math.random() - 0.5) * turbulence * dt;
    b.vy += (Math.random() - 0.5) * turbulence * dt;
  }

  // Behavior-mode external forces dispatcher
  function applyExternalForces(b, dt) {
    if (currentMode === MODES.PIT) {
      applyRepeller(b, dt);
      return;
    }
    if (currentMode === MODES.FLIES) {
      applyAttractor(b, dt);
      return;
    }
    if (currentMode === MODES.WEIGHTLESS) {
      applyWeightlessRepeller(b, dt);
      return;
    }
  }
  
  // Subtle mouse repeller for Weightless mode
  function applyWeightlessRepeller(b, dt) {
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    if (weightlessRepellerPower <= 0 || weightlessRepellerRadius <= 0) return;
    
    const rPx = weightlessRepellerRadius * DPR;
    const dx = b.x - mouseX;
    const dy = b.y - mouseY;
    const d2 = dx*dx + dy*dy;
    const r2 = rPx * rPx;
    if (d2 > r2) return;
    
    const d = Math.max(Math.sqrt(d2), CONSTANTS.MIN_REPEL_DISTANCE);
    const nx = dx / d;
    const ny = dy / d;
    const q = Math.max(0, 1 - d / rPx);
    const strength = weightlessRepellerPower * q; // linear falloff, gentle
    
    b.vx += nx * strength * dt;
    b.vy += ny * strength * dt;
  }

  // Mouse attractor for Flies-to-Light mode - REALISTIC INSECT FLIGHT
  // Reference: Mosquitoes fly 1-2 m/s with quick acceleration and erratic patterns
  function applyAttractor(b, dt) {
    // Idle swarm center (viewport center) when mouse is outside
    const swarmCenterX = (mouseX === CONSTANTS.OFFSCREEN_MOUSE) ? canvas.width * 0.5 : mouseX;
    const swarmCenterY = (mouseY === CONSTANTS.OFFSCREEN_MOUSE) ? canvas.height * 0.5 : mouseY;
    
    const dx = swarmCenterX - b.x;
    const dy = swarmCenterY - b.y;
    const d2 = dx*dx + dy*dy;
    const d = Math.sqrt(d2 + 1);
    
    // Direction to target (mouse or swarm center)
    const dirX = dx / d;
    const dirY = dy / d;
    
    // 1. VERY STRONG ATTRACTION - insects have incredible acceleration relative to size
    // Mosquitoes can accelerate at 50+ g's in short bursts
    const attractForce = attractionPower * swarmSpeed * 2.0; // Use swarmSpeed multiplier
    b.vx += dirX * attractForce * dt;
    b.vy += dirY * attractForce * dt;
    
    // 2. SEPARATION from nearby flies (looser swarm - insects don't stick together)
    const separationRadius = 120 * DPR; // Much larger separation for natural spread
    let sepX = 0, sepY = 0;
    let neighborCount = 0;
    for (let i = 0; i < balls.length; i++) {
      const other = balls[i];
      if (other === b) continue;
      const dx2 = b.x - other.x;
      const dy2 = b.y - other.y;
      const d2_other = dx2*dx2 + dy2*dy2;
      if (d2_other < separationRadius * separationRadius && d2_other > 0) {
        const d_other = Math.sqrt(d2_other);
        const strength = 1 - (d_other / separationRadius);
        sepX += (dx2 / d_other) * strength;
        sepY += (dy2 / d_other) * strength;
            neighborCount++;
          }
        }
    if (neighborCount > 0) {
      const separationForce = 15000; // Stronger separation for more spread
      b.vx += (sepX / neighborCount) * separationForce * dt;
      b.vy += (sepY / neighborCount) * separationForce * dt;
    }
    
    // 3. INTENSE ERRATIC JITTER - mosquitos dart unpredictably with bursts
    // Real mosquitoes change direction constantly and have explosive acceleration
    const jitterBase = 2500 * swarmSpeed; // Scale jitter with swarm speed
    const burstChance = 0.08; // 8% chance per frame for sudden burst
    if (Math.random() < burstChance) {
      // Sudden burst in random direction (mimics insect reflex)
      const burstAngle = Math.random() * Math.PI * 2;
      const burstStrength = 1500 * swarmSpeed;
      b.vx += Math.cos(burstAngle) * burstStrength;
      b.vy += Math.sin(burstAngle) * burstStrength;
    }
    // Constant erratic jitter (insects never fly perfectly straight)
    b.vx += (Math.random() - 0.5) * jitterBase * dt;
    b.vy += (Math.random() - 0.5) * jitterBase * dt;
    
    // 4. CHAOTIC ORBITAL MOTION - insects spiral unpredictably
    // Orbital force varies wildly based on distance and random factor
    const orbitVariation = 0.3 + Math.random() * 2.0; // 0.3x to 2.3x variation
    const orbitStrength = swarmSpeed * 2000 * orbitVariation * dt; // Strong orbital
    b.vx += -dirY * orbitStrength;
    b.vy += dirX * orbitStrength;
    
    // 5. VERY HIGH speed limit - insects are remarkably fast for their size
    const maxSpeed = 2200 * swarmSpeed; // Scale max speed with swarm speed
    const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
    if (speed > maxSpeed) {
      b.vx = (b.vx / speed) * maxSpeed;
      b.vy = (b.vy / speed) * maxSpeed;
    }
    
    // Minimal damping - insects maintain energy through constant wing beats
    b.vx *= 0.995; // Very light damping for sustained high energy
    b.vy *= 0.995;
  }


  // UI elements
  const restitutionSlider = document.getElementById('restitutionSlider');
  const frictionSlider = document.getElementById('frictionSlider');
  const emitterSlider = document.getElementById('emitterSlider');
  // Mode-specific ball properties controls
  // Global ball properties
  const sizeSliderGlobal = document.getElementById('sizeSliderGlobal');
  const sizeVariationSliderGlobal = document.getElementById('sizeVariationSliderGlobal');
  const weightSliderGlobal = document.getElementById('weightSliderGlobal');
  const ballSoftnessSliderGlobal = document.getElementById('ballSoftnessSliderGlobal');
  const sizeValGlobal = document.getElementById('sizeValGlobal');
  const sizeVariationValGlobal = document.getElementById('sizeVariationValGlobal');
  const weightValGlobal = document.getElementById('weightValGlobal');
  const ballSoftnessValGlobal = document.getElementById('ballSoftnessValGlobal');
  
  // Mode-specific sliders (kept for backward compatibility)
  const sizeSliderPit = document.getElementById('sizeSliderPit');
  const sizeVariationSliderPit = document.getElementById('sizeVariationSliderPit');
  const weightSliderPit = document.getElementById('weightSliderPit');
  const ballSoftnessSliderPit = document.getElementById('ballSoftnessSliderPit');
  const sizeValPit = document.getElementById('sizeValPit');
  const sizeVariationValPit = document.getElementById('sizeVariationValPit');
  const weightValPit = document.getElementById('weightValPit');
  const ballSoftnessValPit = document.getElementById('ballSoftnessValPit');

  const sizeSliderFlies = document.getElementById('sizeSliderFlies');
  const sizeVariationSliderFlies = document.getElementById('sizeVariationSliderFlies');
  const weightSliderFlies = document.getElementById('weightSliderFlies');
  const ballSoftnessSliderFlies = document.getElementById('ballSoftnessSliderFlies');
  const sizeValFlies = document.getElementById('sizeValFlies');
  const sizeVariationValFlies = document.getElementById('sizeVariationValFlies');
  const weightValFlies = document.getElementById('weightValFlies');
  const ballSoftnessValFlies = document.getElementById('ballSoftnessValFlies');

  const sizeSliderZeroG = document.getElementById('sizeSliderZeroG');
  const sizeVariationSliderZeroG = document.getElementById('sizeVariationSliderZeroG');
  const weightSliderZeroG = document.getElementById('weightSliderZeroG');
  const ballSoftnessSliderZeroG = document.getElementById('ballSoftnessSliderZeroG');
  const sizeValZeroG = document.getElementById('sizeValZeroG');
  const sizeVariationValZeroG = document.getElementById('sizeVariationValZeroG');
  const weightValZeroG = document.getElementById('weightValZeroG');
  const ballSoftnessValZeroG = document.getElementById('ballSoftnessValZeroG');

  const maxBallsSlider = document.getElementById('maxBallsSlider');
  const spawnYSlider = document.getElementById('spawnYSlider');
  const spawnWidthSlider = document.getElementById('spawnWidthSlider');
  const spawnCenterSlider = document.getElementById('spawnCenterSlider');
  const spawnHeightSlider = document.getElementById('spawnHeightSlider');
  const repelSizeSlider = document.getElementById('repelSizeSlider');
  const repelPowerSlider = document.getElementById('repelPowerSlider');
  const repelSoftSlider = document.getElementById('repelSoftSlider');
  // Color controls
  const colorSelect = document.getElementById('colorSelect');
  const color1 = document.getElementById('color1');
  const color2 = document.getElementById('color2');
  const color3 = document.getElementById('color3');
  const color4 = document.getElementById('color4');
  const color5 = document.getElementById('color5');
  const color6 = document.getElementById('color6');
  const color7 = document.getElementById('color7');
  const color8 = document.getElementById('color8');
  const cursorColorSelect = document.getElementById('cursorColorSelect');
  // Hex spans
  const color1Val = document.getElementById('color1Val');
  const color2Val = document.getElementById('color2Val');
  const color3Val = document.getElementById('color3Val');
  const color4Val = document.getElementById('color4Val');
  const color5Val = document.getElementById('color5Val');
  const color6Val = document.getElementById('color6Val');
  const color7Val = document.getElementById('color7Val');
  const color8Val = document.getElementById('color8Val');
  // Tooltip hint for copy action
  [color1Val, color2Val, color3Val, color4Val, color5Val, color6Val, color7Val, color8Val].forEach(el => {
    if (el) el.setAttribute('title', 'Click to copy');
  });
  // Scene controls
  const cornerRadiusSlider = document.getElementById('cornerRadiusSlider');
  const cornerRadiusVal = document.getElementById('cornerRadiusVal');
  const motionBlurFadeSlider = document.getElementById('trailFadeSlider'); // motion blur uses old trailFade ID
  const motionBlurFadeVal = document.getElementById('trailFadeVal');
  const trailSubtletySlider = document.getElementById('trailSubtletySlider');
  const trailSubtletyVal = document.getElementById('trailSubtletyVal');

  const restitutionVal = document.getElementById('restitutionVal');
  const frictionVal = document.getElementById('frictionVal');
  const emitterVal = document.getElementById('emitterVal');
  // const sizeVal = document.getElementById('sizeVal'); // Removed - using global controls
  const maxBallsVal = document.getElementById('maxBallsVal');
  // const sizeVariationVal = document.getElementById('sizeVariationVal'); // Removed - using global controls
  // const weightVal = document.getElementById('weightVal'); // Removed - using global controls
  const spawnYVal = document.getElementById('spawnYVal');
  const spawnWidthVal = document.getElementById('spawnWidthVal');
  const spawnCenterVal = document.getElementById('spawnCenterVal');
  const spawnHeightVal = document.getElementById('spawnHeightVal');
  const repelSizeVal = document.getElementById('repelSizeVal');
  const repelPowerVal = document.getElementById('repelPowerVal');
  const repelSoftVal = document.getElementById('repelSoftVal');
  // Scene controls vals (shadows removed)

  // Config capture and build functionality (restored)
  function captureCurrentConfig() {
    return {
      gravityMultiplier,
      restitution: REST,
      friction: FRICTION,
      ballMass: ballMassKg,
      emitRate: EMIT_INTERVAL,
      maxBalls: MAX_BALLS,
      ballScale: sizeScale,
      ballVariation: sizeVariation,
      spawnX: SPAWN_X_CENTER_VW,
      spawnY: SPAWN_Y_VH,
      spawnWidth: SPAWN_W_VW,
      spawnHeight: SPAWN_H_VH,
      sweepEnabled: EMITTER_SWEEP_ENABLED,
      repelRadius,
      repelPower,
      repelSoftness: repelSoft,
      trailFade,
      trailSubtlety,
      colors: currentColors.slice(),
      colorWeights: COLOR_WEIGHTS.slice(),
      currentTemplate,
      cursorColorIndex: cursorBallIndex
    };
  }
  function generateConfigCode(config) {
    return `// Generated configuration from frontend\nconst CONFIG = ${JSON.stringify(config, null, 2)};`;
  }
  const saveConfigBtn = document.getElementById('saveConfigBtn');
  const buildBtn = document.getElementById('buildBtn');
  const configOutput = document.getElementById('configOutput');
  if (saveConfigBtn && buildBtn && configOutput) {
    saveConfigBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      const code = generateConfigCode(config);
      configOutput.style.display = 'block';
      configOutput.textContent = code;
      navigator.clipboard.writeText(code).then(() => {
        const old = saveConfigBtn.textContent; saveConfigBtn.textContent = 'âœ… Copied!';
        setTimeout(() => { saveConfigBtn.textContent = old; }, 1200);
      }).catch(() => {
        console.warn('Clipboard copy failed');
        const old = saveConfigBtn.textContent; saveConfigBtn.textContent = 'âš ï¸ Copy failed';
        setTimeout(() => { saveConfigBtn.textContent = old; }, 1200);
      });
    });
    buildBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      configOutput.style.display = 'block';
      configOutput.innerHTML = `
<strong>ğŸš€ Build Instructions:</strong><br>
1. Run: <code>npm run build</code><br>
2. Your current config will be baked into <code>public/js/bouncy-balls-embed.js</code>`;
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'current-config.json'; a.click();
      URL.revokeObjectURL(url);
    });
  }

  // Click-to-copy helper
  function bindCopyOnClick(el, getText) {
    if (!el) return;
    el.addEventListener('click', async () => {
      const text = typeof getText === 'function' ? getText() : String(getText || '').trim();
      try {
        await navigator.clipboard.writeText(text);
        const old = el.textContent;
        el.textContent = 'COPIED';
        el.style.color = '#3ddc84';
        setTimeout(() => { el.textContent = old; el.style.color = '#888'; }, 900);
      } catch (e) {
        console.warn('Clipboard unavailable');
      }
    });
  }

  // Sliders (with auto-save)
  restitutionSlider && restitutionSlider.addEventListener('input', () => { REST = parseFloat(restitutionSlider.value); restitutionVal && (restitutionVal.textContent = REST.toFixed(2)); autoSaveSettings(); });
  frictionSlider && frictionSlider.addEventListener('input', () => { FRICTION = parseFloat(frictionSlider.value); frictionVal && (frictionVal.textContent = FRICTION.toFixed(4)); autoSaveSettings(); });
  emitterSlider && emitterSlider.addEventListener('input', () => { EMIT_INTERVAL = parseFloat(emitterSlider.value); emitterVal && (emitterVal.textContent = EMIT_INTERVAL.toFixed(3)); autoSaveSettings(); });

  // Mode-specific ball properties listeners (apply values globally but source UI is per-mode)
  function bindBallProps(sliders) {
    if (!sliders) return;
    const { size, sizeVal, sizeVar, sizeVarVal, soft, softVal } = sliders;
    size && size.addEventListener('input', () => {
      const newScale = parseFloat(size.value);
    sizeVal && (sizeVal.textContent = newScale.toFixed(1));
    sizeScale = newScale;
    updateEffectiveScaleAndBallSizes();
      // Apply mass to all balls
      for (let i=0; i<balls.length; i++) {
        balls[i].m = ballMassKg;
      }
      autoSaveSettings();
    });
    sizeVar && sizeVar.addEventListener('input', () => {
      const v = parseFloat(sizeVar.value);
      sizeVarVal && (sizeVarVal.textContent = v.toFixed(1));
      sizeVariation = v;
      autoSaveSettings();
    });
    soft && soft.addEventListener('input', () => {
      const s = parseInt(soft.value, 10);
      softVal && (softVal.textContent = String(s));
      ballSoftness = s;
      autoSaveSettings();
    });
  }

  // Global ball properties (apply to all modes)
  bindBallProps({
    size: sizeSliderGlobal, sizeVal: sizeValGlobal,
    sizeVar: sizeVariationSliderGlobal, sizeVarVal: sizeVariationValGlobal,
    soft: ballSoftnessSliderGlobal, softVal: ballSoftnessValGlobal
  });
  maxBallsSlider && maxBallsSlider.addEventListener('input', () => {
    MAX_BALLS = parseInt(maxBallsSlider.value, 10);
    maxBallsVal && (maxBallsVal.textContent = MAX_BALLS.toString());
    // Remove excess balls if current count exceeds new limit (remove from end for better performance)
    if (balls.length > MAX_BALLS) {
      balls.length = MAX_BALLS; // Truncate array efficiently
    }
  });
  sizeVariationSliderGlobal && sizeVariationSliderGlobal.addEventListener('input', () => {
    sizeVariation = parseFloat(sizeVariationSliderGlobal.value);
    sizeVariationValGlobal && (sizeVariationValGlobal.textContent = sizeVariation.toFixed(1));
    
    // Update existing ball sizes to reflect new variation
    updateExistingBallSizes();
  });
  // Mode-specific weight controls
  const weightPitSlider = document.getElementById('weightPitSlider');
  const weightPitVal = document.getElementById('weightPitVal');
  const weightWeightlessSlider = document.getElementById('weightWeightlessSlider');
  const weightWeightlessVal = document.getElementById('weightWeightlessVal');
  // removed legacy rainbow weight controls (replaced by boulderWeight controls)
  
  // Function to update existing ball sizes based on current sizeVariation
  function updateExistingBallSizes() {
    const baseSize = (R_MIN + R_MAX) / 2;
    
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      
      if (sizeVariation === 0) {
        // No variation: all balls exactly the same size
        ball.r = baseSize;
      } else {
        // Apply limited variation (max 10% from global ball size)
        const maxVariation = baseSize * 0.1; // 10% of global ball size
        const minR = Math.max(1, baseSize - maxVariation);
        const maxR = baseSize + maxVariation;
        ball.r = randBetween(minR, maxR);
      }
      
      // Keep shared mass model (no per-ball recompute)
      ball.m = ballMassKg;
    }
  }
  spawnYSlider && spawnYSlider.addEventListener('input', () => {
    SPAWN_Y_VH = parseFloat(spawnYSlider.value);
    spawnYVal && (spawnYVal.textContent = SPAWN_Y_VH.toFixed(0));
    setCSSSize(); resize();
  });
  spawnWidthSlider && spawnWidthSlider.addEventListener('input', () => { SPAWN_W_VW = parseFloat(spawnWidthSlider.value); spawnWidthVal && (spawnWidthVal.textContent = SPAWN_W_VW.toFixed(0)); });
  spawnCenterSlider && spawnCenterSlider.addEventListener('input', () => { SPAWN_X_CENTER_VW = parseFloat(spawnCenterSlider.value); spawnCenterVal && (spawnCenterVal.textContent = SPAWN_X_CENTER_VW.toFixed(0)); });
  spawnHeightSlider && spawnHeightSlider.addEventListener('input', () => { SPAWN_H_VH = parseFloat(spawnHeightSlider.value); spawnHeightVal && (spawnHeightVal.textContent = SPAWN_H_VH.toFixed(0)); });
  repelSizeSlider && repelSizeSlider.addEventListener('input', () => {
    repelRadius = parseFloat(repelSizeSlider.value);
    repelSizeVal && (repelSizeVal.textContent = repelRadius.toFixed(0));
    repellerEnabled = repellerEnabled || (repelPower > 0 && repelRadius > 0); 
  });
  repelPowerSlider && repelPowerSlider.addEventListener('input', () => {
    repelPower = repelSliderToPower(repelPowerSlider.value);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    // Do not auto-enable when template is Off; only enable via template or size/power explicit >0 with mouse over
    if (repellerSelect && repellerSelect.value !== 'off') {
      repellerEnabled = repelPower > 0 && repelRadius > 0; 
    }
  });
  repelSoftSlider && repelSoftSlider.addEventListener('input', () => {
    repelSoft = parseFloat(repelSoftSlider.value);
    repelSoftVal && (repelSoftVal.textContent = repelSoft.toFixed(1));
  });
  // Shadow event listeners removed
  
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // WEBGL RENDERER & SHADER EVENT LISTENERS (Phase 2.2)
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // WebGL Renderer Toggle
  const useWebGLToggleEl = document.getElementById('useWebGLToggle');
  const rendererStatus = document.getElementById('rendererStatus');
  if (useWebGLToggleEl) {
    useWebGLToggleEl.addEventListener('change', () => {
      toggleRenderer();
      
      // Update status display
      if (rendererStatus) {
        if (useWebGL && pixiApp) {
          const type = pixiApp.renderer.type === PIXI.RENDERER_TYPE.WEBGL ? 'WebGL' : 'Canvas2D Fallback';
          rendererStatus.textContent = `Status: ${type} Active âœ…`;
          rendererStatus.style.background = 'rgba(0,255,0,0.2)';
        } else {
          rendererStatus.textContent = 'Status: Canvas2D Active';
          rendererStatus.style.background = 'rgba(0,0,0,0.2)';
        }
      }
      
      console.log('ğŸ”„ Renderer toggled:', useWebGL ? 'WebGL' : 'Canvas2D');
    });
  }
  
  // 3D Shader Controls
  const shaderEnabledEl = document.getElementById('shaderEnabled');
  const ballRoundnessEl = document.getElementById('ballRoundness');
  const ballRoundnessVal = document.getElementById('ballRoundnessVal');
  const lightAngleEl = document.getElementById('lightAngle');
  const lightAngleVal = document.getElementById('lightAngleVal');
  const edgeBevelWidthEl = document.getElementById('edgeBevelWidth');
  const edgeBevelWidthVal = document.getElementById('edgeBevelWidthVal');
  const edgeSharpnessEl = document.getElementById('edgeSharpness');
  const edgeSharpnessVal = document.getElementById('edgeSharpnessVal');
  const specularIntensityEl = document.getElementById('specularIntensity');
  const specularIntensityVal = document.getElementById('specularIntensityVal');
  
  shaderEnabledEl && shaderEnabledEl.addEventListener('change', () => {
    shaderEnabled = shaderEnabledEl.checked;
    console.log('ğŸ¨ Shader enabled:', shaderEnabled);
  });
  
  ballRoundnessEl && ballRoundnessEl.addEventListener('input', () => {
    ballRoundness = parseInt(ballRoundnessEl.value, 10);
    if (ballRoundnessVal) ballRoundnessVal.textContent = ballRoundness + '%';
    console.log('ğŸ”® Ball roundness:', ballRoundness);
  });
  
  lightAngleEl && lightAngleEl.addEventListener('input', () => {
    lightAngle = parseInt(lightAngleEl.value, 10);
    if (lightAngleVal) lightAngleVal.textContent = lightAngle + 'Â°';
    console.log('ğŸ’¡ Light angle:', lightAngle);
  });
  
  edgeBevelWidthEl && edgeBevelWidthEl.addEventListener('input', () => {
    edgeBevelWidth = parseFloat(edgeBevelWidthEl.value);
    if (edgeBevelWidthVal) edgeBevelWidthVal.textContent = edgeBevelWidth.toFixed(2);
    console.log('ğŸ”§ Edge bevel width:', edgeBevelWidth);
  });
  
  edgeSharpnessEl && edgeSharpnessEl.addEventListener('input', () => {
    edgeSharpness = parseFloat(edgeSharpnessEl.value);
    if (edgeSharpnessVal) edgeSharpnessVal.textContent = edgeSharpness.toFixed(1);
    console.log('âš¡ Edge sharpness:', edgeSharpness);
  });
  
  specularIntensityEl && specularIntensityEl.addEventListener('input', () => {
    specularIntensity = parseFloat(specularIntensityEl.value);
    if (specularIntensityVal) specularIntensityVal.textContent = specularIntensity.toFixed(2);
    console.log('âœ¨ Specular intensity:', specularIntensity);
  });
  
  // Mouse tracking for cursor ball and repeller
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) * DPR;
    mouseY = (e.clientY - rect.top) * DPR;
  });
  
  canvas.addEventListener('mouseleave', () => {
    mouseX = CONSTANTS.OFFSCREEN_MOUSE;
    mouseY = CONSTANTS.OFFSCREEN_MOUSE;
  });
  
  // Color controls
  colorSelect && colorSelect.addEventListener('change', () => {
    const template = COLOR_TEMPLATES[colorSelect.value];
    if (!template) return;
    currentTemplate = colorSelect.value;
    currentColors = template.colors.slice();
    // Keep cursor index and update color
    cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor;
    // Update color pickers + hex spans
    if (color1 && color1Val) { color1.value = currentColors[0]; color1Val.textContent = currentColors[0].toUpperCase(); }
    if (color2 && color2Val) { color2.value = currentColors[1]; color2Val.textContent = currentColors[1].toUpperCase(); }
    if (color3 && color3Val) { color3.value = currentColors[2]; color3Val.textContent = currentColors[2].toUpperCase(); }
    if (color4 && color4Val) { color4.value = currentColors[3]; color4Val.textContent = currentColors[3].toUpperCase(); }
    if (color5 && color5Val) { color5.value = currentColors[4]; color5Val.textContent = currentColors[4].toUpperCase(); }
    if (color6 && color6Val) { color6.value = currentColors[5]; color6Val.textContent = currentColors[5].toUpperCase(); }
    if (color7 && color7Val) { color7.value = currentColors[6]; color7Val.textContent = currentColors[6].toUpperCase(); }
    if (color8 && color8Val) { color8.value = currentColors[7]; color8Val.textContent = currentColors[7].toUpperCase(); }
    // Update existing ball colors
    updateExistingBallColors();
    // Sync CSS variables
    syncPaletteVars();
  });

  // Mode switcher wiring
  const modeButtons = Array.from(document.querySelectorAll('.mode-button'));
  const pitControls = document.getElementById('pitControls');
  const fliesControls = document.getElementById('fliesControls');
  const weightlessControls = document.getElementById('weightlessControls');
  const gravityPitSlider = document.getElementById('gravityPitSlider');
  const gravityPitVal = document.getElementById('gravityPitVal');
  const repellerEnabledPitEl = document.getElementById('repellerEnabledPit');
  const attractPowerSlider = document.getElementById('attractPowerSlider');
  const attractPowerVal = document.getElementById('attractPowerVal');
  const orbitRadiusSlider = document.getElementById('orbitRadiusSlider');
  const orbitRadiusVal = document.getElementById('orbitRadiusVal');
  const swarmSpeedSlider = document.getElementById('swarmSpeedSlider');
  const swarmSpeedVal = document.getElementById('swarmSpeedVal');
  
  // Weightless controls
  const weightlessCountSlider = document.getElementById('weightlessCountSlider');
  const weightlessCountVal = document.getElementById('weightlessCountVal');
  const weightlessSpeedSlider = document.getElementById('weightlessSpeedSlider');
  const weightlessSpeedVal = document.getElementById('weightlessSpeedVal');
  const weightlessBounceSlider = document.getElementById('weightlessBounceSlider');
  const weightlessBounceVal = document.getElementById('weightlessBounceVal');
  const weightlessRepelSlider = document.getElementById('weightlessRepelSlider');
  const weightlessRepelVal = document.getElementById('weightlessRepelVal');
  const weightlessRepelRadiusSlider = document.getElementById('weightlessRepelRadiusSlider');
  const weightlessRepelRadiusVal = document.getElementById('weightlessRepelRadiusVal');

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PROFESSIONAL WEIGHTLESS SCENE INITIALIZATION
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  // Initialize flies in idle swarm at viewport center
  function initializeFliesScene() {
    balls.length = 0;
    
    const targetBalls = 60; // Good swarm size for flies
    const w = canvas.width;
    const h = canvas.height;
    const centerX = w * 0.5;
    const centerY = h * 0.5;
    
    // Spawn flies in a loose cluster at center with randomized positions
    const swarmRadius = 150 * DPR; // Initial spread radius
    
    for (let i = 0; i < targetBalls; i++) {
      // Random position within swarm radius from center
      const angle = Math.random() * Math.PI * 2;
      const distance = Math.random() * swarmRadius;
      const x = centerX + Math.cos(angle) * distance;
      const y = centerY + Math.sin(angle) * distance;
      
      const ball = spawnBall(x, y);
      
      // Initial erratic velocity (flies are already moving in idle state)
      const speedVariation = 0.5 + Math.random() * 0.5;
      const vAngle = Math.random() * Math.PI * 2;
      const speed = 300 * speedVariation; // Moderate initial speed
      ball.vx = Math.cos(vAngle) * speed;
      ball.vy = Math.sin(vAngle) * speed;
      ball.driftAx = 0;
      ball.driftTime = 0;
    }
  }

  function initializeWeightlessScene() {
    balls.length = 0;
    
    // Fixed count from UI control
    const targetBalls = weightlessCount;
    const w = canvas.width;
    const h = canvas.height;
    
    // Grid distribution
    const aspectRatio = w / h;
    const cols = Math.ceil(Math.sqrt(targetBalls * aspectRatio));
    const rows = Math.ceil(targetBalls / cols);
    
    const marginX = 40;
    const marginY = 40;
    const spacingX = (w - 2 * marginX) / Math.max(1, cols - 1);
    const spacingY = (h - 2 * marginY) / Math.max(1, rows - 1);
    
    const positions = [];
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        if (positions.length >= targetBalls) break;
        
        const x = marginX + col * spacingX;
        const y = marginY + row * spacingY;
        
        // Subtle jitter
        const jitterX = (Math.random() - 0.5) * spacingX * 0.25;
        const jitterY = (Math.random() - 0.5) * spacingY * 0.25;
        
        positions.push({
          x: Math.max(20, Math.min(w - 20, x + jitterX)),
          y: Math.max(20, Math.min(h - 20, y + jitterY))
        });
      }
    }
    
    // Spawn balls with random velocities
    for (const pos of positions) {
      const ball = spawnBall(pos.x, pos.y);
      const angle = Math.random() * Math.PI * 2;
      const speed = weightlessInitialSpeed * (0.7 + Math.random() * 0.3);
      ball.vx = Math.cos(angle) * speed;
      ball.vy = Math.sin(angle) * speed;
      ball.driftAx = 0;
      ball.driftTime = 0;
    }
  }

  function updateModeControlsUI() {
    if (pitControls) pitControls.classList.toggle('active', currentMode === MODES.PIT);
    if (fliesControls) fliesControls.classList.toggle('active', currentMode === MODES.FLIES);
    if (weightlessControls) weightlessControls.classList.toggle('active', currentMode === MODES.WEIGHTLESS);
    modeButtons.forEach(btn => btn.classList.toggle('active', btn.getAttribute('data-mode') === currentMode));
  }

  function setMode(mode) {
    currentMode = mode;
    
    // Update container CSS class for mode-specific styling (canvas height)
    container.className = ''; // Clear all mode classes
    if (currentMode === MODES.PIT) {
      container.classList.add('mode-pit'); // 150vh height
    }
    // Other modes use default 100svh (no class needed)
    
    // Resize canvas to match new mode's height
    resize();
    
    // Apply per-mode high-level toggles and initialization
    if (currentMode === MODES.PIT) {
      gravityMultiplier = gravityMultiplierPit;
      G = GE * gravityMultiplier;
      repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0);
      EMITTER_SWEEP_ENABLED = true;
      // Reset scene when entering Ball Pit
      balls.length = 0;
      emitterTimer = 0;
      // Reset ball sizes to global
      resetBallSizeToGlobal();
    } else if (currentMode === MODES.FLIES) {
      gravityMultiplier = 0.0; // no gravity
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
      // Initialize flies scene with idle swarm at center
      initializeFliesScene();
      // Reset ball sizes to global (after initialization)
      resetBallSizeToGlobal();
    } else if (currentMode === MODES.WEIGHTLESS) {
      gravityMultiplier = 0.0; // zero gravity (weightless)
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
      // Initialize weightless scene with even distribution
      initializeWeightlessScene();
      // Reset ball sizes to global (after initialization)
      resetBallSizeToGlobal();
    }
    updateModeControlsUI();
  }

  // Hook up UI listeners (with auto-save on changes)
  modeButtons.forEach(btn => btn.addEventListener('click', () => {
    setMode(btn.getAttribute('data-mode'));
    // Note: resetBallSizeToGlobal() is now called inside setMode() for each mode
    autoSaveSettings();
  }));
  gravityPitSlider && gravityPitSlider.addEventListener('input', () => {
    gravityMultiplierPit = parseFloat(gravityPitSlider.value);
    gravityPitVal && (gravityPitVal.textContent = gravityMultiplierPit.toFixed(1));
    autoSaveSettings();
    if (currentMode === MODES.PIT) { gravityMultiplier = gravityMultiplierPit; G = GE * gravityMultiplier; }
  });
  
  // Mode-specific weight controls
  weightPitSlider && weightPitSlider.addEventListener('input', () => {
    ballMassKg = parseFloat(weightPitSlider.value);
    weightPitVal && (weightPitVal.textContent = ballMassKg.toFixed(2));
    // Apply shared mass to all balls
    for (let i=0; i<balls.length; i++) {
      balls[i].m = ballMassKg;
    }
    // Recompute derived scaling so gravity visibly changes with weight
    recomputeMassDerivedScales();
    autoSaveSettings();
  });
  repellerEnabledPitEl && repellerEnabledPitEl.addEventListener('change', () => {
    repellerEnabledPit = !!repellerEnabledPitEl.checked;
    if (currentMode === MODES.PIT) repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0);
  });
  attractPowerSlider && attractPowerSlider.addEventListener('input', () => {
    attractionPower = parseFloat(attractPowerSlider.value);
    attractPowerVal && (attractPowerVal.textContent = Math.round(attractionPower).toString());
  });
  orbitRadiusSlider && orbitRadiusSlider.addEventListener('input', () => {
    orbitRadius = parseFloat(orbitRadiusSlider.value);
    orbitRadiusVal && (orbitRadiusVal.textContent = Math.round(orbitRadius).toString());
  });
  swarmSpeedSlider && swarmSpeedSlider.addEventListener('input', () => {
    swarmSpeed = parseFloat(swarmSpeedSlider.value);
    swarmSpeedVal && (swarmSpeedVal.textContent = swarmSpeed.toFixed(1));
  });
  
  // Weightless controls
  weightlessCountSlider && weightlessCountSlider.addEventListener('input', () => {
    weightlessCount = parseInt(weightlessCountSlider.value, 10);
    weightlessCountVal && (weightlessCountVal.textContent = weightlessCount.toString());
    if (currentMode === MODES.WEIGHTLESS) initializeWeightlessScene();
  });
  weightlessSpeedSlider && weightlessSpeedSlider.addEventListener('input', () => {
    weightlessInitialSpeed = parseFloat(weightlessSpeedSlider.value);
    weightlessSpeedVal && (weightlessSpeedVal.textContent = Math.round(weightlessInitialSpeed).toString());
  });
  weightlessBounceSlider && weightlessBounceSlider.addEventListener('input', () => {
    weightlessBounce = parseFloat(weightlessBounceSlider.value);
    weightlessBounceVal && (weightlessBounceVal.textContent = weightlessBounce.toFixed(2));
  });
  weightlessRepelSlider && weightlessRepelSlider.addEventListener('input', () => {
    weightlessRepellerPower = parseFloat(weightlessRepelSlider.value);
    weightlessRepelVal && (weightlessRepelVal.textContent = Math.round(weightlessRepellerPower).toString());
    autoSaveSettings();
  });
  weightlessRepelRadiusSlider && weightlessRepelRadiusSlider.addEventListener('input', () => {
    weightlessRepellerRadius = parseFloat(weightlessRepelRadiusSlider.value);
    weightlessRepelRadiusVal && (weightlessRepelRadiusVal.textContent = Math.round(weightlessRepellerRadius).toString());
    autoSaveSettings();
  });

  // Individual color picker listeners (with existing ball color update)
  function updateExistingBallColors() {
    // Update colors of existing balls to use new color palette
    for (let i = 0; i < balls.length; i++) {
      balls[i].color = pickRandomColor();
    }
  }
  
  color1 && color1.addEventListener('input', () => { currentColors[0] = color1.value; color1Val && (color1Val.textContent = color1.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color2 && color2.addEventListener('input', () => { currentColors[1] = color2.value; color2Val && (color2Val.textContent = color2.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color3 && color3.addEventListener('input', () => { currentColors[2] = color3.value; color3Val && (color3Val.textContent = color3.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color4 && color4.addEventListener('input', () => { currentColors[3] = color4.value; color4Val && (color4Val.textContent = color4.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color5 && color5.addEventListener('input', () => { currentColors[4] = color5.value; color5Val && (color5Val.textContent = color5.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color6 && color6.addEventListener('input', () => { currentColors[5] = color6.value; color6Val && (color6Val.textContent = color6.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color7 && color7.addEventListener('input', () => { currentColors[6] = color7.value; color7Val && (color7Val.textContent = color7.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color8 && color8.addEventListener('input', () => { currentColors[7] = color8.value; color8Val && (color8Val.textContent = color8.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  cursorColorSelect && cursorColorSelect.addEventListener('change', () => { const idx = Math.max(1, Math.min(8, parseInt(cursorColorSelect.value, 10))) - 1; cursorBallIndex = idx; cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor; });

  // Bind click-to-copy on hex badges
  bindCopyOnClick(color1Val, () => color1.value.toUpperCase());
  bindCopyOnClick(color2Val, () => color2.value.toUpperCase());
  bindCopyOnClick(color3Val, () => color3.value.toUpperCase());
  bindCopyOnClick(color4Val, () => color4.value.toUpperCase());
  bindCopyOnClick(color5Val, () => color5.value.toUpperCase());
  bindCopyOnClick(color6Val, () => color6.value.toUpperCase());
  bindCopyOnClick(color7Val, () => color7.value.toUpperCase());
  bindCopyOnClick(color8Val, () => color8.value.toUpperCase());
  // If the user changes any color, keep the cursor color stable unless it was the one changed
  // To keep behavior simple, we do not auto-switch the cursor color here.
  
  // Scene control event listeners
  cornerRadiusSlider && cornerRadiusSlider.addEventListener('input', () => { 
    cornerRadius = parseFloat(cornerRadiusSlider.value); 
    cornerRadiusVal && (cornerRadiusVal.textContent = cornerRadius.toFixed(0)); 
  });
  motionBlurFadeSlider && motionBlurFadeSlider.addEventListener('input', () => { 
    motionBlurFade = parseFloat(motionBlurFadeSlider.value); 
    motionBlurFadeVal && (motionBlurFadeVal.textContent = motionBlurFade.toFixed(3)); 
  });
  trailSubtletySlider && trailSubtletySlider.addEventListener('input', () => {
    trailSubtlety = parseFloat(trailSubtletySlider.value);
    trailSubtletyVal && (trailSubtletyVal.textContent = trailSubtlety.toFixed(2) + 'Ã—');
  });

  // Presets (10 each)
  // Rubber-focused physics presets under Earth gravity (â‰ˆ1960 px/sÂ²)
  const PHYSICS_PRESETS = {
    rubberPlayground: { label: 'Rubber â€“ Playground', G: 1960, REST: 0.90, FRICTION: 0.0025, sizeScale: 1.8, maxBalls: 450, sizeVariation: 0.20 },
    rubberRacquet:    { label: 'Rubber â€“ Racquetball', G: 3320, REST: 0.97, FRICTION: 0.0035, sizeScale: 0.7, maxBalls: 350, sizeVariation: 0.30 },
    rubberSuperball:  { label: 'Rubber â€“ Superball', G: 1960, REST: 0.95, FRICTION: 0.0015, sizeScale: 1.2, maxBalls: 450, sizeVariation: 0.05 },
    rubberSoft:       { label: 'Rubber â€“ Soft', G: 1960, REST: 0.86, FRICTION: 0.0035, sizeScale: 2.2, maxBalls: 350, sizeVariation: 0.25 },
    rubberHeavy:      { label: 'Rubber â€“ Heavy', G: 1960, REST: 0.88, FRICTION: 0.0030, sizeScale: 2.0, maxBalls: 400, sizeVariation: 0.15 }
  };

  const SPAWN_PRESETS = {
    fullRain:       { label: 'Full Rain (top-half)', EMIT_INTERVAL: 0.030, xCenter: 50, y: -50, w: 100, h: 50 },
    narrowStrip:    { label: 'Narrow Strip Top', EMIT_INTERVAL: 0.050, xCenter: 50, y: -40, w: 20,  h: 10 },
    leftGutter:     { label: 'Left Gutter', EMIT_INTERVAL: 0.045, xCenter: 10, y: -60, w: 18,  h: 20 },
    rightGutter:    { label: 'Right Gutter', EMIT_INTERVAL: 0.045, xCenter: 90, y: -60, w: 18,  h: 20 },
    centerFountain: { label: 'Center Fountain', EMIT_INTERVAL: 0.020, xCenter: 50, y: -30, w: 30,  h: 20 },
    stormBurst:     { label: 'Storm Burst', EMIT_INTERVAL: 0.005, xCenter: 50, y: -80, w: 100, h: 30 },
    slowSnow:       { label: 'Slow Snow', EMIT_INTERVAL: 0.200, xCenter: 50, y: -30, w: 100, h: 20 },
    edgeDrizzle:    { label: 'Edge Drizzle', EMIT_INTERVAL: 0.080, xCenter: 15, y: -40, w: 30,  h: 15 },
    twinColumns:    { label: 'Twin Columns', EMIT_INTERVAL: 0.030, xCenter: 30, y: -50, w: 10,  h: 40 },
    focusedBeam:    { label: 'Focused Beam', EMIT_INTERVAL: 0.015, xCenter: 50, y: -70, w: 6,   h: 12 }
  };

  const REPELLER_PRESETS = {
    off:         { label: 'Off', r: 710,   p: 27400 * 10, s: 4.4 },
    gentle:      { label: 'Gentle Breeze', r: 120, p: 2500, s: 2.5 },
    pushField:   { label: 'Push Field', r: 240, p: 8000 * 10, s: 2.0 },
    tractor:     { label: 'Tractor Push', r: 320, p: 14000 * 10, s: 1.6 },
    magnet:      { label: 'Magnet Repel', r: 200, p: 18000 * 10, s: 3.0 },
    pulse:       { label: 'Pulse Strong', r: 280, p: 22000 * 10, s: 1.2 },
    wideSoft:    { label: 'Wide Soft', r: 500, p: 8000 * 10, s: 4.5 },
    needle:      { label: 'Needle Point', r: 80,  p: 26000 * 10, s: 0.8 },
    wall:        { label: 'Invisible Wall', r: 700, p: 16000 * 10, s: 5.0 },
    singularity: { label: 'Singularity', r: 600, p: 30000 * 10, s: 0.5 }
  };

  // Shadow presets removed for better performance


  // Populate selects
  function fillSelect(select, dict, selectedKey) {
    select.innerHTML = '';
    for (const [key, val] of Object.entries(dict)) {
      const opt = document.createElement('option');
      opt.value = key; opt.textContent = val.label || key; if (key === selectedKey) opt.selected = true;
      select.appendChild(opt);
    }
  }

  const physicsSelect = document.getElementById('physicsSelect');
  const spawnSelect = document.getElementById('spawnSelect');
  const repellerSelect = document.getElementById('repellerSelect');

  if (physicsSelect) fillSelect(physicsSelect, PHYSICS_PRESETS, 'rubberRacquet');
  if (spawnSelect) fillSelect(spawnSelect, SPAWN_PRESETS, 'fullRain');
  if (repellerSelect) fillSelect(repellerSelect, REPELLER_PRESETS, 'off');
  // Populate color template dropdown
  if (colorSelect) fillSelect(colorSelect, COLOR_TEMPLATES, 'industrialTeal');

  // Helper function for UI updates
  function updateSliderAndValue(slider, valueElement, value, decimals = 0) {
    if (slider) slider.value = String(value);
    if (valueElement) valueElement.textContent = decimals > 0 ? value.toFixed(decimals) : value.toString();
  }

  // Reusable event listener factory for sliders
  // Removed unused slider listener factory

  // Apply preset helpers
  function applyPhysicsPreset(key) {
    const p = PHYSICS_PRESETS[key]; if (!p) return;
    // Keep gravity constant (1.1x Earth). Only apply REST and FRICTION from preset.
    REST = p.REST; FRICTION = p.FRICTION;
    MAX_BALLS = p.maxBalls; sizeVariation = p.sizeVariation;
    const newScale = p.sizeScale;
    sizeScale = newScale;
    // Recompute effective scale and proportionally resize existing balls
    updateEffectiveScaleAndBallSizes();
    // Apply mass (Rainbow balls maintain 5x multiplier)
    for (let i=0; i<balls.length; i++) {
      if (currentMode === MODES.BOULDERS) {
        balls[i].m = ballMassKg * 5;
      } else {
        balls[i].m = ballMassKg;
      }
    }
    
    // Remove excess balls if new limit is lower (truncate efficiently)
    if (balls.length > MAX_BALLS) { balls.length = MAX_BALLS; }
    
    // Update UI efficiently (gravity is fixed; no slider to update)
    updateSliderAndValue(restitutionSlider, restitutionVal, REST, 2);
    updateSliderAndValue(frictionSlider, frictionVal, FRICTION, 4);
    updateSliderAndValue(sizeSliderGlobal, sizeValGlobal, sizeScale, 1);
    updateSliderAndValue(maxBallsSlider, maxBallsVal, MAX_BALLS, 0);
    updateSliderAndValue(sizeVariationSliderGlobal, sizeVariationValGlobal, sizeVariation, 1);
    
    // Apply the new size variation to existing balls
    updateExistingBallSizes();
  }
  function applySpawnPreset(key) {
    const s = SPAWN_PRESETS[key]; if (!s) return;
    EMIT_INTERVAL = s.EMIT_INTERVAL; SPAWN_X_CENTER_VW = s.xCenter; SPAWN_Y_VH = s.y; SPAWN_W_VW = s.w; SPAWN_H_VH = s.h;
    updateSliderAndValue(emitterSlider, emitterVal, EMIT_INTERVAL, 3);
    updateSliderAndValue(spawnCenterSlider, spawnCenterVal, SPAWN_X_CENTER_VW, 0);
    updateSliderAndValue(spawnYSlider, spawnYVal, SPAWN_Y_VH, 0);
    updateSliderAndValue(spawnWidthSlider, spawnWidthVal, SPAWN_W_VW, 0);
    updateSliderAndValue(spawnHeightSlider, spawnHeightVal, SPAWN_H_VH, 0);
  }
  function applyRepellerPreset(key) {
    const r = REPELLER_PRESETS[key]; if (!r) return;
    repelRadius = r.r; repelPower = r.p * (REPELLER_GLOBAL_MULTIPLIER / 20.0); // keep perceived strength consistent after global doubling
    repellerEnabled = (key !== 'off');
    updateSliderAndValue(repelSizeSlider, repelSizeVal, repelRadius, 0);
    // Sync slider to mapped power and label
    const sliderPos = powerToRepelSlider(repelPower);
    if (repelPowerSlider) repelPowerSlider.value = String(sliderPos);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    updateSliderAndValue(repelSoftSlider, repelSoftVal, repelSoft, 1);
  }
  // Shadow preset function removed

  // Apply sane defaults FIRST (before event listeners to avoid triggering them)
  applyPhysicsPreset('rubberRacquet');
  applySpawnPreset('fullRain');
  applyRepellerPreset('off');
  
  // Initialize color system
  const defaultTemplate = COLOR_TEMPLATES[currentTemplate];
  if (color1 && color1Val) { color1.value = defaultTemplate.colors[0]; color1Val.textContent = defaultTemplate.colors[0].toUpperCase(); }
  if (color2 && color2Val) { color2.value = defaultTemplate.colors[1]; color2Val.textContent = defaultTemplate.colors[1].toUpperCase(); }
  if (color3 && color3Val) { color3.value = defaultTemplate.colors[2]; color3Val.textContent = defaultTemplate.colors[2].toUpperCase(); }
  if (color4 && color4Val) { color4.value = defaultTemplate.colors[3]; color4Val.textContent = defaultTemplate.colors[3].toUpperCase(); }
  if (color5 && color5Val) { color5.value = defaultTemplate.colors[4]; color5Val.textContent = defaultTemplate.colors[4].toUpperCase(); }
  if (color6 && color6Val) { color6.value = defaultTemplate.colors[5]; color6Val.textContent = defaultTemplate.colors[5].toUpperCase(); }
  if (color7 && color7Val) { color7.value = defaultTemplate.colors[6]; color7Val.textContent = defaultTemplate.colors[6].toUpperCase(); }
  if (color8 && color8Val) { color8.value = defaultTemplate.colors[7]; color8Val.textContent = defaultTemplate.colors[7].toUpperCase(); }
  // Sync CSS variables on init
  syncPaletteVars(defaultTemplate.colors);

  // Hook presets to selects AFTER applying defaults
  physicsSelect && physicsSelect.addEventListener('change', () => applyPhysicsPreset(physicsSelect.value));
  spawnSelect && spawnSelect.addEventListener('change', () => applySpawnPreset(spawnSelect.value));
  repellerSelect && repellerSelect.addEventListener('change', () => applyRepellerPreset(repellerSelect.value));

  // Now that sizeScale is set by presets, compute responsive scale once
  updateEffectiveScaleAndBallSizes();
  
  // Initialize text colliders
  updateTextColliders();
  
  // Load saved settings from localStorage
  const settingsLoaded = loadSettings();
  
  // Apply device-specific mode visibility (hide Trail on mobile)
  applyDeviceSpecificModeVisibility();
  
  // Initialize mode (use saved mode or default to Ball Pit)
  setMode(currentMode);
  
  // Save settings on mode change or slider change
  window.addEventListener('beforeunload', saveSettings);
})();
</script>
</body>
</html>
