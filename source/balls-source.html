<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Refined Bravia Balls ‚Äì Canvas Physics</title>
<style>
  html, body { height: 100%; margin: 0; background: #cecece; overflow:hidden; }
  /* Scoped wrapper for embed friendliness and interaction hygiene */
  #bravia-balls {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 150vh;
    overscroll-behavior: contain;
    -webkit-tap-highlight-color: transparent;
    user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
  }
  #bravia-balls canvas { 
    display: block; 
    width: 100%; 
    height: 150vh;
    position: absolute;
    bottom: 0;
    left: 0;
    -webkit-user-drag: none;
    user-select: none; 
    -webkit-user-select: none;
    touch-action: none;
    cursor: none;
  }
  @media (prefers-reduced-motion: reduce) { 
    #bravia-balls canvas { filter: none; } 
  }
  #bravia-balls .panel {
    position: fixed;
    top: 5vh;
    right: 5vh;
    color: #fff;
    font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    background: rgba(0,0,0,0.45);
    padding: 10px;
    border-radius: 8px;
    user-select: none;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 10;
    max-height: 90vh;
    overflow: auto;
    backdrop-filter: blur(6px);
  }
  #bravia-balls .panel.hidden { display: none; }
  #bravia-balls .panel label {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 6px;
    width: 260px;
  }
  #bravia-balls .panel input[type="range"] {
    flex: 1;
  }
  #bravia-balls .panel span.val {
    width: 56px;
    text-align: right;
    font-family: monospace;
  }
  #bravia-balls .panel span.hex-val {
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    font-size: 10px;
    color: #888;
    background: rgba(0,0,0,0.05);
    padding: 1px 4px;
    border-radius: 2px;
    margin-left: 4px;
    text-transform: uppercase;
    cursor: pointer;
  }
  #bravia-balls .panel code {
    font-family: monospace;
    background: rgba(255,255,255,0.1);
    padding: 2px 4px;
    border-radius: 4px;
  }
  #bravia-balls .panel details { background: rgba(255,255,255,0.04); border-radius: 6px; padding: 6px; }
  #bravia-balls .panel summary { cursor: pointer; list-style: none; outline: none; }
  #bravia-balls .panel summary::-webkit-details-marker { display: none; }
  #bravia-balls .panel summary { display:flex; align-items:center; justify-content:space-between; color:#b8c2c7; }
  #bravia-balls .panel .group { display:flex; flex-direction:column; gap:6px; margin-top:6px; }
  
  /* Mode switcher - segmented control */
  #bravia-balls .mode-switcher {
    display: flex;
    background: rgba(0,0,0,0.3);
    border-radius: 6px;
    padding: 2px;
    gap: 2px;
    margin-bottom: 8px;
  }
  #bravia-balls .mode-button {
    flex: 1;
    padding: 8px 12px;
    background: transparent;
    border: none;
    border-radius: 4px;
    color: rgba(255,255,255,0.6);
    font-size: 11px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
  }
  #bravia-balls .mode-button:hover {
    background: rgba(255,255,255,0.05);
    color: rgba(255,255,255,0.8);
  }
  #bravia-balls .mode-button.active {
    background: rgba(255,255,255,0.15);
    color: #ffffff;
    font-weight: 600;
  }
  #bravia-balls .mode-controls { display: none; }
  #bravia-balls .mode-controls.active { display: block; }
  
  /* Palette variables (defaults match 'industrialTeal') */
  :root {
    --ball-1: #b7bcb7;
    --ball-2: #e4e9e4;
    --ball-3: #ffffff;
    --ball-4: #00695c;
    --ball-5: #000000;
    --ball-6: #ff4013;
    --ball-7: #0d5cb6;
    --ball-8: #ffa000;
  }
  /* Utility classes for using the palette elsewhere on the page */
  .text-ball-1 { color: var(--ball-1); }
  .text-ball-2 { color: var(--ball-2); }
  .text-ball-3 { color: var(--ball-3); }
  .text-ball-4 { color: var(--ball-4); }
  .text-ball-5 { color: var(--ball-5); }
  .text-ball-6 { color: var(--ball-6); }
  .text-ball-7 { color: var(--ball-7); }
  .text-ball-8 { color: var(--ball-8); }
  .bg-ball-1 { background-color: var(--ball-1); }
  .bg-ball-2 { background-color: var(--ball-2); }
  .bg-ball-3 { background-color: var(--ball-3); }
  .bg-ball-4 { background-color: var(--ball-4); }
  .bg-ball-5 { background-color: var(--ball-5); }
  .bg-ball-6 { background-color: var(--ball-6); }
  .bg-ball-7 { background-color: var(--ball-7); }
  .bg-ball-8 { background-color: var(--ball-8); }
  .border-ball-1 { border-color: var(--ball-1); }
  .border-ball-2 { border-color: var(--ball-2); }
  .border-ball-3 { border-color: var(--ball-3); }
  .border-ball-4 { border-color: var(--ball-4); }
  .border-ball-5 { border-color: var(--ball-5); }
  .border-ball-6 { border-color: var(--ball-6); }
  .border-ball-7 { border-color: var(--ball-7); }
  .border-ball-8 { border-color: var(--ball-8); }
</style>
</head>
<body>
<div id="bravia-balls">
  <canvas id="c" aria-label="Bouncy balls simulation" role="img" draggable="false"></canvas>
  <div class="panel" id="controlPanel">
  
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- GLOBAL SETTINGS (apply to ALL modes) - ABOVE MODE SWITCHER             -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  
  <details open>
    <summary>üåê Global Ball Properties</summary>
    <div class="group">
        <label>Size: <span class="val" id="sizeValGlobal">0.75</span><input type="range" id="sizeSliderGlobal" min="0.1" max="6.0" step="0.05" value="0.75"></label>
        <label>Size variation: <span class="val" id="sizeVariationValGlobal">1.0</span><input type="range" id="sizeVariationSliderGlobal" min="0.0" max="3.0" step="0.1" value="1.0"></label>
        <label>Softness: <span class="val" id="ballSoftnessValGlobal">40</span><input type="range" id="ballSoftnessSliderGlobal" min="0" max="100" step="1" value="40"></label>
        <div style="font-size: 9px; opacity: 0.7; margin-top: 4px;">Softness: 0 = hard, 40 = normal, 100 = very squishy</div>
    </div>
  </details>
  
  <!-- Mode Switcher -->
  <div class="mode-switcher">
    <button class="mode-button active" data-mode="pit">üéØ Pit</button>
    <button class="mode-button" data-mode="flies">üïäÔ∏è Flies</button>
    <button class="mode-button" data-mode="trail" id="trailModeButton">üñ±Ô∏è Trail</button>
    <button class="mode-button" data-mode="weightless">üåå Zero-G</button>
    <button class="mode-button" data-mode="rainbow">üåà Rainbow</button>
  </div>
  
  <!-- Build Controls -->
  <div style="margin-bottom: 12px; padding: 8px; background: rgba(0,255,0,0.1); border-radius: 4px; text-align: center;">
    <button id="saveConfigBtn" style="background: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold; margin-right: 8px;">üíæ Save Config</button>
    <button id="buildBtn" style="background: #2196F3; color: white; border: none; padding: 8px 16px; border-radius: 4px; cursor: pointer; font-weight: bold;">üöÄ Build Embed</button>
    <div id="configOutput" style="margin-top: 8px; font-family: monospace; font-size: 10px; color: #333; max-height: 120px; overflow-y: auto; display: none; text-align: left; background: rgba(255,255,255,0.8); padding: 6px; border-radius: 3px;"></div>
  </div>
  
  <details open>
    <summary>üé® Colors</summary>
    <div class="group">
        <label>Color template: <select id="colorSelect"></select></label>
        <label>Color 1 (50%): <input type="color" id="color1" value="#ffffff"> <span class="hex-val" id="color1Val">#ffffff</span></label>
        <label>Color 2 (25%): <input type="color" id="color2" value="#f8f9fa"> <span class="hex-val" id="color2Val">#f8f9fa</span></label>
        <label>Color 3 (12%): <input type="color" id="color3" value="#e9ecef"> <span class="hex-val" id="color3Val">#e9ecef</span></label>
        <label>Color 4 (6%): <input type="color" id="color4" value="#d90429"> <span class="hex-val" id="color4Val">#d90429</span></label>
        <label>Color 5 (3%): <input type="color" id="color5" value="#000000"> <span class="hex-val" id="color5Val">#000000</span></label>
        <label>Color 6 (2%): <input type="color" id="color6" value="#54d4ff"> <span class="hex-val" id="color6Val">#54d4ff</span></label>
        <label>Color 7 (1%): <input type="color" id="color7" value="#b589ff"> <span class="hex-val" id="color7Val">#b589ff</span></label>
        <label>Color 8 (1%): <input type="color" id="color8" value="#ffc27a"> <span class="hex-val" id="color8Val">#ffc27a</span></label>
        <label>Cursor color:
          <select id="cursorColorSelect">
            <option value="1">Color 1</option>
            <option value="2">Color 2</option>
            <option value="3">Color 3</option>
            <option value="4">Color 4</option>
            <option value="5">Color 5</option>
            <option value="6" selected>Color 6 (highlight)</option>
            <option value="7">Color 7</option>
            <option value="8">Color 8</option>
          </select>
        </label>
        <div style="font-size: 9px; opacity: 0.7; margin-top: 4px;">Colors appear by weight: 1 is most common, 8 is rarest</div>
    </div>
  </details>
  
  <details>
    <summary>üñºÔ∏è Scene & Effects</summary>
    <div class="group">
        <label>Max balls: <span class="val" id="maxBallsVal">800</span><input type="range" id="maxBallsSlider" min="50" max="2000" step="25" value="800"></label>
        <label>Corner radius (px): <span class="val" id="cornerRadiusVal">0</span><input type="range" id="cornerRadiusSlider" min="0" max="200" step="5" value="0"></label>
        <label>Motion blur: <span class="val" id="trailFadeVal">0.000</span><input type="range" id="trailFadeSlider" min="0.000" max="1.500" step="0.001" value="0.000"></label>
        <label>Blur intensity: <span class="val" id="trailSubtletyVal">1.00√ó</span><input type="range" id="trailSubtletySlider" min="0.00" max="3.00" step="0.05" value="1.00"></label>
    </div>
  </details>
  
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  <!-- MODE-SPECIFIC SETTINGS (only apply to active mode)                     -->
  <!-- ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê -->
  
  <div id="pitControls" class="mode-controls active">
    <details open>
      <summary>üéØ Ball Pit Mode</summary>
      <div class="group">
        <label>Physics template: <select id="physicsSelect"></select></label>
        <label>Gravity: <span class="val" id="gravityPitVal">1.1</span><input type="range" id="gravityPitSlider" min="0.0" max="3.0" step="0.1" value="1.1"></label>
        <label>Weight (kg): <span class="val" id="weightPitVal">11.20</span><input type="range" id="weightPitSlider" min="0.10" max="200.00" step="0.10" value="11.20"></label>
        <label>Bounciness: <span class="val" id="restitutionVal">0.78</span><input type="range" id="restitutionSlider" min="0.00" max="1.00" step="0.001" value="0.78"></label>
        <label>Friction: <span class="val" id="frictionVal">0.0025</span><input type="range" id="frictionSlider" min="0.000" max="0.250" step="0.0005" value="0.0025"></label>
      </div>
    </details>
    <details open>
      <summary>üéØ Spawn Settings</summary>
      <div class="group">
        <label>Spawn template: <select id="spawnSelect"></select></label>
        <label>Emit interval (s): <span class="val" id="emitterVal">0.04</span><input type="range" id="emitterSlider" min="0.000" max="1.000" step="0.005" value="0.04"></label>
        <label>Spawn Y (vh): <span class="val" id="spawnYVal">-50</span><input type="range" id="spawnYSlider" min="-100" max="100" step="10" value="-50"></label>
        <label>Spawn Width (vw): <span class="val" id="spawnWidthVal">100</span><input type="range" id="spawnWidthSlider" min="0" max="100" step="10" value="100"></label>
        <label>Spawn X Center (vw): <span class="val" id="spawnCenterVal">50</span><input type="range" id="spawnCenterSlider" min="0" max="100" step="10" value="50"></label>
        <label>Spawn Height (vh): <span class="val" id="spawnHeightVal">50</span><input type="range" id="spawnHeightSlider" min="0" max="100" step="10" value="50"></label>
      </div>
    </details>
    <details open>
      <summary>üß≤ Mouse Repeller</summary>
      <div class="group">
        <label>Repeller template: <select id="repellerSelect"></select></label>
        <label>Repeller active: <input type="checkbox" id="repellerEnabledPit" checked></label>
        <label>Repel size (px): <span class="val" id="repelSizeVal">200</span><input type="range" id="repelSizeSlider" min="0" max="1000" step="5" value="200"></label>
        <label>Repel power: <span class="val" id="repelPowerVal">24000</span><input type="range" id="repelPowerSlider" min="0" max="1000" step="1" value="500"></label>
        <label>Repel softness: <span class="val" id="repelSoftVal">2.0</span><input type="range" id="repelSoftSlider" min="0.1" max="8" step="0.1" value="2.0"></label>
      </div>
    </details>
  </div>
  
  <div id="fliesControls" class="mode-controls">
    <details open>
      <summary>üïäÔ∏è Flies to Light Mode</summary>
      <div class="group">
        <label>Attraction power: <span class="val" id="attractPowerVal">1000</span><input type="range" id="attractPowerSlider" min="1" max="3000" step="1" value="1000"></label>
        <label>Orbit radius (px): <span class="val" id="orbitRadiusVal">150</span><input type="range" id="orbitRadiusSlider" min="50" max="500" step="10" value="150"></label>
        <label>Swarm speed: <span class="val" id="swarmSpeedVal">1.0</span><input type="range" id="swarmSpeedSlider" min="0.1" max="3.0" step="0.1" value="1.0"></label>
      </div>
    </details>
  </div>
  
  <div id="trailControls" class="mode-controls">
    <details open>
      <summary>‚ú® Sparkle Trail Mode</summary>
      <div class="group">
        <label>Emission rate: <span class="val" id="sparkleEmissionVal">3</span><input type="range" id="sparkleEmissionSlider" min="1" max="30" step="1" value="3"></label>
        <label>Particle lifetime (s): <span class="val" id="sparkleLifetimeVal">1.5</span><input type="range" id="sparkleLifetimeSlider" min="0.5" max="9.0" step="0.1" value="1.5"></label>
        <label>Velocity spread: <span class="val" id="sparkleSpreadVal">100</span><input type="range" id="sparkleSpreadSlider" min="20" max="900" step="10" value="100"></label>
        <label>Drift strength: <span class="val" id="sparkleDriftVal">50</span><input type="range" id="sparkleDriftSlider" min="0" max="600" step="10" value="50"></label>
        <label>Particle scale: <span class="val" id="sparkleScaleVal">0.6</span><input type="range" id="sparkleScaleSlider" min="0.1" max="4.5" step="0.05" value="0.6"></label>
      </div>
    </details>
  </div>
  
  <div id="weightlessControls" class="mode-controls">
    <details open>
      <summary>üåå Weightless (Zero-G) Mode</summary>
      <div class="group">
        <label>Initial speed: <span class="val" id="weightlessSpeedVal">400</span><input type="range" id="weightlessSpeedSlider" min="50" max="1000" step="50" value="400"></label>
        <label>Weight (kg): <span class="val" id="weightWeightlessVal">11.20</span><input type="range" id="weightWeightlessSlider" min="0.10" max="200.00" step="0.10" value="11.20"></label>
        <label>Wall bounce: <span class="val" id="weightlessBounceVal">0.98</span><input type="range" id="weightlessBounceSlider" min="0.50" max="1.00" step="0.01" value="0.98"></label>
        <label>Ball count: <span class="val" id="weightlessMaxBallsVal">300</span><input type="range" id="weightlessMaxBallsSlider" min="50" max="600" step="25" value="300"></label>
        <label>Repeller power: <span class="val" id="weightlessRepelPowerVal">800</span><input type="range" id="weightlessRepelPowerSlider" min="0" max="2000" step="100" value="800"></label>
        <label>Repeller radius: <span class="val" id="weightlessRepelRadiusVal">120</span><input type="range" id="weightlessRepelRadiusSlider" min="0" max="300" step="10" value="120"></label>
      </div>
    </details>
  </div>
  
  <div id="rainbowControls" class="mode-controls">
    <details open>
      <summary>üåà Rainbow Drop Mode</summary>
      <div class="group">
        <label>Randomness: <span class="val" id="rainbowRandomnessVal">1.0</span><input type="range" id="rainbowRandomnessSlider" min="0.0" max="1.0" step="0.1" value="1.0"></label>
        <div style="font-size: 9px; opacity: 0.7; margin-top: 4px;">0 = equal size steps, 1 = random distribution</div>
        <label>Weight (kg): <span class="val" id="weightRainbowVal">11.20</span><input type="range" id="weightRainbowSlider" min="0.10" max="200.00" step="0.10" value="11.20"></label>
        <label>Drop delay (s): <span class="val" id="rainbowDropDelayVal">0.15</span><input type="range" id="rainbowDropDelaySlider" min="0.05" max="0.5" step="0.05" value="0.15"></label>
        <label>Gravity: <span class="val" id="rainbowGravityVal">1.2</span><input type="range" id="rainbowGravitySlider" min="0.5" max="3.0" step="0.1" value="1.2"></label>
        <label>Bounce: <span class="val" id="rainbowBounceVal">0.30</span><input type="range" id="rainbowBounceSlider" min="0.00" max="1.00" step="0.05" value="0.30"></label>
      </div>
    </details>
  </div>
  
    <div style="font-size:10px; opacity:0.8;">Press <code>R</code> to reset ‚Ä¢ <code>/</code> toggle panel ‚Ä¢ <code>1-5</code> switch modes</div>
  </div>
  
  <!-- FPS Counter -->
  <div id="fps-counter" style="position: fixed; top: 5vh; left: 5vh; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 4px; font-family: monospace; font-size: 12px; z-index: 1001; backdrop-filter: blur(6px); line-height: 1.4;">
    Render: <span id="render-fps">--</span> fps<br>
    Physics: <span id="physics-fps">--</span> fps<br>
  </div>
</div>
<script>
// Version: 2024-09-30 - Added 3-mode system (Ball Pit, Flies to Light, Mouse Trail)
(() => {
  // Behavior modes with device availability
  const MODES = {
    PIT: 'pit',          // Ball Pit: gravity + repeller
    FLIES: 'flies',      // Flies to Light: attraction to mouse, no gravity
    TRAIL: 'trail',      // Mouse Trail: static paint drops (DESKTOP ONLY)
    WEIGHTLESS: 'weightless',  // Weightless Bounce: zero-G bouncing balls
    RAINBOW: 'rainbow'   // Rainbow Drop: one ball per color falling with size distribution
  };
  
  // Mode availability by device type
  const MODE_AVAILABILITY = {
    [MODES.PIT]: { desktop: true, mobile: true },
    [MODES.FLIES]: { desktop: true, mobile: true },
    [MODES.TRAIL]: { desktop: true, mobile: false }, // Trail only on desktop (needs precise cursor)
    [MODES.WEIGHTLESS]: { desktop: true, mobile: true },
    [MODES.RAINBOW]: { desktop: true, mobile: true }
  };
  
  let currentMode = MODES.PIT;
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // GLOBAL PARAMETERS (apply to all modes)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  let ballSoftness = 40; // 0-100: controls squash/stretch on collision (0=hard, 100=very squishy)
  
  // Mode-specific parameters
  // Ball Pit mode parameters
  let gravityMultiplierPit = 1.1;
  let repellerEnabledPit = true;
  
  // Flies mode parameters
  let attractionPower = 1000; // Default attraction
  let orbitRadius = 150;
  let swarmSpeed = 1.0;
  
  // Trail (Sparkle) mode parameters
  let sparkleEmissionRate = 3; // particles per frame when moving
  let sparkleLifetime = 1.5; // seconds before fade complete
  let sparkleVelocitySpread = 100; // initial random velocity magnitude
  let sparkleDriftStrength = 50; // gentle floating motion
  let sparkleParticleScale = 0.6; // smaller than normal balls
  // Track only recent mouse samples to estimate velocity for sparkle emission
  let mouseTrail = []; // Array<{x:number,y:number,time:number}>
  const MAX_MOUSE_TRAIL_LENGTH = 6; // small buffer keeps calc cheap and responsive
  // Weightless mode parameters
  let weightlessInitialSpeed = 400; // initial velocity magnitude (px/s)
  let weightlessBounce = 0.98; // wall bounce restitution (very elastic)
  let weightlessMaxBalls = 300; // number of balls in scene
  let weightlessRepellerPower = 800; // subtle mouse repeller strength
  let weightlessRepellerRadius = 120; // small repeller radius (px)
  
  // Rainbow mode parameters
  let rainbowRandomness = 1.0; // randomness factor for size distribution (0 = equal steps, 1 = random)
  let rainbowDropDelay = 0.15; // delay between each color drop (seconds)
  let rainbowGravity = 1.2; // gravity multiplier for rainbow mode
  let rainbowBounce = 0.3; // bounce restitution for rainbow mode (lower for rock-like settling)
  
  // Mass constants (needed before CONSTANTS object)
  const MASS_BASELINE_KG = 1.0; // reference mass for scaling drag/forces
  
  // Constants for magic numbers
  const CONSTANTS = {
    CANVAS_HEIGHT_VH: 1.5,        // 150vh canvas height
    OFFSCREEN_MOUSE: -1e9,        // Offscreen mouse position
    MIN_DISTANCE_EPSILON: 1e-6,   // Minimum distance for collision calculations
    MIN_REPEL_DISTANCE: 1e-4,     // Minimum repeller distance
    ACCUMULATOR_RESET_THRESHOLD: 3, // Reset accumulator if behind by this many frames
    INITIAL_SEED_BALLS: 200,      // Initial balls to seed
    BALL_SPAWN_OFFSET: 2,         // Offset for ball spawning
    BALL_CLUSTER_SPACING: 8,      // Spacing between clustered balls
    BALL_CLUSTER_Y_OFFSET: 12,    // Y offset for clustered balls
    MAX_PHYSICS_STEPS: 2,         // Maximum physics steps per frame
    FPS_UPDATE_INTERVAL: 1.0,     // FPS counter update interval in seconds
    MIN_MOUSE_SPEED_FOR_TRAIL: 50, // Minimum mouse speed to emit trail particles
    SPARKLE_DRAG_COEFFICIENT: 0.98, // Drag coefficient for sparkle particles
    // Spin & squash tuning
    SPIN_DAMP_PER_S: 2.0,         // angular damping per second
    SPIN_GAIN: 0.25,              // how strongly tangential slip converts to spin
    SPIN_GAIN_TANGENT: 0.18,      // ball‚Äìball tangential slip to spin
    ROLL_FRICTION_PER_S: 1.5,     // rolling friction for horizontal speed per second when grounded
    SQUASH_MAX_BASE: 0.20,        // base maximum squash at softness=40 (moderate)
    SQUASH_DECAY_PER_S: 18.0,     // faster relaxation for snappy feel
    WALL_REST_VEL_THRESHOLD: 70,  // below this, wall bounce becomes inelastic (settles)
    GROUND_COUPLING_PER_S: 8.0    // match roll (vx) to spin (omega) when grounded
  };
  
  // Dynamic squash calculation based on ball softness (0-100)
  // 0 = completely hard (no deformation)
  // 40 = normal/default (0.20 squash)
  // 100 = very squishy (0.50 squash)
  function getSquashMax() {
    if (ballSoftness === 0) return 0; // Completely hard - no squash
    // Linear interpolation: softness 40 = base value (0.20)
    // softness 100 = 2.5√ó base (0.50)
    return CONSTANTS.SQUASH_MAX_BASE * (ballSoftness / 40.0);
  }

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  const panel = document.getElementById('controlPanel');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // Spawn area controls (viewport-relative)
  // Defaults: xCenter = 50vw, y = -50vh, width = 100vw, height = 50vh
  let SPAWN_X_CENTER_VW = 50;
  let SPAWN_Y_VH = -50;
  let SPAWN_W_VW = 100;
  let SPAWN_H_VH = 50;

  // Resize canvas to 150vh (with top 50vh hidden above viewport)
  function resize() {
    const simHeight = window.innerHeight * CONSTANTS.CANVAS_HEIGHT_VH;
    canvas.width  = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(simHeight * DPR);
  }
  const setCSSSize = () => {
    // CSS size is handled by CSS (150vh, bottom-aligned)
  };
  setCSSSize(); resize();
  window.addEventListener('resize', () => { setCSSSize(); resize(); updateEffectiveScaleAndBallSizes(); updateTextColliders(); });

  // Physics parameters (initial)
  const GE = 1960;        // Earth gravity in px/s^2 at our scale
  let gravityMultiplier = 1.10; // 1.1√ó Earth
  let G = GE * gravityMultiplier;
  let REST = 0.88;        // restitution (bounciness) - from screenshot
  let FRICTION = 0.0030;  // air drag per frame - from screenshot
  let EMIT_INTERVAL = 0.030; // seconds between drops - from screenshot
  let MAX_BALLS = 800;    // increased for better trail mode performance
  const SOLVER_ITERS = 6;    // Optimized for realistic collisions without jitter
  const POS_CORRECT_PERCENT = 0.8; // Reduced for more stable contacts
  const POS_CORRECT_SLOP = 0.5 * DPR; // Slightly more tolerance to prevent jitter
  const REST_VEL_THRESHOLD = 30; // Lower threshold for more realistic settling

  // Base radius values
  const R_MIN_BASE = 6;
  const R_MAX_BASE = 24;
  let sizeScale = 0.75;     // Global ball size (default per user request)
  let sizeVariation = 1.0; // Global size variation
  // Responsive scale: reduce ball size by 60% on mobile breakpoints (‚â§768px)
  let responsiveScale = 1.0;
  let lastEffectiveScale = null; // tracks previous (sizeScale * responsiveScale)
  // Global mass model: all balls share the same mass in kg
  let ballMassKg = 19.80; // from screenshot
  // Mass influence tuning
  const MASS_GRAVITY_EXP = 0.35; // how much mass influences gravity (perceptual)
  const MASS_REST_EXP = 0.15;    // how much mass influences bounce restitution
  let gravityScale = 1.0;        // computed from mass
  function recomputeMassDerivedScales() {
    gravityScale = Math.max(0.5, Math.min(3.0, Math.pow(ballMassKg / MASS_BASELINE_KG, MASS_GRAVITY_EXP)));
  }
  recomputeMassDerivedScales();
  let R_MIN = R_MIN_BASE * sizeScale;
  let R_MAX = R_MAX_BASE * sizeScale;

  function computeResponsiveScale() {
    // Use canvas container width for proper embed behavior
    const containerWidth = canvas.clientWidth || window.innerWidth;
    return (containerWidth <= 768) ? 0.4 : 1.0;
  }

  // Recomputes the effective pixel radius from global size and responsiveness,
  // then proportionally rescales existing balls so the scene updates smoothly.
  function updateEffectiveScaleAndBallSizes() {
    responsiveScale = computeResponsiveScale();
    const effectiveScale = sizeScale * responsiveScale;
    if (lastEffectiveScale === null) {
      lastEffectiveScale = effectiveScale;
      R_MIN = R_MIN_BASE * effectiveScale;
      R_MAX = R_MAX_BASE * effectiveScale;
      return;
    }
    const ratio = effectiveScale / lastEffectiveScale;
    if (ratio !== 1) {
      for (let i = 0; i < balls.length; i++) {
        // Don't scale Rainbow mode balls - they have fixed sizes
        if (currentMode !== MODES.RAINBOW) {
          balls[i].r *= ratio;
        }
      }
      lastEffectiveScale = effectiveScale;
    }
    R_MIN = R_MIN_BASE * effectiveScale;
    R_MAX = R_MAX_BASE * effectiveScale;
  }

  // Update text collision rectangles by measuring DOM elements
  function updateTextColliders() {
    textColliders = []; // Clear existing colliders
    
    const textElement = document.querySelector(TEXT_SELECTOR);
    if (!textElement) return; // No text element found
    
    const textRect = textElement.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    
    // Calculate cap height (height of capital letters only)
    const capHeight = calculateCapHeight(textElement);
    
    // Center the collision box vertically on the visual text
    const heightDifference = textRect.height - capHeight;
    const verticalOffset = heightDifference * 0.5; // Center the cap height within the full text height
    
    // Convert to canvas coordinates with device pixel ratio
    const collider = {
      x: (textRect.left - canvasRect.left) * DPR,
      y: (textRect.top - canvasRect.top + verticalOffset) * DPR,
      width: textRect.width * DPR,
      height: capHeight * DPR
    };
    
    // Only add collider if it's within canvas bounds and has valid dimensions
    if (collider.width > 0 && collider.height > 0 && 
        collider.x < canvas.width && collider.y < canvas.height &&
        collider.x + collider.width > 0 && collider.y + collider.height > 0) {
      textColliders.push(collider);
    }
  }
  
  // Calculate the cap height of text element (height of capital letters)
  function calculateCapHeight(element) {
    // Create a temporary element with just capital letters to measure cap height
    const tempElement = document.createElement('span');
    tempElement.style.cssText = window.getComputedStyle(element).cssText;
    tempElement.style.position = 'absolute';
    tempElement.style.visibility = 'hidden';
    tempElement.style.whiteSpace = 'nowrap';
    tempElement.textContent = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    
    document.body.appendChild(tempElement);
    const capHeight = tempElement.getBoundingClientRect().height;
    document.body.removeChild(tempElement);
    
    return capHeight;
  }

  // Emitter sweep (natural hand-like motion across the top band)
  let EMITTER_SWEEP_ENABLED = true;
  let emitterPhase = 0;                 // radians
  const EMITTER_SWEEP_HZ = 0.12;        // cycles per second
  const EMITTER_SWEEP_AMPL_VW = 20;     // sweep amplitude in vw
  let emitterSweepDir = 1;              // +1 sweeping right, -1 sweeping left (derived)

  // 8-Color system with weighted distribution (50%, 25%, 12%, 6%, 3%, 2%, 1%, 1%)
  // Color 1 (50%): Dominant/background color
  // Color 2 (25%): Secondary color  
  // Color 3 (15%): Tertiary color
  // Color 4 (7.5%): Accent color
  // Color 5 (2.5%): Rare/special color
  const COLOR_TEMPLATES = {
    industrialTeal: { label: 'Industrial Teal', colors: ['#b7bcb7', '#e4e9e4', '#ffffff', '#00695c', '#000000', '#ff4013', '#0d5cb6', '#ffa000'] },
    modern: { label: 'Modern European', colors: ['#9ca3af', '#d1d5db', '#ffffff', '#ff3b30', '#000000', '#00e5ff', '#1976d2', '#ffc107'] },
    corporate: { label: 'Corporate Modern', colors: ['#a0a8b1', '#d2d8de', '#ffffff', '#1a73e8', '#000000', '#ff5722', '#7b1fa2', '#ffa000'] },
    minimal: { label: 'Helvetica Minimal', colors: ['#bdbdbd', '#e0e0e0', '#ffffff', '#6b7280', '#000000', '#40e0d0', '#303f9f', '#ff9800'] },
    euroBlue: { label: 'European Blue', colors: ['#9aa6b2', '#d4dde5', '#ffffff', '#0a66c2', '#000000', '#ff4081', '#388e3c', '#ffb300'] },
    scandi: { label: 'Scandinavian Bright', colors: ['#aab2b7', '#e6eaee', '#ffffff', '#74b9ff', '#000000', '#e91e63', '#1976d2', '#4caf50'] },
    neonCyan: { label: 'Graphite Neon Cyan', colors: ['#9aa0a6', '#d5d9dd', '#ffffff', '#00e5ff', '#000000', '#ff9800', '#9c27b0', '#4caf50'] },
    coralTech: { label: 'Coral Tech', colors: ['#9da3a9', '#d8dde2', '#ffffff', '#ff6b6b', '#000000', '#00e676', '#3f51b5', '#ff5722'] },
    violetMidnight: { label: 'Violet Midnight', colors: ['#9fa3b1', '#d9dce3', '#ffffff', '#7c3aed', '#000000', '#e91e63', '#388e3c', '#ffb300'] },
    mintSage: { label: 'Mint Sage', colors: ['#a0a7a2', '#dbe0dd', '#ffffff', '#00c896', '#000000', '#ff1744', '#3f51b5', '#ff9800'] },
    slateAzure: { label: 'Slate Azure', colors: ['#9aa3ad', '#d8dee6', '#ffffff', '#3b82f6', '#000000', '#ff4081', '#388e3c', '#ffc107'] },
    vaporPop: { label: 'Vapor Pop', colors: ['#9ea0a8', '#d6d7dc', '#ffffff', '#ff00e5', '#000000', '#00bcd4', '#673ab7', '#ff5722'] },
    cyberMagenta: { label: 'Cyber Magenta', colors: ['#9c9fad', '#d6d9e3', '#ffffff', '#ff007a', '#000000', '#40e0d0', '#1976d2', '#ff9800'] },
    streetLime: { label: 'Street Lime', colors: ['#9aa19a', '#d6dbd6', '#ffffff', '#baff00', '#000000', '#e91e63', '#3f51b5', '#ff6f00'] },
    cmykPop: { label: 'CMYK Pop', colors: ['#9f9f9f', '#d9d9d9', '#ffffff', '#ffd400', '#000000', '#ff1744', '#7b1fa2', '#4caf50'] }
  };

  let currentTemplate = 'industrialTeal';
  let currentColors = COLOR_TEMPLATES.industrialTeal.colors.slice(); // 8 colors
  // Cursor color: default to Color 6 (highlight)
  let cursorBallIndex = 5;
  let cursorBallColor = currentColors[cursorBallIndex] || '#ff4013';

  // Expose palette as CSS variables for use by page elements
  function syncPaletteVars(colors = currentColors) {
    try {
      const root = document.documentElement;
      const list = (colors && colors.length ? colors : currentColors).slice(0, 8);
      for (let i = 0; i < 8; i++) {
        const hex = list[i] || '#ffffff';
        root.style.setProperty(`--ball-${i+1}`, hex);
      }
    } catch (_) { /* no-op */ }
  }

  // Color weights: Color 1: 50%, Color 2: 25%, Color 3: 15%, Color 4: 7.5%, Color 5: 2.5%
  const COLOR_WEIGHTS = [0.50, 0.25, 0.12, 0.06, 0.03, 0.02, 0.01, 0.01];
  
  function pickRandomColor() {
    try {
      if (!currentColors || currentColors.length === 0) {
        console.warn('No colors available, using fallback');
        return '#ffffff'; // Fallback color
      }
      
      // Use weighted random selection
      const random = Math.random();
      let cumulativeWeight = 0;
      
      for (let i = 0; i < Math.min(currentColors.length, COLOR_WEIGHTS.length); i++) {
        cumulativeWeight += COLOR_WEIGHTS[i];
        if (random <= cumulativeWeight) {
          return currentColors[i];
        }
      }
      
      // Fallback to last color if something goes wrong
      return currentColors[Math.min(currentColors.length - 1, 7)];
    } catch (error) {
      console.error('Error picking random color:', error);
      return '#ffffff'; // Fallback color
    }
  }

  // Repeller controls
  let repelRadius = 135;   // px (CSS px) - from screenshot
  let repelPower = 1536000;  // from screenshot (mapped display value)
  let repelSoft = 3.4;     // exponent falloff - from screenshot
  let mouseX = CONSTANTS.OFFSCREEN_MOUSE, mouseY = CONSTANTS.OFFSCREEN_MOUSE; // offscreen until moved
  let repellerEnabled = false; // disabled by default; enabled by preset or sliders
  const REPELLER_GLOBAL_MULTIPLIER = 20.0; // doubled overall repeller strength
  
  // Touch detection - cursor ball only shows on non-touch devices
  let isTouchDevice = false;
  // Check for touch support
  if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
    isTouchDevice = true;
  }
  
  // Hide modes that aren't available on this device
  function applyDeviceSpecificModeVisibility() {
    const deviceType = isTouchDevice ? 'mobile' : 'desktop';
    const trailButton = document.getElementById('trailModeButton');
    
    // Hide Trail mode button on mobile (needs precise cursor control)
    if (trailButton && !MODE_AVAILABILITY[MODES.TRAIL][deviceType]) {
      trailButton.style.display = 'none';
    }
    
    // Can add more device-specific logic here for other modes
  }
  
  // Settings persistence using localStorage
  const STORAGE_KEY = 'bouncyBallsSettings';
  
  // Persist current UI/simulation settings to localStorage so user preferences
  // survive reloads. Uses a compact single object for easy versioning.
  function saveSettings() {
    const settings = {
      currentMode,
      gravityMultiplierPit,
      repellerEnabledPit,
      attractionPower,
      orbitRadius,
      swarmSpeed,
      sparkleEmissionRate,
      sparkleLifetime,
      sparkleVelocitySpread,
      sparkleDriftStrength,
      sparkleParticleScale,
      weightlessInitialSpeed,
      weightlessBounce,
      weightlessMaxBalls,
      weightlessRepellerPower,
      weightlessRepellerRadius,
      restitution: REST,
      friction: FRICTION,
      sizeScale,
      sizeVariation,
      ballMassKg,
      ballSoftness,
      repelPower,
      repelRadius,
      repelSoft,
      cornerRadius,
      motionBlur: trailFade,
      trailSubtlety,
      currentTemplate,
      cursorBallColor
    };
    try {
      localStorage.setItem(STORAGE_KEY, JSON.stringify(settings));
      console.log('‚úì Settings saved');
    } catch (e) {
      console.warn('Could not save settings:', e);
    }
  }
  
  // Load settings from localStorage and safely apply them. Each field is
  // guarded to avoid clobbering defaults if a key is missing or old.
  function loadSettings() {
    try {
      const saved = localStorage.getItem(STORAGE_KEY);
      if (saved) {
        const settings = JSON.parse(saved);
        // Restore all settings
        if (settings.currentMode) currentMode = settings.currentMode;
        if (settings.gravityMultiplierPit !== undefined) gravityMultiplierPit = settings.gravityMultiplierPit;
        if (settings.repellerEnabledPit !== undefined) repellerEnabledPit = settings.repellerEnabledPit;
        if (settings.attractionPower) attractionPower = settings.attractionPower;
        if (settings.orbitRadius) orbitRadius = settings.orbitRadius;
        if (settings.swarmSpeed) swarmSpeed = settings.swarmSpeed;
        if (settings.sparkleEmissionRate !== undefined) sparkleEmissionRate = settings.sparkleEmissionRate;
        if (settings.sparkleLifetime !== undefined) sparkleLifetime = settings.sparkleLifetime;
        if (settings.sparkleVelocitySpread !== undefined) sparkleVelocitySpread = settings.sparkleVelocitySpread;
        if (settings.sparkleDriftStrength !== undefined) sparkleDriftStrength = settings.sparkleDriftStrength;
        if (settings.sparkleParticleScale !== undefined) sparkleParticleScale = settings.sparkleParticleScale;
        if (settings.weightlessInitialSpeed) weightlessInitialSpeed = settings.weightlessInitialSpeed;
        if (settings.weightlessBounce) weightlessBounce = settings.weightlessBounce;
        if (settings.weightlessMaxBalls) weightlessMaxBalls = settings.weightlessMaxBalls;
        if (settings.weightlessRepellerPower !== undefined) weightlessRepellerPower = settings.weightlessRepellerPower;
        if (settings.weightlessRepellerRadius !== undefined) weightlessRepellerRadius = settings.weightlessRepellerRadius;
        if (settings.restitution) REST = settings.restitution;
        if (settings.friction !== undefined) FRICTION = settings.friction;
        if (settings.sizeScale) sizeScale = settings.sizeScale;
        if (settings.sizeVariation !== undefined) sizeVariation = settings.sizeVariation;
        if (settings.ballMassKg) ballMassKg = settings.ballMassKg;
        if (settings.repelPower) repelPower = settings.repelPower;
        if (settings.repelRadius) repelRadius = settings.repelRadius;
        if (settings.repelSoft) repelSoft = settings.repelSoft;
        if (settings.cornerRadius !== undefined) cornerRadius = settings.cornerRadius;
        if (settings.motionBlur !== undefined) trailFade = settings.motionBlur;
        if (settings.trailSubtlety) trailSubtlety = settings.trailSubtlety;
        if (settings.currentTemplate) currentTemplate = settings.currentTemplate;
        if (settings.cursorBallColor) cursorBallColor = settings.cursorBallColor;
        
        console.log('‚úì Settings loaded');
        return true;
      }
    } catch (e) {
      console.warn('Could not load settings:', e);
    }
    return false;
  }
  
  // Auto-save settings when sliders change
  function autoSaveSettings() {
    // Debounced save (wait 500ms after last change)
    clearTimeout(window.settingsSaveTimeout);
    window.settingsSaveTimeout = setTimeout(saveSettings, 500);
  }

  // Repeller slider mapping (wide dynamic range; midpoint equals 2√ó previous default)
  const REPEL_BASE_POWER = 12000; // previous default baseline
  const REPEL_SLIDER_MAX = 1000;  // slider range [0..1000]
  const REPEL_CENTER_MULTIPLIER = 2.0; // midpoint = 2√ó base
  const REPEL_N_OCTAVES = 12; // wide range (~1/32x .. 128x around center)
  function repelSliderToPower(sliderValue) {
    const s = Math.max(0, Math.min(REPEL_SLIDER_MAX, Number(sliderValue))) / REPEL_SLIDER_MAX;
    const mult = REPEL_CENTER_MULTIPLIER * Math.pow(2, (s - 0.5) * REPEL_N_OCTAVES);
    return REPEL_BASE_POWER * mult;
  }
  function powerToRepelSlider(power) {
    const safe = Math.max(1, Number(power));
    const x = safe / (REPEL_BASE_POWER * REPEL_CENTER_MULTIPLIER);
    const s = 0.5 + (Math.log2(x) / REPEL_N_OCTAVES);
    return Math.round(Math.max(0, Math.min(1, s)) * REPEL_SLIDER_MAX);
  }

  // Shadows removed for better performance and realism
  
  // High refresh mode is now default
  let highRefreshMode = true; // Always enabled for best performance
  
  // Rounded corners for simulation area
  let cornerRadius = 0; // Corner radius in pixels (0 = square corners)
  
  // Text collision system
  const TEXT_SELECTOR = '#hero-text'; // ID selector for the main text element
  let textColliders = []; // Array of text collision rectangles
  // Temporal trail for simple motion blur (0 = off, up to ~0.25)
  let trailFade = 0.025; // from screenshot
  let trailSubtlety = 1.80; // from screenshot
  
  // Performance optimizations and FPS tracking
  let renderFrameCount = 0;
  let physicsStepCount = 0;
  let lastFPSTime = 0;
  let currentRenderFPS = 0;
  let currentPhysicsFPS = 0;
  const renderFpsElement = document.getElementById('render-fps');
  const physicsFpsElement = document.getElementById('physics-fps');
  // Removed performance mode indicators
  
  // Shadow system removed for better performance

  // Ball model - updated to remove 3D rendering
  class Ball {
    constructor(x, y, r, color) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random()*2 - 1) * 200; // random lateral kick
      this.vy = -Math.random()*200;          // slight upward variation
      this.r = r;
      this.rBase = r;                         // Store original radius for scaling
      this.m = ballMassKg;                    // all balls share the same mass
      this.color = color;
      this.t = 0;
      // Entry drift state for natural side-throw effect
      this.age = 0;           // seconds since spawn
      this.driftAx = 0;       // lateral acceleration during entry (px/s^2)
      this.driftTime = 0;     // duration of entry drift (s)
      // Spin & squash state
      this.omega = 0;         // angular velocity (rad/s)
      this.squash = 1.0;      // visual squash factor (1 = round)
      this.squashDirX = 1;    // squash direction components (unit vector)
      this.squashDirY = 0;
      // Improved rotation & world-aligned squash
      this.theta = 0;               // integrated angular position (rad)
      this.squashAmount = 0.0;      // 0 = no squash, up to SQUASH_MAX
      this.squashNormalAngle = 0.0; // world-space normal direction for squash
      // Trail mode alpha transparency
      this.alpha = 1.0;       // 1 = opaque, 0 = transparent
    }
    // Integrate motion with simple Euler step
    step(dt) {
      // Advance timers
        this.t += dt;
      this.age += dt;

      // Gravity scaled by mass to make weight perceptible without changing G globally
      this.vy += (G * gravityScale) * dt;
      // Mass-aware drag (heavier balls lose proportionally less velocity)
      const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
      const drag = Math.max(0, 1 - (FRICTION / massScale));
      this.vx *= drag;
      this.vy *= drag;
      // Apply short-lived lateral drift to simulate being thrown from the side above
      if (this.driftAx !== 0 && this.age < this.driftTime) {
        this.vx += (this.driftAx * dt) / massScale;
      } else if (this.driftAx !== 0) {
        this.driftAx = 0; // Clear drift when expired to skip future checks
      }
      applyExternalForces(this, dt);
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      // Angular damping
      const spinDamp = Math.max(0, 1 - CONSTANTS.SPIN_DAMP_PER_S * dt);
      this.omega *= spinDamp;
      // Integrate angular position for visible rotation
      this.theta += this.omega * dt;
      if (this.theta > Math.PI) this.theta -= Math.PI * 2; else if (this.theta < -Math.PI) this.theta += Math.PI * 2;
      // Relax squash amount back to 0 (area-preserving)
      const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
      this.squashAmount += (0 - this.squashAmount) * decay;
      this.squash = 1 - this.squashAmount;
    }
    // Resolve collision with walls (with rounded corners)
    walls(w, h, dt, customRest = REST) {
      // Use custom restitution if provided (for mode-specific bounce behavior)
      const rest = customRest;
      if (cornerRadius === 0) {
        // Standard rectangular collision
      if (this.y + this.r > h) { 
        this.y = h - this.r; 
        // Pre-impact speed for squash amplitude
        const preVy = this.vy;
        // Rolling friction & spin from tangential slip
        const slip = this.vx - this.omega * this.r; // world x is tangential at bottom contact
        const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
        // convert part of slip to spin, reduce horizontal speed (rolling tendency)
        this.omega += (slip / this.r) * CONSTANTS.SPIN_GAIN / massScale;
        const rollDamp = Math.max(0, 1 - CONSTANTS.ROLL_FRICTION_PER_S * dt / massScale);
        this.vx *= rollDamp;
        // Bounce with mass-aware restitution
        const wallRest = Math.abs(preVy) < CONSTANTS.WALL_REST_VEL_THRESHOLD ? 0 : rest;
        this.vy = -this.vy * (wallRest * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash on impact using pre-impact speed
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = -Math.PI / 2; // ground normal upwards
        // Ground coupling: tend towards pure rolling without slipping
        const rollTarget = this.vx / this.r;
        this.omega += (rollTarget - this.omega) * Math.min(1, CONSTANTS.GROUND_COUPLING_PER_S * dt);
      }
      // Top wall collision at visible viewport top (not canvas top)
      // Canvas is 150vh, visible viewport is bottom 100vh, so top is at 1/3 of canvas height
      const viewportTop = h / 3; // 50vh offset from 150vh canvas
      if (this.y - this.r < viewportTop) { 
        this.y = viewportTop + this.r; 
        const preVy = this.vy;
        this.vy = -this.vy * rest; 
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI / 2; // ceiling normal downwards
      }
      if (this.x + this.r > w) { 
        this.x = w - this.r; 
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * rest; 
        const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
        this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // right wall normal leftwards
      }
        if (this.x - this.r < 0) { 
          this.x = this.r; 
          {
            const slip = this.vy - this.omega * this.r;
            const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
            this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
          }
          this.vx = -this.vx * rest; 
          const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
          this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
          this.squash = 1 - this.squashAmount;
          this.squashNormalAngle = 0; // left wall normal rightwards
        }
      } else {
        // Rounded corner collision detection
        this.handleRoundedWallCollision(w, h);
      }
      
      // Text collision detection
      this.checkTextCollisions(dt);
    }
    
    // Check collision with text elements
    checkTextCollisions(dt) {
      for (let i = 0; i < textColliders.length; i++) {
        const rect = textColliders[i];
        
        // Check if ball overlaps with text rectangle
        const closestX = Math.max(rect.x, Math.min(this.x, rect.x + rect.width));
        const closestY = Math.max(rect.y, Math.min(this.y, rect.y + rect.height));
        
        const dx = this.x - closestX;
        const dy = this.y - closestY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < this.r) {
          // Collision detected - resolve it
          if (distance === 0) {
            // Ball center is inside rectangle - push out in shortest direction
            const distToLeft = this.x - rect.x;
            const distToRight = (rect.x + rect.width) - this.x;
            const distToTop = this.y - rect.y;
            const distToBottom = (rect.y + rect.height) - this.y;
            
            const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
            
            if (minDist === distToLeft) {
              this.x = rect.x - this.r;
              this.vx = -Math.abs(this.vx) * REST;
            } else if (minDist === distToRight) {
              this.x = rect.x + rect.width + this.r;
              this.vx = Math.abs(this.vx) * REST;
            } else if (minDist === distToTop) {
              this.y = rect.y - this.r;
              this.vy = -Math.abs(this.vy) * REST;
            } else {
              this.y = rect.y + rect.height + this.r;
              this.vy = Math.abs(this.vy) * REST;
            }
          } else {
            // Normal collision resolution
            const overlap = this.r - distance;
            const nx = dx / distance;
            const ny = dy / distance;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity with restitution
            const dotProduct = this.vx * nx + this.vy * ny;
            if (dotProduct < 0) {
              this.vx -= 2 * dotProduct * nx * REST;
              this.vy -= 2 * dotProduct * ny * REST;
              
              // Add squash effect for visual impact
              const impact = Math.min(1, Math.abs(dotProduct) / (this.r * 70));
              this.squash = 1 - getSquashMax() * impact;
              this.squashDirX = Math.abs(nx) > Math.abs(ny) ? 1 : 0;
              this.squashDirY = Math.abs(ny) > Math.abs(nx) ? 1 : 0;
            }
          }
        }
      }
    }
    
    // Handle collision with rounded corner boundaries
    handleRoundedWallCollision(w, h) {
      const r = cornerRadius;
      
      // Check collision with each corner circle
      const corners = [
        { x: r, y: r },           // Top-left
        { x: w - r, y: r },       // Top-right
        { x: w - r, y: h - r },   // Bottom-right
        { x: r, y: h - r }        // Bottom-left
      ];
      
      for (let i = 0; i < corners.length; i++) {
        const corner = corners[i];
        const dx = this.x - corner.x;
        const dy = this.y - corner.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Check if ball is in corner region and colliding with corner circle
        const inCornerRegion = this.isInCornerRegion(corner, w, h, r);
        if (inCornerRegion && dist + this.r > r) {
          // Collision with corner circle
          const overlap = r - (dist - this.r);
          if (overlap > 0 && dist > 0) {
            const nx = dx / dist;
            const ny = dy / dist;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity
            const dot = this.vx * nx + this.vy * ny;
            this.vx -= 2 * dot * nx * REST;
            this.vy -= 2 * dot * ny * REST;
            // Squash aligned to corner normal, proportional to impact
            const impact = Math.min(1, Math.abs(dot) / (this.r * 90));
            this.squashAmount = Math.min(getSquashMax(), impact * 0.8);
            this.squash = 1 - this.squashAmount;
            this.squashNormalAngle = Math.atan2(ny, nx);
          }
        }
      }
      
      // Handle straight wall collisions (outside corner regions)
      // Bottom wall
      if (this.y + this.r > h && (this.x < r || this.x > w - r)) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      
      // Top wall
      if (this.y - this.r < 0 && (this.x < r || this.x > w - r)) {
        this.y = this.r;
        this.vy = -this.vy * REST;
      }
      
      // Right wall
      if (this.x + this.r > w && (this.y < r || this.y > h - r)) {
        this.x = w - this.r;
        // Wall contact: add spin from tangential slip (vertical normal)
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash aligned to wall normal
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(getSquashMax(), impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // normal leftwards
      }
      
      // Left wall
      if (this.x - this.r < 0 && (this.y < r || this.y > h - r)) {
        this.x = this.r;
        {
          const slip = this.vy - this.omega * this.r;
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(getSquashMax(), impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = 0; // normal rightwards
      }
      
      // Handle straight sections of walls
      if (this.y + this.r > h && this.x >= r && this.x <= w - r) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.y - this.r < 0 && this.x >= r && this.x <= w - r) {
        this.y = this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x + this.r > w && this.y >= r && this.y <= h - r) {
        this.x = w - this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x - this.r < 0 && this.y >= r && this.y <= h - r) {
        this.x = this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
    }
    
    // Check if ball is in a corner region
    isInCornerRegion(corner, w, h, r) {
      // Top-left corner
      if (corner.x === r && corner.y === r) {
        return this.x <= r && this.y <= r;
      }
      // Top-right corner
      if (corner.x === w - r && corner.y === r) {
        return this.x >= w - r && this.y <= r;
      }
      // Bottom-right corner
      if (corner.x === w - r && corner.y === h - r) {
        return this.x >= w - r && this.y >= h - r;
      }
      // Bottom-left corner
      if (corner.x === r && corner.y === h - r) {
        return this.x <= r && this.y >= h - r;
      }
      return false;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      // World-aligned squash/stretch only if significant
      const amt = Math.min(getSquashMax(), Math.max(0, this.squashAmount));
      if (amt > 0.001) {
        // Area-preserving squash: s * (1/s) maintains roundness perception
        const s = 1 + amt;
        const inv = 1 / s;
        ctx.rotate(this.squashNormalAngle);
        ctx.scale(s, inv);
        ctx.rotate(-this.squashNormalAngle);
      }
      // Body
      ctx.beginPath();
      ctx.arc(0, 0, this.r, 0, Math.PI*2);
      ctx.fillStyle = this.color;
      ctx.fill();
      // Spin indicator removed for cleaner visuals and performance
      ctx.restore();
    }
  }

  const balls = [];

  // Helpers
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function randBetween(a, b) { return a + Math.random() * (b - a); }
  // Compute mass from radius using current weight slider as density baseline
  // Removed radius-based mass; shared mass is used instead
  
  // Draw rounded boundary visualization
  function drawRoundedBoundary(ctx, w, h) {
    const r = cornerRadius;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    // Start from top-left corner (after the curve)
    ctx.moveTo(r, 0);
    
    // Top edge
    ctx.lineTo(w - r, 0);
    
    // Top-right corner
    ctx.arcTo(w, 0, w, r, r);
    
    // Right edge
    ctx.lineTo(w, h - r);
    
    // Bottom-right corner
    ctx.arcTo(w, h, w - r, h, r);
    
    // Bottom edge
    ctx.lineTo(r, h);
    
    // Bottom-left corner
    ctx.arcTo(0, h, 0, h - r, r);
    
    // Left edge
    ctx.lineTo(0, r);
    
    // Top-left corner
    ctx.arcTo(0, 0, r, 0, r);
    
    ctx.closePath();
    ctx.stroke();
  }
  
  function spawnBall(x, y, color = pickRandomColor()) {
    // Calculate size range with variation (ensure positive values)
    const baseSize = (R_MIN + R_MAX) / 2;
    
    let r;
    if (sizeVariation === 0) {
      // No variation: all balls exactly the same size
      r = baseSize;
    } else {
      // Apply variation
      const range = (R_MAX - R_MIN) / 2;
      const variedRange = range * sizeVariation;
      const minR = Math.max(1, baseSize - variedRange);
      const maxR = baseSize + variedRange;
      r = randBetween(minR, maxR);
    }
    
    const ball = new Ball(x, y, r, color);

    // Natural entry throw with size-aware impulse and sweep-aware direction
    const centerX = canvas.width * 0.5;
    // Prefer current sweep direction if enabled; otherwise side-based
    const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((x < centerX) ? 1 : -1);
    const sizeInfluence = clamp((r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
    const baseKick = 140 * sizeInfluence;  // scale with size
    const randKick = 180 * sizeInfluence;  // scale with size
    const upwardKick = 120;                // small upward speed to soften entry
    ball.vx = dir * (baseKick + Math.random() * randKick);
    ball.vy = -Math.random() * upwardKick;

    // Short lived lateral acceleration to feel like being pushed from the side (size-aware)
    ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence; // px/s^2
    ball.driftTime = 0.22 + Math.random() * 0.28;                    // 0.22‚Äì0.5s of drift

    balls.push(ball);
    return ball;
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PROFESSIONAL RAINBOW DROP SYSTEM
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  class RainbowDropSystem {
    constructor() {
      this.dropQueue = [];
      this.currentIndex = 0;
      this.lastDropTime = 0;
      this.isActive = false;
      this.dropPositions = [];
      this.preCalculatedSizes = [];
    }
    
    // Initialize the drop system with pre-calculated properties
    initialize() {
      this.clear();
      this.preCalculateDropProperties();
      this.generateDropPositions();
      this.isActive = true;
      this.lastDropTime = performance.now() / 1000;
    }
    
    // Pre-calculate all ball properties for optimal performance
    preCalculateDropProperties() {
      const maxRadius = Math.min(canvas.height * 0.15, canvas.width * 0.15); // radius, not diameter
      const minRadius = 10 * DPR; // radius, not diameter
      const colorCount = currentColors.length;
      
      this.preCalculatedSizes = [];
      
      for (let i = 0; i < colorCount; i++) {
        let radius;
        if (rainbowRandomness === 0) {
          // Equal steps
          const t = i / (colorCount - 1);
          radius = maxRadius - t * (maxRadius - minRadius);
        } else {
          // Random distribution with bias towards larger sizes for first colors
          const baseT = i / (colorCount - 1);
          const randomT = baseT + (Math.random() - 0.5) * rainbowRandomness * 0.3;
          const t = Math.max(0, Math.min(1, randomT));
          radius = maxRadius - t * (maxRadius - minRadius);
        }
        this.preCalculatedSizes.push(radius);
      }
      
      // Sort sizes in descending order for visual appeal
      this.preCalculatedSizes.sort((a, b) => b - a);
    }
    
    // Generate smart drop positions to avoid clustering
    generateDropPositions() {
      const colorCount = currentColors.length;
      this.dropPositions = [];
      
      for (let i = 0; i < colorCount; i++) {
        // Smart positioning: avoid clustering, spread across canvas
        const x = (canvas.width / colorCount) * i + (canvas.width / colorCount) * 0.5;
        const jitter = (Math.random() - 0.5) * (canvas.width / colorCount) * 0.6;
        this.dropPositions.push(Math.max(20, Math.min(canvas.width - 20, x + jitter)));
      }
    }
    
    // Drop the next ball in sequence
    dropNext() {
      if (this.currentIndex >= currentColors.length || !this.isActive) return false;
      
      const radius = this.preCalculatedSizes[this.currentIndex]; // Already a radius
      const x = this.dropPositions[this.currentIndex];
      const y = -radius - 50; // Spawn above viewport
      
      // Create ball with optimized properties
      const ball = new Ball(x, y, radius, currentColors[this.currentIndex]);
      
      // Add subtle random horizontal velocity for natural movement
      ball.vx = (Math.random() - 0.5) * 80;
      ball.vy = 0;
      
      // Add to balls array
      balls.push(ball);
      
      this.currentIndex++;
      this.lastDropTime = performance.now() / 1000;
      
      return true;
    }
    
    // Check if ready to drop next ball
    shouldDrop() {
      if (!this.isActive || this.currentIndex >= currentColors.length) return false;
      const now = performance.now() / 1000;
      return (now - this.lastDropTime) >= rainbowDropDelay;
    }
    
    // Reset the system
    clear() {
      balls.length = 0;
      this.currentIndex = 0;
      this.isActive = false;
      this.lastDropTime = 0;
      this.dropQueue = [];
      this.dropPositions = [];
      this.preCalculatedSizes = [];
    }
    
    // Get system status
    getStatus() {
      return {
        isActive: this.isActive,
        currentIndex: this.currentIndex,
        totalColors: currentColors.length,
        progress: this.currentIndex / currentColors.length,
        remaining: currentColors.length - this.currentIndex
      };
    }
  }
  
  // Global rainbow drop system instance
  const rainbowDropSystem = new RainbowDropSystem();
  
  // Legacy function wrappers for compatibility
  function spawnRainbowBalls() {
    rainbowDropSystem.initialize();
  }
  
  function dropNextRainbowBall() {
    rainbowDropSystem.dropNext();
  }

  // Continuous emitter within a vw/vh-defined rectangle
  let emitterTimer = 0;
  function pickSpawnPoint() {
    const wCss = canvas.clientWidth;
    const hCss = canvas.clientHeight;
    const widthCss = clamp((SPAWN_W_VW / 100) * wCss, 0, wCss);
    let xCenterCss = clamp((SPAWN_X_CENTER_VW / 100) * wCss, 0, wCss);
    // Apply sweeping emitter motion across the band for natural hand-like movement
    if (EMITTER_SWEEP_ENABLED) {
      const amplPx = (EMITTER_SWEEP_AMPL_VW / 100) * wCss;
      const sweepOffset = Math.sin(emitterPhase) * amplPx;
      const prevX = xCenterCss;
      xCenterCss = clamp(xCenterCss + sweepOffset, 0, wCss);
      emitterSweepDir = (xCenterCss >= prevX) ? 1 : -1;
    }
    // Allow slight offscreen horizontal spawn for natural side entry feel
    const offX = Math.min(40, widthCss * 0.1); // up to 40px or 10% width
    const xLeftCss = clamp(xCenterCss - widthCss / 2 - offX, -offX, wCss);
    const xRightCss = clamp(xCenterCss + widthCss / 2 + offX, -offX, wCss);
    const yTopCss = (SPAWN_Y_VH / 100) * hCss;
    const yBotCss = yTopCss + (SPAWN_H_VH / 100) * hCss;
    // Slight bias along sweep direction to emit closer to the leading edge
    const bias = 0.3; // 0 = uniform, 1 = fully biased to leading edge
    const u = Math.random();
    const biased = bias > 0 ? (emitterSweepDir > 0 ? Math.pow(u, 1 - bias) : 1 - Math.pow(1 - u, 1 - bias)) : u;
    const x = (xLeftCss + (xRightCss - xLeftCss) * biased) * DPR;
    // Add slight upward randomness to spawn height for organic feel
    const y = randBetween(yTopCss * DPR, yBotCss * DPR) - (R_MAX + CONSTANTS.BALL_SPAWN_OFFSET + randBetween(0, 10 * DPR));
    return { x, y };
  }
  // Sparkle Trail emission: emit particles from cursor based on mouse movement
  function emitSparkles(dt) {
    // Only emit if mouse is on-screen and moving
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    
    // Calculate mouse velocity using timestamps for stability
    let mouseVx = 0, mouseVy = 0;
    if (mouseTrail.length >= 2) {
      const latest = mouseTrail[mouseTrail.length - 1];
      const prev = mouseTrail[mouseTrail.length - 2];
      const dtx = Math.max(1e-3, (latest.time - prev.time)); // seconds
      mouseVx = (latest.x - prev.x) / dtx;
      mouseVy = (latest.y - prev.y) / dtx;
    }
    const mouseSpeed = Math.sqrt(mouseVx * mouseVx + mouseVy * mouseVy);
    
    // Only emit if mouse is moving
    if (mouseSpeed < CONSTANTS.MIN_MOUSE_SPEED_FOR_TRAIL) return;
    
    // Emit multiple particles per frame based on emission rate
    const particlesToEmit = sparkleEmissionRate;
    for (let i = 0; i < particlesToEmit; i++) {
      if (balls.length >= MAX_BALLS) break;
      
      // Spawn particle at cursor position
      const ball = spawnBall(mouseX, mouseY);
      
      // Random initial velocity (spread in all directions)
      const spreadAngle = Math.random() * Math.PI * 2;
      const spreadMagnitude = sparkleVelocitySpread * (0.5 + Math.random() * 0.5);
      ball.vx = Math.cos(spreadAngle) * spreadMagnitude;
      ball.vy = Math.sin(spreadAngle) * spreadMagnitude;
      
      // Mark for sparkle mode and track spawn time
      ball.isSparkle = true;
      ball.spawnTime = performance.now() / 1000; // seconds
      ball.lifetime = sparkleLifetime;
      
      // Scale particles down
      ball.r = ball.r * sparkleParticleScale;
      ball.rBase = ball.rBase * sparkleParticleScale;
    }
  }
  
  function emit(dt) {
    // Trail (Sparkle) mode: emit sparkles from cursor
    if (currentMode === MODES.TRAIL) {
      emitSparkles(dt);
      return;
    }
    
    // Rainbow mode: professional drop system
    if (currentMode === MODES.RAINBOW) {
      if (rainbowDropSystem.shouldDrop()) {
        rainbowDropSystem.dropNext();
      }
      return;
    }
    
    // Ball Pit & Flies modes: standard top emitter
    emitterTimer += dt;
    while (emitterTimer >= EMIT_INTERVAL) {
      // Jitter emissions slightly for organic timing
      const jitter = (Math.random() - 0.5) * EMIT_INTERVAL * 0.5; // ¬±25%
      emitterTimer -= (EMIT_INTERVAL + jitter);
      // Advance sweep phase based on elapsed time segment (approx)
      emitterPhase += (2 * Math.PI) * EMITTER_SWEEP_HZ * (EMIT_INTERVAL + jitter);
      const p = pickSpawnPoint();
      // Occasionally emit small clusters to mimic handful tosses
      const drops = (Math.random() < 0.35 ? 3 : 1);
      for (let i=0; i<drops; i++) {
        if (balls.length < MAX_BALLS) {
          // Slight horizontal staggering to suggest sideways motion
          const xOffset = i * CONSTANTS.BALL_CLUSTER_SPACING * (Math.random() < 0.5 ? 1 : -1);
          spawnBall(p.x + xOffset, p.y - i * CONSTANTS.BALL_CLUSTER_Y_OFFSET);
        }
      }
    }
  }

  // Spatial hash grid to accelerate broad-phase (optimized)
  const spatialGrid = new Map();
  
  function collectPairsSorted() {
    const n = balls.length;
    if (n < 2) return []; // Early exit for trivial cases
    const cellSize = Math.max(1, R_MAX * 2); // Optimized cell size
    const gridWidth = Math.ceil(canvas.width / cellSize) + 1; // Dynamic grid width
    spatialGrid.clear(); // Reuse map
    
    // Build grid with numeric keys (faster than string concatenation)
    for (let i = 0; i < n; i++) {
      const b = balls[i];
      const cx = (b.x / cellSize) | 0;
      const cy = (b.y / cellSize) | 0;
      const key = cy * gridWidth + cx; // Numeric key
      let arr = spatialGrid.get(key);
      if (!arr) { arr = []; spatialGrid.set(key, arr); }
      arr.push(i);
    }
    
    const pairs = [];
    for (const [key, arr] of spatialGrid) {
      const cy = (key / gridWidth) | 0;
      const cx = key % gridWidth;
      
      // Check 9 neighboring cells (including self)
      for (let oy = -1; oy <= 1; oy++) {
        for (let ox = -1; ox <= 1; ox++) {
          const neighborKey = (cy + oy) * gridWidth + (cx + ox);
          const nb = spatialGrid.get(neighborKey);
          if (!nb) continue;
          
          for (let ii = 0; ii < arr.length; ii++) {
            const i = arr[ii];
            for (let jj = 0; jj < nb.length; jj++) {
              const j = nb[jj];
              if (j <= i) continue;
              
              const A = balls[i], B = balls[j];
              const dx = B.x - A.x, dy = B.y - A.y;
              const rSum = A.r + B.r;
              const dist2 = dx*dx + dy*dy;
              
              if (dist2 < rSum*rSum) {
                const dist = Math.sqrt(Math.max(dist2, CONSTANTS.MIN_DISTANCE_EPSILON));
                const overlap = rSum - dist;
                pairs.push({ i, j, overlap });
              }
            }
          }
        }
      }
    }
    
    // Sort by overlap (most overlapping first for stability)
    pairs.sort((a, b) => b.overlap - a.overlap);
    return pairs;
  }

  // Circle‚Äìcircle collisions: sequential impulses + Baumgarte positional correction
  function resolveCollisions(iterations = SOLVER_ITERS) {
    const pairs = collectPairsSorted();
    for (let iter = 0; iter < iterations; iter++) {
      for (let k = 0; k < pairs.length; k++) {
        const { i, j } = pairs[k];
        const A = balls[i];
        const B = balls[j];
        const dx = B.x - A.x;
        const dy = B.y - A.y;
        const rSum = A.r + B.r;
        const dist2 = dx * dx + dy * dy;
        if (dist2 === 0 || dist2 > rSum * rSum) continue;
        const dist = Math.sqrt(dist2);
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = rSum - dist;
        const invA = 1 / Math.max(A.m, 0.001);
        const invB = 1 / Math.max(B.m, 0.001);

        // Positional correction
        const correctionMag = POS_CORRECT_PERCENT * Math.max(overlap - POS_CORRECT_SLOP, 0) / (invA + invB);
        const cx = correctionMag * nx;
        const cy = correctionMag * ny;
        A.x -= cx * invA; A.y -= cy * invA;
        B.x += cx * invB; B.y += cy * invB;

        // Velocity impulse along the normal
        const rvx = B.vx - A.vx;
        const rvy = B.vy - A.vy;
        const velAlongNormal = rvx * nx + rvy * ny;
        if (velAlongNormal < 0) {
          const e = Math.abs(velAlongNormal) < REST_VEL_THRESHOLD ? 0 : REST;
          const j = -(1 + e) * velAlongNormal / (invA + invB);
          const ix = j * nx;
          const iy = j * ny;
          A.vx -= ix * invA; A.vy -= iy * invA;
          B.vx += ix * invB; B.vy += iy * invB;

          // Tangential slip to spin (approximate rolling/spin transfer)
          const tvx = rvx - velAlongNormal * nx;
          const tvy = rvy - velAlongNormal * ny;
          const slipMag = Math.hypot(tvx, tvy);
          if (slipMag > 1e-3) {
            const tangentSign = (tvx * -ny + tvy * nx) >= 0 ? 1 : -1; // right-hand tangent
            const gain = CONSTANTS.SPIN_GAIN_TANGENT;
            A.omega -= tangentSign * gain * slipMag / Math.max(A.r, 1);
            B.omega += tangentSign * gain * slipMag / Math.max(B.r, 1);
          }
          // Visual squash aligned to contact normal based on impact
          const impact = Math.min(1, Math.abs(velAlongNormal) / ((A.r + B.r) * 50));
          const sAmt = Math.min(getSquashMax(), impact * 0.8);
          A.squashAmount = Math.max(A.squashAmount, sAmt * 0.8);
          A.squashNormalAngle = Math.atan2(-ny, -nx);
          B.squashAmount = Math.max(B.squashAmount, sAmt * 0.8);
          B.squashNormalAngle = Math.atan2(ny, nx);
        }
      }
    }
  }

  // Main loop optimized for 120fps
  let last = performance.now() / 1000;
  let acc = 0;
  const DT = 1/120; // Target 120fps physics
  function frame(nowMs) {
    const now = nowMs / 1000;
    let dt = Math.min(0.008, now - last); // Cap at ~120fps for high refresh displays
    last = now;
    acc += dt;

  // FPS counters (render and physics) - only update if elements exist
    renderFrameCount++;
    if ((renderFpsElement || physicsFpsElement) && now - lastFPSTime >= CONSTANTS.FPS_UPDATE_INTERVAL) {
      if (renderFpsElement && renderFrameCount !== currentRenderFPS) {
        currentRenderFPS = renderFrameCount;
        renderFpsElement.textContent = currentRenderFPS.toString();
      }
      if (physicsFpsElement && physicsStepCount !== currentPhysicsFPS) {
        currentPhysicsFPS = physicsStepCount;
        physicsFpsElement.textContent = currentPhysicsFPS.toString();
      }
      
      renderFrameCount = 0;
      physicsStepCount = 0;
      lastFPSTime = now;
    }

    emit(dt);
    
    // Update text colliders periodically (every ~60 frames for performance)
    if (renderFrameCount % 60 === 0) {
      updateTextColliders();
    }

    // Physics iterations optimized for realistic, stable simulation
    let physicsSteps = 0;
    while (acc >= DT && physicsSteps < CONSTANTS.MAX_PHYSICS_STEPS) {
      for (let i=0; i<balls.length; i++) balls[i].step(DT);
      
      // Ball-to-ball collisions (disabled for Flies and Trail modes)
      if (currentMode !== MODES.FLIES && currentMode !== MODES.TRAIL) {
        resolveCollisions(3); // Balanced quality vs performance
      }
      
      // Wall collisions (disabled for Trail mode - particles drift off-screen)
      if (currentMode !== MODES.TRAIL) {
        const wallRestitution = (currentMode === MODES.WEIGHTLESS) ? weightlessBounce : 
                                (currentMode === MODES.RAINBOW) ? rainbowBounce : REST;
        for (let i=0; i<balls.length; i++) balls[i].walls(canvas.width, canvas.height, DT, wallRestitution);
      }
      
      acc -= DT;
      physicsSteps++;
      physicsStepCount++; // Count physics steps for FPS measurement
    }
    
  // Trail (Sparkle) mode: cleanup tiny particles to cap memory and keep FPS
    if (currentMode === MODES.TRAIL) {
      for (let i = balls.length - 1; i >= 0; i--) {
        const ball = balls[i];
        if (ball.isSparkle && ball.r <= 0.5) {
          balls.splice(i, 1); // Remove tiny sparkles earlier to save memory
        }
      }
    }
    
    // Reset accumulator if we're falling behind
    if (acc > DT * CONSTANTS.ACCUMULATOR_RESET_THRESHOLD) acc = 0;

    // Clear or fade canvas for motion blur trail
    if (trailFade > 0 && trailSubtlety > 0) {
      // Map sliders to effective fade alpha
      const TRAIL_FADE_UI_MAX = 1.5;      // slider max for trail length
      const TRAIL_SUBTLE_UI_MAX = 3.0;    // slider max for subtlety
      const maxAlpha = 0.35;              // shortest trail (more aggressive clear)
      const minAlpha = 0.0015;            // longest trail (very subtle clear)
      const normLen = Math.max(0, Math.min(1, trailFade / TRAIL_FADE_UI_MAX));
      const baseFade = maxAlpha + (minAlpha - maxAlpha) * normLen; // low slider -> big fade
      const subtleNorm = Math.max(0, Math.min(1, trailSubtlety / TRAIL_SUBTLE_UI_MAX));
      // Blend between full clear (1.0 alpha) at low subtlety and baseFade at high subtlety
      let effectiveFade = 1.0 + (baseFade - 1.0) * subtleNorm;
      // Clamp to safe bounds
      effectiveFade = Math.max(0.001, Math.min(1.0, effectiveFade));
      ctx.fillStyle = `rgba(0,0,0,${effectiveFade})`;
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'source-over';
    } else {
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }
    
    // Draw rounded boundary if corner radius > 0 (cache boundary path for performance)
    if (cornerRadius > 0) {
      drawRoundedBoundary(ctx, canvas.width, canvas.height);
    }
    
    // Shadow rendering removed for better performance and realism
    
    // Render balls with individual colors
    for (let i=0; i<balls.length; i++) balls[i].draw(ctx);
    // Draw cursor ball last
    drawCursorBall(ctx);
    
    // Draw current mode indicator (desktop only)
    if (!isTouchDevice) {
      ctx.save();
      ctx.font = '14px system-ui, -apple-system, sans-serif';
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.textAlign = 'left';
      ctx.textBaseline = 'bottom';
      const modeName = currentMode.charAt(0).toUpperCase() + currentMode.slice(1);
      ctx.fillText(modeName + ' Mode', 10, canvas.height - 10);
      ctx.restore();
    }

    // Use requestAnimationFrame for proper vsync
    requestAnimationFrame(frame);
  }
  
  // Start the main loop with requestAnimationFrame
  console.log('High refresh mode enabled - using requestAnimationFrame');
  requestAnimationFrame(frame);

  // Reset balls to spawn positions (preserves all settings)
  function resetBallsToSpawn() {
    if (currentMode === MODES.RAINBOW) {
      // For rainbow mode, reinitialize the drop system
      rainbowDropSystem.initialize();
    } else if (currentMode === MODES.WEIGHTLESS) {
      // For weightless mode, reinitialize with even distribution
      initializeWeightlessScene();
    } else {
      for (let i = 0; i < balls.length; i++) {
        const ball = balls[i];
        const p = pickSpawnPoint();
        ball.x = p.x;
        ball.y = p.y;
        // Re-apply natural entry throw on reset (sweep-aware, size-aware)
        const centerX = canvas.width * 0.5;
        const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((ball.x < centerX) ? 1 : -1);
        const sizeInfluence = clamp((ball.r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
        const baseKick = 140 * sizeInfluence;
        const randKick = 180 * sizeInfluence;
        const upwardKick = 120;
        ball.vx = dir * (baseKick + Math.random() * randKick);
        ball.vy = -Math.random() * upwardKick;
        ball.age = 0;
        ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence;
        ball.driftTime = 0.22 + Math.random() * 0.28;
      }
    }
  }

  // Keyboard: reset balls to spawn, toggle panel
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k === 'r') {
      // Move balls back to spawn area - preserve all parameter settings
      resetBallsToSpawn();
      e.preventDefault(); // Prevent any default browser behavior
    }
    if (k === '/' && panel) {
      e.preventDefault();
      panel.classList.toggle('hidden');
    }
    // Quick mode switches 1..5
    if (k === '1') setMode(MODES.PIT);
    if (k === '2') setMode(MODES.FLIES);
    if (k === '3') setMode(MODES.TRAIL);
    if (k === '4') setMode(MODES.WEIGHTLESS);
    if (k === '5') setMode(MODES.RAINBOW);
  });

  // Seed initial balls across the spawn area for quicker fill
  function seedArea(n = 160) {
    for (let i=0; i<n && balls.length < MAX_BALLS; i++) {
      const p = pickSpawnPoint();
      spawnBall(p.x, p.y);
    }
  }
  seedArea(CONSTANTS.INITIAL_SEED_BALLS);

  // Shadow system removed for better performance



  // Mouse input (unified handler for repeller + trail recording)
  let lastTrailRecordTime = 0;
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    mouseX = (e.clientX - rect.left) * DPR;
    mouseY = (e.clientY - rect.top) * DPR;
    
    // Ball Pit: enable repeller when power and radius are set
    if (currentMode === MODES.PIT && repelPower > 0 && repelRadius > 0) {
      repellerEnabled = true;
    }
    
    // Trail mode: record mouse path
    if (currentMode === MODES.TRAIL) {
      const now = performance.now() / 1000; // seconds
      // Push sample with timestamp; keep small fixed buffer
      mouseTrail.push({ x: mouseX, y: mouseY, time: now });
      if (mouseTrail.length > MAX_MOUSE_TRAIL_LENGTH) mouseTrail.shift();
    }
  });
  canvas.addEventListener('mouseleave', () => { 
    mouseX = CONSTANTS.OFFSCREEN_MOUSE; 
    mouseY = CONSTANTS.OFFSCREEN_MOUSE;
    if (currentMode === MODES.TRAIL) mouseTrail = [];
  });

  // Draw a cursor as a ball matching the simulation style
  // Renders the cursor as a simulation-like ball for desktop. Hidden on touch.
  function drawCursorBall(ctx) {
    // Don't show cursor ball on touch devices (mobile)
    if (isTouchDevice) return;
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    
  // Hide cursor ball in Trail mode
    if (currentMode === MODES.TRAIL) return;
    
    // Draw main cursor ball for all other modes (white by default on desktop)
    const x = mouseX, y = mouseY;
    const baseSize = (R_MIN + R_MAX) / 2;
    const r = baseSize;
    const color = 'rgba(255, 255, 255, 0.9)';
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    
    // Add subtle white outline for visibility
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
    ctx.lineWidth = 2;
    ctx.stroke();
  }

  function applyRepeller(b, dt) {
    // Respect "Off" template by treating zero or near-zero params as disabled
    if (!repellerEnabled) return;
    if (repelPower <= 0 || repelRadius <= 0) return;
    const rPx = repelRadius * DPR;
    const dx = b.x - mouseX;
    const dy = b.y - mouseY;
    const d2 = dx*dx + dy*dy;
    const r2 = rPx * rPx;
    if (d2 > r2) return;
    const d = Math.max(Math.sqrt(d2), CONSTANTS.MIN_REPEL_DISTANCE);
    const nx = dx / d;
    const ny = dy / d;
    const q = Math.max(0, 1 - d / rPx);
    const strength = (repelPower * REPELLER_GLOBAL_MULTIPLIER) * Math.pow(q, repelSoft);
    // Heavier balls respond less to the same field
    const massScale = Math.max(0.25, b.m / MASS_BASELINE_KG);
    b.vx += (nx * strength * dt) / massScale;
    b.vy += (ny * strength * dt) / massScale;
    // Add subtle air turbulence for realism (micro perturbations)
    const turbulence = 10; // subtle random force
    b.vx += (Math.random() - 0.5) * turbulence * dt;
    b.vy += (Math.random() - 0.5) * turbulence * dt;
  }

  // Behavior-mode external forces dispatcher
  function applyExternalForces(b, dt) {
    if (currentMode === MODES.PIT) {
      applyRepeller(b, dt);
      return;
    }
    if (currentMode === MODES.FLIES) {
      applyAttractor(b, dt);
      return;
    }
    if (currentMode === MODES.TRAIL) {
      applySparklePhysics(b, dt);
      return;
    }
    if (currentMode === MODES.WEIGHTLESS) {
      applyWeightlessRepeller(b, dt);
      return;
    }
  }
  
  // Subtle mouse repeller for Weightless mode
  function applyWeightlessRepeller(b, dt) {
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    if (weightlessRepellerPower <= 0 || weightlessRepellerRadius <= 0) return;
    
    const rPx = weightlessRepellerRadius * DPR;
    const dx = b.x - mouseX;
    const dy = b.y - mouseY;
    const d2 = dx*dx + dy*dy;
    const r2 = rPx * rPx;
    if (d2 > r2) return;
    
    const d = Math.max(Math.sqrt(d2), CONSTANTS.MIN_REPEL_DISTANCE);
    const nx = dx / d;
    const ny = dy / d;
    const q = Math.max(0, 1 - d / rPx);
    const strength = weightlessRepellerPower * q; // linear falloff, gentle
    
    b.vx += nx * strength * dt;
    b.vy += ny * strength * dt;
  }

  // Mouse attractor for Flies-to-Light mode - FAST erratic mosquito flight
  function applyAttractor(b, dt) {
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    
    const dx = mouseX - b.x;
    const dy = mouseY - b.y;
    const d2 = dx*dx + dy*dy;
    const d = Math.sqrt(d2 + 1);
    
    // Direction to cursor
    const dirX = dx / d;
    const dirY = dy / d;
    
    // 1. STRONG ATTRACTION - mosquitos dart toward light quickly
    const attractForce = attractionPower * 4.0; // Much stronger (4x instead of 1.5x)
    b.vx += dirX * attractForce * dt;
    b.vy += dirY * attractForce * dt;
    
    // 2. SEPARATION from nearby flies (keep some spacing)
    const separationRadius = 80 * DPR; // Larger separation for more spread
    let sepX = 0, sepY = 0;
    let neighborCount = 0;
    for (let i = 0; i < balls.length; i++) {
      const other = balls[i];
      if (other === b) continue;
      const dx2 = b.x - other.x;
      const dy2 = b.y - other.y;
      const d2_other = dx2*dx2 + dy2*dy2;
      if (d2_other < separationRadius * separationRadius && d2_other > 0) {
        const d_other = Math.sqrt(d2_other);
        const strength = 1 - (d_other / separationRadius);
        sepX += (dx2 / d_other) * strength;
        sepY += (dy2 / d_other) * strength;
        neighborCount++;
      }
    }
    if (neighborCount > 0) {
      const separationForce = 15000; // Stronger separation for more spread
      b.vx += (sepX / neighborCount) * separationForce * dt;
      b.vy += (sepY / neighborCount) * separationForce * dt;
    }
    
    // 3. STRONG ERRATIC JITTER - mosquitos dart unpredictably
    // Random direction changes and quick bursts
    const jitterBase = 1200; // Much stronger jitter
    const burstChance = 0.05; // 5% chance per frame for sudden burst
    if (Math.random() < burstChance) {
      // Sudden burst in random direction
      const burstAngle = Math.random() * Math.PI * 2;
      const burstStrength = 800;
      b.vx += Math.cos(burstAngle) * burstStrength;
      b.vy += Math.sin(burstAngle) * burstStrength;
    }
    // Constant jitter
    b.vx += (Math.random() - 0.5) * jitterBase * dt;
    b.vy += (Math.random() - 0.5) * jitterBase * dt;
    
    // 4. VARIABLE ORBITAL MOTION - not perfect circles, more chaotic
    // Orbital force varies based on distance and random factor
    const orbitVariation = 0.5 + Math.random() * 1.5; // 0.5x to 2x variation
    const orbitStrength = swarmSpeed * 1200 * orbitVariation * dt; // 2x base orbit
    b.vx += -dirY * orbitStrength;
    b.vy += dirX * orbitStrength;
    
    // 5. HIGHER speed limit - mosquitos are FAST
    const maxSpeed = 1400; // Much faster than 600
    const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy);
    if (speed > maxSpeed) {
      b.vx = (b.vx / speed) * maxSpeed;
      b.vy = (b.vy / speed) * maxSpeed;
    }
    
    // Very light damping - keep energy high
    b.vx *= 0.99; // Less damping than 0.98
    b.vy *= 0.99;
  }

  // Trail (Sparkle) mode: particles drift gently and scale down based on age
  function applySparklePhysics(b, dt) {
    // Apply gentle drift (random floating motion)
    if (sparkleDriftStrength > 0) {
      b.vx += (Math.random() - 0.5) * sparkleDriftStrength * dt;
      b.vy += (Math.random() - 0.5) * sparkleDriftStrength * dt;
    }
    
    // Apply drag (deceleration)
    b.vx *= CONSTANTS.SPARKLE_DRAG_COEFFICIENT;
    b.vy *= CONSTANTS.SPARKLE_DRAG_COEFFICIENT;
    
    // Age-based scale down
    const currentTime = performance.now() / 1000;
    const age = currentTime - b.spawnTime;
    const scaleProgress = age / b.lifetime;
    const scaleDown = Math.max(0, 1 - scaleProgress);
    b.r = b.rBase * scaleDown * sparkleParticleScale;
  }

  // UI elements
  const restitutionSlider = document.getElementById('restitutionSlider');
  const frictionSlider = document.getElementById('frictionSlider');
  const emitterSlider = document.getElementById('emitterSlider');
  // Mode-specific ball properties controls
  // Global ball properties
  const sizeSliderGlobal = document.getElementById('sizeSliderGlobal');
  const sizeVariationSliderGlobal = document.getElementById('sizeVariationSliderGlobal');
  const weightSliderGlobal = document.getElementById('weightSliderGlobal');
  const ballSoftnessSliderGlobal = document.getElementById('ballSoftnessSliderGlobal');
  const sizeValGlobal = document.getElementById('sizeValGlobal');
  const sizeVariationValGlobal = document.getElementById('sizeVariationValGlobal');
  const weightValGlobal = document.getElementById('weightValGlobal');
  const ballSoftnessValGlobal = document.getElementById('ballSoftnessValGlobal');
  
  // Mode-specific sliders (kept for backward compatibility)
  const sizeSliderPit = document.getElementById('sizeSliderPit');
  const sizeVariationSliderPit = document.getElementById('sizeVariationSliderPit');
  const weightSliderPit = document.getElementById('weightSliderPit');
  const ballSoftnessSliderPit = document.getElementById('ballSoftnessSliderPit');
  const sizeValPit = document.getElementById('sizeValPit');
  const sizeVariationValPit = document.getElementById('sizeVariationValPit');
  const weightValPit = document.getElementById('weightValPit');
  const ballSoftnessValPit = document.getElementById('ballSoftnessValPit');

  const sizeSliderFlies = document.getElementById('sizeSliderFlies');
  const sizeVariationSliderFlies = document.getElementById('sizeVariationSliderFlies');
  const weightSliderFlies = document.getElementById('weightSliderFlies');
  const ballSoftnessSliderFlies = document.getElementById('ballSoftnessSliderFlies');
  const sizeValFlies = document.getElementById('sizeValFlies');
  const sizeVariationValFlies = document.getElementById('sizeVariationValFlies');
  const weightValFlies = document.getElementById('weightValFlies');
  const ballSoftnessValFlies = document.getElementById('ballSoftnessValFlies');

  const sizeSliderZeroG = document.getElementById('sizeSliderZeroG');
  const sizeVariationSliderZeroG = document.getElementById('sizeVariationSliderZeroG');
  const weightSliderZeroG = document.getElementById('weightSliderZeroG');
  const ballSoftnessSliderZeroG = document.getElementById('ballSoftnessSliderZeroG');
  const sizeValZeroG = document.getElementById('sizeValZeroG');
  const sizeVariationValZeroG = document.getElementById('sizeVariationValZeroG');
  const weightValZeroG = document.getElementById('weightValZeroG');
  const ballSoftnessValZeroG = document.getElementById('ballSoftnessValZeroG');

  const maxBallsSlider = document.getElementById('maxBallsSlider');
  const spawnYSlider = document.getElementById('spawnYSlider');
  const spawnWidthSlider = document.getElementById('spawnWidthSlider');
  const spawnCenterSlider = document.getElementById('spawnCenterSlider');
  const spawnHeightSlider = document.getElementById('spawnHeightSlider');
  const repelSizeSlider = document.getElementById('repelSizeSlider');
  const repelPowerSlider = document.getElementById('repelPowerSlider');
  const repelSoftSlider = document.getElementById('repelSoftSlider');
  // Color controls
  const colorSelect = document.getElementById('colorSelect');
  const color1 = document.getElementById('color1');
  const color2 = document.getElementById('color2');
  const color3 = document.getElementById('color3');
  const color4 = document.getElementById('color4');
  const color5 = document.getElementById('color5');
  const color6 = document.getElementById('color6');
  const color7 = document.getElementById('color7');
  const color8 = document.getElementById('color8');
  const cursorColorSelect = document.getElementById('cursorColorSelect');
  // Hex spans
  const color1Val = document.getElementById('color1Val');
  const color2Val = document.getElementById('color2Val');
  const color3Val = document.getElementById('color3Val');
  const color4Val = document.getElementById('color4Val');
  const color5Val = document.getElementById('color5Val');
  const color6Val = document.getElementById('color6Val');
  const color7Val = document.getElementById('color7Val');
  const color8Val = document.getElementById('color8Val');
  // Tooltip hint for copy action
  [color1Val, color2Val, color3Val, color4Val, color5Val, color6Val, color7Val, color8Val].forEach(el => {
    if (el) el.setAttribute('title', 'Click to copy');
  });
  // Scene controls
  const cornerRadiusSlider = document.getElementById('cornerRadiusSlider');
  const cornerRadiusVal = document.getElementById('cornerRadiusVal');
  const trailFadeSlider = document.getElementById('trailFadeSlider');
  const trailFadeVal = document.getElementById('trailFadeVal');
  const trailSubtletySlider = document.getElementById('trailSubtletySlider');
  const trailSubtletyVal = document.getElementById('trailSubtletyVal');

  const restitutionVal = document.getElementById('restitutionVal');
  const frictionVal = document.getElementById('frictionVal');
  const emitterVal = document.getElementById('emitterVal');
  // const sizeVal = document.getElementById('sizeVal'); // Removed - using global controls
  const maxBallsVal = document.getElementById('maxBallsVal');
  // const sizeVariationVal = document.getElementById('sizeVariationVal'); // Removed - using global controls
  // const weightVal = document.getElementById('weightVal'); // Removed - using global controls
  const spawnYVal = document.getElementById('spawnYVal');
  const spawnWidthVal = document.getElementById('spawnWidthVal');
  const spawnCenterVal = document.getElementById('spawnCenterVal');
  const spawnHeightVal = document.getElementById('spawnHeightVal');
  const repelSizeVal = document.getElementById('repelSizeVal');
  const repelPowerVal = document.getElementById('repelPowerVal');
  const repelSoftVal = document.getElementById('repelSoftVal');
  // Scene controls vals (shadows removed)

  // Config capture and build functionality (restored)
  function captureCurrentConfig() {
    return {
      gravityMultiplier,
      restitution: REST,
      friction: FRICTION,
      ballMass: ballMassKg,
      emitRate: EMIT_INTERVAL,
      maxBalls: MAX_BALLS,
      ballScale: sizeScale,
      ballVariation: sizeVariation,
      spawnX: SPAWN_X_CENTER_VW,
      spawnY: SPAWN_Y_VH,
      spawnWidth: SPAWN_W_VW,
      spawnHeight: SPAWN_H_VH,
      sweepEnabled: EMITTER_SWEEP_ENABLED,
      repelRadius,
      repelPower,
      repelSoftness: repelSoft,
      trailFade,
      trailSubtlety,
      colors: currentColors.slice(),
      colorWeights: COLOR_WEIGHTS.slice(),
      currentTemplate,
      cursorColorIndex: cursorBallIndex
    };
  }
  function generateConfigCode(config) {
    return `// Generated configuration from frontend\nconst CONFIG = ${JSON.stringify(config, null, 2)};`;
  }
  const saveConfigBtn = document.getElementById('saveConfigBtn');
  const buildBtn = document.getElementById('buildBtn');
  const configOutput = document.getElementById('configOutput');
  if (saveConfigBtn && buildBtn && configOutput) {
    saveConfigBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      const code = generateConfigCode(config);
      configOutput.style.display = 'block';
      configOutput.textContent = code;
      navigator.clipboard.writeText(code).then(() => {
        const old = saveConfigBtn.textContent; saveConfigBtn.textContent = '‚úÖ Copied!';
        setTimeout(() => { saveConfigBtn.textContent = old; }, 1200);
      }).catch(() => {
        console.warn('Clipboard copy failed');
        const old = saveConfigBtn.textContent; saveConfigBtn.textContent = '‚ö†Ô∏è Copy failed';
        setTimeout(() => { saveConfigBtn.textContent = old; }, 1200);
      });
    });
    buildBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      configOutput.style.display = 'block';
      configOutput.innerHTML = `
<strong>üöÄ Build Instructions:</strong><br>
1. Run: <code>npm run build</code><br>
2. Your current config will be baked into <code>public/js/bouncy-balls-embed.js</code>`;
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'current-config.json'; a.click();
      URL.revokeObjectURL(url);
    });
  }

  // Click-to-copy helper
  function bindCopyOnClick(el, getText) {
    if (!el) return;
    el.addEventListener('click', async () => {
      const text = typeof getText === 'function' ? getText() : String(getText || '').trim();
      try {
        await navigator.clipboard.writeText(text);
        const old = el.textContent;
        el.textContent = 'COPIED';
        el.style.color = '#3ddc84';
        setTimeout(() => { el.textContent = old; el.style.color = '#888'; }, 900);
      } catch (e) {
        console.warn('Clipboard unavailable');
      }
    });
  }

  // Sliders (with auto-save)
  restitutionSlider && restitutionSlider.addEventListener('input', () => { REST = parseFloat(restitutionSlider.value); restitutionVal && (restitutionVal.textContent = REST.toFixed(2)); autoSaveSettings(); });
  frictionSlider && frictionSlider.addEventListener('input', () => { FRICTION = parseFloat(frictionSlider.value); frictionVal && (frictionVal.textContent = FRICTION.toFixed(4)); autoSaveSettings(); });
  emitterSlider && emitterSlider.addEventListener('input', () => { EMIT_INTERVAL = parseFloat(emitterSlider.value); emitterVal && (emitterVal.textContent = EMIT_INTERVAL.toFixed(3)); autoSaveSettings(); });

  // Mode-specific ball properties listeners (apply values globally but source UI is per-mode)
  function bindBallProps(sliders) {
    if (!sliders) return;
    const { size, sizeVal, sizeVar, sizeVarVal, soft, softVal } = sliders;
    size && size.addEventListener('input', () => {
      const newScale = parseFloat(size.value);
      sizeVal && (sizeVal.textContent = newScale.toFixed(1));
      sizeScale = newScale;
      updateEffectiveScaleAndBallSizes();
      for (let i=0; i<balls.length; i++) { balls[i].m = ballMassKg; }
      autoSaveSettings();
    });
    sizeVar && sizeVar.addEventListener('input', () => {
      const v = parseFloat(sizeVar.value);
      sizeVarVal && (sizeVarVal.textContent = v.toFixed(1));
      sizeVariation = v;
      autoSaveSettings();
    });
    soft && soft.addEventListener('input', () => {
      const s = parseInt(soft.value, 10);
      softVal && (softVal.textContent = String(s));
      ballSoftness = s;
      autoSaveSettings();
    });
  }

  // Global ball properties (apply to all modes)
  bindBallProps({
    size: sizeSliderGlobal, sizeVal: sizeValGlobal,
    sizeVar: sizeVariationSliderGlobal, sizeVarVal: sizeVariationValGlobal,
    soft: ballSoftnessSliderGlobal, softVal: ballSoftnessValGlobal
  });
  maxBallsSlider && maxBallsSlider.addEventListener('input', () => {
    MAX_BALLS = parseInt(maxBallsSlider.value, 10);
    maxBallsVal && (maxBallsVal.textContent = MAX_BALLS.toString());
    // Remove excess balls if current count exceeds new limit (remove from end for better performance)
    if (balls.length > MAX_BALLS) {
      balls.length = MAX_BALLS; // Truncate array efficiently
    }
  });
  sizeVariationSliderGlobal && sizeVariationSliderGlobal.addEventListener('input', () => {
    sizeVariation = parseFloat(sizeVariationSliderGlobal.value);
    sizeVariationValGlobal && (sizeVariationValGlobal.textContent = sizeVariation.toFixed(1));
    
    // Update existing ball sizes to reflect new variation
    updateExistingBallSizes();
  });
  // Mode-specific weight controls
  const weightPitSlider = document.getElementById('weightPitSlider');
  const weightPitVal = document.getElementById('weightPitVal');
  const weightWeightlessSlider = document.getElementById('weightWeightlessSlider');
  const weightWeightlessVal = document.getElementById('weightWeightlessVal');
  const weightRainbowSlider = document.getElementById('weightRainbowSlider');
  const weightRainbowVal = document.getElementById('weightRainbowVal');
  
  // Function to update existing ball sizes based on current sizeVariation
  function updateExistingBallSizes() {
    const baseSize = (R_MIN + R_MAX) / 2;
    
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      
      if (sizeVariation === 0) {
        // No variation: all balls exactly the same size
        ball.r = baseSize;
      } else {
        // Apply variation
        const range = (R_MAX - R_MIN) / 2;
        const variedRange = range * sizeVariation;
        const minR = Math.max(1, baseSize - variedRange);
        const maxR = baseSize + variedRange;
        ball.r = randBetween(minR, maxR);
      }
      
      // Keep shared mass model (no per-ball recompute)
      ball.m = ballMassKg;
    }
  }
  spawnYSlider && spawnYSlider.addEventListener('input', () => {
    SPAWN_Y_VH = parseFloat(spawnYSlider.value);
    spawnYVal && (spawnYVal.textContent = SPAWN_Y_VH.toFixed(0));
    setCSSSize(); resize();
  });
  spawnWidthSlider && spawnWidthSlider.addEventListener('input', () => { SPAWN_W_VW = parseFloat(spawnWidthSlider.value); spawnWidthVal && (spawnWidthVal.textContent = SPAWN_W_VW.toFixed(0)); });
  spawnCenterSlider && spawnCenterSlider.addEventListener('input', () => { SPAWN_X_CENTER_VW = parseFloat(spawnCenterSlider.value); spawnCenterVal && (spawnCenterVal.textContent = SPAWN_X_CENTER_VW.toFixed(0)); });
  spawnHeightSlider && spawnHeightSlider.addEventListener('input', () => { SPAWN_H_VH = parseFloat(spawnHeightSlider.value); spawnHeightVal && (spawnHeightVal.textContent = SPAWN_H_VH.toFixed(0)); });
  repelSizeSlider && repelSizeSlider.addEventListener('input', () => {
    repelRadius = parseFloat(repelSizeSlider.value);
    repelSizeVal && (repelSizeVal.textContent = repelRadius.toFixed(0));
    repellerEnabled = repellerEnabled || (repelPower > 0 && repelRadius > 0); 
  });
  repelPowerSlider && repelPowerSlider.addEventListener('input', () => {
    repelPower = repelSliderToPower(repelPowerSlider.value);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    // Do not auto-enable when template is Off; only enable via template or size/power explicit >0 with mouse over
    if (repellerSelect && repellerSelect.value !== 'off') {
      repellerEnabled = repelPower > 0 && repelRadius > 0; 
    }
  });
  repelSoftSlider && repelSoftSlider.addEventListener('input', () => {
    repelSoft = parseFloat(repelSoftSlider.value);
    repelSoftVal && (repelSoftVal.textContent = repelSoft.toFixed(1));
  });
  // Shadow event listeners removed
  
  // Color controls
  colorSelect && colorSelect.addEventListener('change', () => {
    const template = COLOR_TEMPLATES[colorSelect.value];
    if (!template) return;
    currentTemplate = colorSelect.value;
    currentColors = template.colors.slice();
    // Keep cursor index and update color
    cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor;
    // Update color pickers + hex spans
    if (color1 && color1Val) { color1.value = currentColors[0]; color1Val.textContent = currentColors[0].toUpperCase(); }
    if (color2 && color2Val) { color2.value = currentColors[1]; color2Val.textContent = currentColors[1].toUpperCase(); }
    if (color3 && color3Val) { color3.value = currentColors[2]; color3Val.textContent = currentColors[2].toUpperCase(); }
    if (color4 && color4Val) { color4.value = currentColors[3]; color4Val.textContent = currentColors[3].toUpperCase(); }
    if (color5 && color5Val) { color5.value = currentColors[4]; color5Val.textContent = currentColors[4].toUpperCase(); }
    if (color6 && color6Val) { color6.value = currentColors[5]; color6Val.textContent = currentColors[5].toUpperCase(); }
    if (color7 && color7Val) { color7.value = currentColors[6]; color7Val.textContent = currentColors[6].toUpperCase(); }
    if (color8 && color8Val) { color8.value = currentColors[7]; color8Val.textContent = currentColors[7].toUpperCase(); }
    // Update existing ball colors
    updateExistingBallColors();
    // Sync CSS variables
    syncPaletteVars();
  });

  // Mode switcher wiring
  const modeButtons = Array.from(document.querySelectorAll('.mode-button'));
  const pitControls = document.getElementById('pitControls');
  const fliesControls = document.getElementById('fliesControls');
  const trailControls = document.getElementById('trailControls');
  const weightlessControls = document.getElementById('weightlessControls');
  const rainbowControls = document.getElementById('rainbowControls');
  const gravityPitSlider = document.getElementById('gravityPitSlider');
  const gravityPitVal = document.getElementById('gravityPitVal');
  const repellerEnabledPitEl = document.getElementById('repellerEnabledPit');
  const attractPowerSlider = document.getElementById('attractPowerSlider');
  const attractPowerVal = document.getElementById('attractPowerVal');
  const orbitRadiusSlider = document.getElementById('orbitRadiusSlider');
  const orbitRadiusVal = document.getElementById('orbitRadiusVal');
  const swarmSpeedSlider = document.getElementById('swarmSpeedSlider');
  const swarmSpeedVal = document.getElementById('swarmSpeedVal');
  // Sparkle Trail controls
  const sparkleEmissionSlider = document.getElementById('sparkleEmissionSlider');
  const sparkleEmissionVal = document.getElementById('sparkleEmissionVal');
  const sparkleLifetimeSlider = document.getElementById('sparkleLifetimeSlider');
  const sparkleLifetimeVal = document.getElementById('sparkleLifetimeVal');
  const sparkleSpreadSlider = document.getElementById('sparkleSpreadSlider');
  const sparkleSpreadVal = document.getElementById('sparkleSpreadVal');
  const sparkleDriftSlider = document.getElementById('sparkleDriftSlider');
  const sparkleDriftVal = document.getElementById('sparkleDriftVal');
  const sparkleScaleSlider = document.getElementById('sparkleScaleSlider');
  const sparkleScaleVal = document.getElementById('sparkleScaleVal');

  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // PROFESSIONAL WEIGHTLESS SCENE INITIALIZATION
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  function initializeWeightlessScene() {
    // Clear existing balls
    balls.length = 0;
    
    // Calculate optimal grid distribution
    const targetBalls = weightlessMaxBalls;
    const canvasWidth = canvas.width;
    const canvasHeight = canvas.height;
    
    // Calculate grid dimensions for even distribution
    const aspectRatio = canvasWidth / canvasHeight;
    const cols = Math.ceil(Math.sqrt(targetBalls * aspectRatio));
    const rows = Math.ceil(targetBalls / cols);
    
    // Calculate spacing and margins
    const marginX = 40; // Margin from edges
    const marginY = 40;
    const availableWidth = canvasWidth - (2 * marginX);
    const availableHeight = canvasHeight - (2 * marginY);
    const spacingX = availableWidth / (cols - 1);
    const spacingY = availableHeight / (rows - 1);
    
    // Generate evenly distributed positions
    const positions = [];
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        if (positions.length >= targetBalls) break;
        
        const x = marginX + (col * spacingX);
        const y = marginY + (row * spacingY);
        
        // Add subtle jitter to avoid perfect grid alignment
        const jitterX = (Math.random() - 0.5) * spacingX * 0.3;
        const jitterY = (Math.random() - 0.5) * spacingY * 0.3;
        
        positions.push({
          x: Math.max(20, Math.min(canvasWidth - 20, x + jitterX)),
          y: Math.max(20, Math.min(canvasHeight - 20, y + jitterY))
        });
      }
    }
    
    // Create balls with controlled initial velocities
    for (let i = 0; i < positions.length; i++) {
      const pos = positions[i];
      const ball = spawnBall(pos.x, pos.y);
      
      // Generate controlled initial velocity
      const angle = Math.random() * Math.PI * 2;
      const speed = weightlessInitialSpeed * (0.5 + Math.random() * 0.5); // 50-100% of max speed
      
      ball.vx = Math.cos(angle) * speed;
      ball.vy = Math.sin(angle) * speed;
      ball.driftAx = 0;
      ball.driftTime = 0;
    }
    
    console.log(`Weightless scene initialized: ${balls.length} balls distributed evenly across viewport`);
  }

  function updateModeControlsUI() {
    if (pitControls) pitControls.classList.toggle('active', currentMode === MODES.PIT);
    if (fliesControls) fliesControls.classList.toggle('active', currentMode === MODES.FLIES);
    if (trailControls) trailControls.classList.toggle('active', currentMode === MODES.TRAIL);
    if (weightlessControls) weightlessControls.classList.toggle('active', currentMode === MODES.WEIGHTLESS);
    if (rainbowControls) rainbowControls.classList.toggle('active', currentMode === MODES.RAINBOW);
    modeButtons.forEach(btn => btn.classList.toggle('active', btn.getAttribute('data-mode') === currentMode));
  }

  function setMode(mode) {
    currentMode = mode;
    // Apply per-mode high-level toggles
    if (currentMode === MODES.PIT) {
      gravityMultiplier = gravityMultiplierPit;
      G = GE * gravityMultiplier;
      repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0);
      EMITTER_SWEEP_ENABLED = true;
    } else if (currentMode === MODES.FLIES) {
      gravityMultiplier = 0.0; // no gravity
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
    } else if (currentMode === MODES.TRAIL) {
      gravityMultiplier = 0.0; // no gravity for sparkle particles
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
      mouseTrail = [];
      // Clear all existing balls when entering Trail mode
      balls.length = 0;
    } else if (currentMode === MODES.WEIGHTLESS) {
      gravityMultiplier = 0.0; // zero gravity (weightless)
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
      // Initialize professional weightless scene with even distribution
      initializeWeightlessScene();
    } else if (currentMode === MODES.RAINBOW) {
      gravityMultiplier = rainbowGravity;
      G = GE * gravityMultiplier;
      repellerEnabled = false;
      EMITTER_SWEEP_ENABLED = false;
      // Initialize professional rainbow drop system
      rainbowDropSystem.initialize();
    }
    updateModeControlsUI();
  }

  // Hook up UI listeners (with auto-save on changes)
  modeButtons.forEach(btn => btn.addEventListener('click', () => { setMode(btn.getAttribute('data-mode')); autoSaveSettings(); }));
  gravityPitSlider && gravityPitSlider.addEventListener('input', () => {
    gravityMultiplierPit = parseFloat(gravityPitSlider.value);
    gravityPitVal && (gravityPitVal.textContent = gravityMultiplierPit.toFixed(1));
    autoSaveSettings();
    if (currentMode === MODES.PIT) { gravityMultiplier = gravityMultiplierPit; G = GE * gravityMultiplier; }
  });
  
  // Mode-specific weight controls
  weightPitSlider && weightPitSlider.addEventListener('input', () => {
    ballMassKg = parseFloat(weightPitSlider.value);
    weightPitVal && (weightPitVal.textContent = ballMassKg.toFixed(2));
    // Apply shared mass to all balls
    for (let i=0; i<balls.length; i++) { balls[i].m = ballMassKg; }
    // Recompute derived scaling so gravity visibly changes with weight
    recomputeMassDerivedScales();
    autoSaveSettings();
  });
  repellerEnabledPitEl && repellerEnabledPitEl.addEventListener('change', () => {
    repellerEnabledPit = !!repellerEnabledPitEl.checked;
    if (currentMode === MODES.PIT) repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0);
  });
  attractPowerSlider && attractPowerSlider.addEventListener('input', () => {
    attractionPower = parseFloat(attractPowerSlider.value);
    attractPowerVal && (attractPowerVal.textContent = Math.round(attractionPower).toString());
  });
  orbitRadiusSlider && orbitRadiusSlider.addEventListener('input', () => {
    orbitRadius = parseFloat(orbitRadiusSlider.value);
    orbitRadiusVal && (orbitRadiusVal.textContent = Math.round(orbitRadius).toString());
  });
  swarmSpeedSlider && swarmSpeedSlider.addEventListener('input', () => {
    swarmSpeed = parseFloat(swarmSpeedSlider.value);
    swarmSpeedVal && (swarmSpeedVal.textContent = swarmSpeed.toFixed(1));
  });
  // Sparkle Trail event listeners
  sparkleEmissionSlider && sparkleEmissionSlider.addEventListener('input', () => {
    sparkleEmissionRate = parseInt(sparkleEmissionSlider.value, 10);
    sparkleEmissionVal && (sparkleEmissionVal.textContent = sparkleEmissionRate.toString());
    autoSaveSettings();
  });
  sparkleLifetimeSlider && sparkleLifetimeSlider.addEventListener('input', () => {
    sparkleLifetime = parseFloat(sparkleLifetimeSlider.value);
    sparkleLifetimeVal && (sparkleLifetimeVal.textContent = sparkleLifetime.toFixed(1));
    autoSaveSettings();
  });
  sparkleSpreadSlider && sparkleSpreadSlider.addEventListener('input', () => {
    sparkleVelocitySpread = parseInt(sparkleSpreadSlider.value, 10);
    sparkleSpreadVal && (sparkleSpreadVal.textContent = sparkleVelocitySpread.toString());
    autoSaveSettings();
  });
  sparkleDriftSlider && sparkleDriftSlider.addEventListener('input', () => {
    sparkleDriftStrength = parseInt(sparkleDriftSlider.value, 10);
    sparkleDriftVal && (sparkleDriftVal.textContent = sparkleDriftStrength.toString());
    autoSaveSettings();
  });
  sparkleScaleSlider && sparkleScaleSlider.addEventListener('input', () => {
    sparkleParticleScale = parseFloat(sparkleScaleSlider.value);
    sparkleScaleVal && (sparkleScaleVal.textContent = sparkleParticleScale.toFixed(2));
    autoSaveSettings();
  });
  
  // Weightless mode sliders
  const weightlessSpeedSlider = document.getElementById('weightlessSpeedSlider');
  const weightlessSpeedVal = document.getElementById('weightlessSpeedVal');
  const weightlessBounceSlider = document.getElementById('weightlessBounceSlider');
  const weightlessBounceVal = document.getElementById('weightlessBounceVal');
  const weightlessMaxBallsSlider = document.getElementById('weightlessMaxBallsSlider');
  const weightlessMaxBallsVal = document.getElementById('weightlessMaxBallsVal');
  const weightlessRepelPowerSlider = document.getElementById('weightlessRepelPowerSlider');
  const weightlessRepelPowerVal = document.getElementById('weightlessRepelPowerVal');
  const weightlessRepelRadiusSlider = document.getElementById('weightlessRepelRadiusSlider');
  const weightlessRepelRadiusVal = document.getElementById('weightlessRepelRadiusVal');
  
  weightlessSpeedSlider && weightlessSpeedSlider.addEventListener('input', () => {
    weightlessInitialSpeed = parseFloat(weightlessSpeedSlider.value);
    weightlessSpeedVal && (weightlessSpeedVal.textContent = Math.round(weightlessInitialSpeed).toString());
  });
  
  weightWeightlessSlider && weightWeightlessSlider.addEventListener('input', () => {
    ballMassKg = parseFloat(weightWeightlessSlider.value);
    weightWeightlessVal && (weightWeightlessVal.textContent = ballMassKg.toFixed(2));
    // Apply shared mass to all balls
    for (let i=0; i<balls.length; i++) { balls[i].m = ballMassKg; }
    // Recompute derived scaling so gravity visibly changes with weight
    recomputeMassDerivedScales();
    autoSaveSettings();
  });
  weightlessBounceSlider && weightlessBounceSlider.addEventListener('input', () => {
    weightlessBounce = parseFloat(weightlessBounceSlider.value);
    weightlessBounceVal && (weightlessBounceVal.textContent = weightlessBounce.toFixed(2));
  });
  weightlessMaxBallsSlider && weightlessMaxBallsSlider.addEventListener('input', () => {
    weightlessMaxBalls = parseInt(weightlessMaxBallsSlider.value, 10);
    weightlessMaxBallsVal && (weightlessMaxBallsVal.textContent = weightlessMaxBalls.toString());
    // If in weightless mode, reinitialize with new ball count
    if (currentMode === MODES.WEIGHTLESS) {
      initializeWeightlessScene();
    }
  });
  weightlessRepelPowerSlider && weightlessRepelPowerSlider.addEventListener('input', () => {
    weightlessRepellerPower = parseFloat(weightlessRepelPowerSlider.value);
    weightlessRepelPowerVal && (weightlessRepelPowerVal.textContent = Math.round(weightlessRepellerPower).toString());
  });
  weightlessRepelRadiusSlider && weightlessRepelRadiusSlider.addEventListener('input', () => {
    weightlessRepellerRadius = parseFloat(weightlessRepelRadiusSlider.value);
    weightlessRepelRadiusVal && (weightlessRepelRadiusVal.textContent = Math.round(weightlessRepellerRadius).toString());
  });
  
  // Rainbow mode sliders
  const rainbowRandomnessSlider = document.getElementById('rainbowRandomnessSlider');
  const rainbowRandomnessVal = document.getElementById('rainbowRandomnessVal');
  const rainbowDropDelaySlider = document.getElementById('rainbowDropDelaySlider');
  const rainbowDropDelayVal = document.getElementById('rainbowDropDelayVal');
  const rainbowGravitySlider = document.getElementById('rainbowGravitySlider');
  const rainbowGravityVal = document.getElementById('rainbowGravityVal');
  const rainbowBounceSlider = document.getElementById('rainbowBounceSlider');
  const rainbowBounceVal = document.getElementById('rainbowBounceVal');
  
  rainbowRandomnessSlider && rainbowRandomnessSlider.addEventListener('input', () => {
    rainbowRandomness = parseFloat(rainbowRandomnessSlider.value);
    rainbowRandomnessVal && (rainbowRandomnessVal.textContent = rainbowRandomness.toFixed(1));
  });
  
  weightRainbowSlider && weightRainbowSlider.addEventListener('input', () => {
    ballMassKg = parseFloat(weightRainbowSlider.value);
    weightRainbowVal && (weightRainbowVal.textContent = ballMassKg.toFixed(2));
    // Apply shared mass to all balls
    for (let i=0; i<balls.length; i++) { balls[i].m = ballMassKg; }
    // Recompute derived scaling so gravity visibly changes with weight
    recomputeMassDerivedScales();
    autoSaveSettings();
  });
  rainbowDropDelaySlider && rainbowDropDelaySlider.addEventListener('input', () => {
    rainbowDropDelay = parseFloat(rainbowDropDelaySlider.value);
    rainbowDropDelayVal && (rainbowDropDelayVal.textContent = rainbowDropDelay.toFixed(2));
  });
  rainbowGravitySlider && rainbowGravitySlider.addEventListener('input', () => {
    rainbowGravity = parseFloat(rainbowGravitySlider.value);
    rainbowGravityVal && (rainbowGravityVal.textContent = rainbowGravity.toFixed(1));
    if (currentMode === MODES.RAINBOW) {
      gravityMultiplier = rainbowGravity;
      G = GE * gravityMultiplier;
    }
  });
  rainbowBounceSlider && rainbowBounceSlider.addEventListener('input', () => {
    rainbowBounce = parseFloat(rainbowBounceSlider.value);
    rainbowBounceVal && (rainbowBounceVal.textContent = rainbowBounce.toFixed(2));
  });

  // Individual color picker listeners (with existing ball color update)
  function updateExistingBallColors() {
    // Update colors of existing balls to use new color palette
    for (let i = 0; i < balls.length; i++) {
      balls[i].color = pickRandomColor();
    }
  }
  
  color1 && color1.addEventListener('input', () => { currentColors[0] = color1.value; color1Val && (color1Val.textContent = color1.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color2 && color2.addEventListener('input', () => { currentColors[1] = color2.value; color2Val && (color2Val.textContent = color2.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color3 && color3.addEventListener('input', () => { currentColors[2] = color3.value; color3Val && (color3Val.textContent = color3.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color4 && color4.addEventListener('input', () => { currentColors[3] = color4.value; color4Val && (color4Val.textContent = color4.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color5 && color5.addEventListener('input', () => { currentColors[4] = color5.value; color5Val && (color5Val.textContent = color5.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color6 && color6.addEventListener('input', () => { currentColors[5] = color6.value; color6Val && (color6Val.textContent = color6.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color7 && color7.addEventListener('input', () => { currentColors[6] = color7.value; color7Val && (color7Val.textContent = color7.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color8 && color8.addEventListener('input', () => { currentColors[7] = color8.value; color8Val && (color8Val.textContent = color8.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  cursorColorSelect && cursorColorSelect.addEventListener('change', () => { const idx = Math.max(1, Math.min(8, parseInt(cursorColorSelect.value, 10))) - 1; cursorBallIndex = idx; cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor; });

  // Bind click-to-copy on hex badges
  bindCopyOnClick(color1Val, () => color1.value.toUpperCase());
  bindCopyOnClick(color2Val, () => color2.value.toUpperCase());
  bindCopyOnClick(color3Val, () => color3.value.toUpperCase());
  bindCopyOnClick(color4Val, () => color4.value.toUpperCase());
  bindCopyOnClick(color5Val, () => color5.value.toUpperCase());
  bindCopyOnClick(color6Val, () => color6.value.toUpperCase());
  bindCopyOnClick(color7Val, () => color7.value.toUpperCase());
  bindCopyOnClick(color8Val, () => color8.value.toUpperCase());
  // If the user changes any color, keep the cursor color stable unless it was the one changed
  // To keep behavior simple, we do not auto-switch the cursor color here.
  
  // Scene control event listeners
  cornerRadiusSlider && cornerRadiusSlider.addEventListener('input', () => { 
    cornerRadius = parseFloat(cornerRadiusSlider.value); 
    cornerRadiusVal && (cornerRadiusVal.textContent = cornerRadius.toFixed(0)); 
  });
  trailFadeSlider && trailFadeSlider.addEventListener('input', () => { 
    trailFade = parseFloat(trailFadeSlider.value); 
    trailFadeVal && (trailFadeVal.textContent = trailFade.toFixed(3)); 
  });
  trailSubtletySlider && trailSubtletySlider.addEventListener('input', () => {
    trailSubtlety = parseFloat(trailSubtletySlider.value);
    trailSubtletyVal && (trailSubtletyVal.textContent = trailSubtlety.toFixed(2) + '√ó');
  });

  // Presets (10 each)
  // Rubber-focused physics presets under Earth gravity (‚âà1960 px/s¬≤)
  const PHYSICS_PRESETS = {
    rubberPlayground: { label: 'Rubber ‚Äì Playground', G: 1960, REST: 0.90, FRICTION: 0.0025, sizeScale: 1.8, maxBalls: 450, sizeVariation: 0.20 },
    rubberRacquet:    { label: 'Rubber ‚Äì Racquetball', G: 3320, REST: 0.97, FRICTION: 0.0035, sizeScale: 2.1, maxBalls: 350, sizeVariation: 0.30 },
    rubberSuperball:  { label: 'Rubber ‚Äì Superball', G: 1960, REST: 0.95, FRICTION: 0.0015, sizeScale: 1.2, maxBalls: 450, sizeVariation: 0.05 },
    rubberSoft:       { label: 'Rubber ‚Äì Soft', G: 1960, REST: 0.86, FRICTION: 0.0035, sizeScale: 2.2, maxBalls: 350, sizeVariation: 0.25 },
    rubberHeavy:      { label: 'Rubber ‚Äì Heavy', G: 1960, REST: 0.88, FRICTION: 0.0030, sizeScale: 2.0, maxBalls: 400, sizeVariation: 0.15 }
  };

  const SPAWN_PRESETS = {
    fullRain:       { label: 'Full Rain (top-half)', EMIT_INTERVAL: 0.030, xCenter: 50, y: -50, w: 100, h: 50 },
    narrowStrip:    { label: 'Narrow Strip Top', EMIT_INTERVAL: 0.050, xCenter: 50, y: -40, w: 20,  h: 10 },
    leftGutter:     { label: 'Left Gutter', EMIT_INTERVAL: 0.045, xCenter: 10, y: -60, w: 18,  h: 20 },
    rightGutter:    { label: 'Right Gutter', EMIT_INTERVAL: 0.045, xCenter: 90, y: -60, w: 18,  h: 20 },
    centerFountain: { label: 'Center Fountain', EMIT_INTERVAL: 0.020, xCenter: 50, y: -30, w: 30,  h: 20 },
    stormBurst:     { label: 'Storm Burst', EMIT_INTERVAL: 0.005, xCenter: 50, y: -80, w: 100, h: 30 },
    slowSnow:       { label: 'Slow Snow', EMIT_INTERVAL: 0.200, xCenter: 50, y: -30, w: 100, h: 20 },
    edgeDrizzle:    { label: 'Edge Drizzle', EMIT_INTERVAL: 0.080, xCenter: 15, y: -40, w: 30,  h: 15 },
    twinColumns:    { label: 'Twin Columns', EMIT_INTERVAL: 0.030, xCenter: 30, y: -50, w: 10,  h: 40 },
    focusedBeam:    { label: 'Focused Beam', EMIT_INTERVAL: 0.015, xCenter: 50, y: -70, w: 6,   h: 12 }
  };

  const REPELLER_PRESETS = {
    off:         { label: 'Off', r: 710,   p: 27400 * 10, s: 4.4 },
    gentle:      { label: 'Gentle Breeze', r: 120, p: 2500, s: 2.5 },
    pushField:   { label: 'Push Field', r: 240, p: 8000 * 10, s: 2.0 },
    tractor:     { label: 'Tractor Push', r: 320, p: 14000 * 10, s: 1.6 },
    magnet:      { label: 'Magnet Repel', r: 200, p: 18000 * 10, s: 3.0 },
    pulse:       { label: 'Pulse Strong', r: 280, p: 22000 * 10, s: 1.2 },
    wideSoft:    { label: 'Wide Soft', r: 500, p: 8000 * 10, s: 4.5 },
    needle:      { label: 'Needle Point', r: 80,  p: 26000 * 10, s: 0.8 },
    wall:        { label: 'Invisible Wall', r: 700, p: 16000 * 10, s: 5.0 },
    singularity: { label: 'Singularity', r: 600, p: 30000 * 10, s: 0.5 }
  };

  // Shadow presets removed for better performance


  // Populate selects
  function fillSelect(select, dict, selectedKey) {
    select.innerHTML = '';
    for (const [key, val] of Object.entries(dict)) {
      const opt = document.createElement('option');
      opt.value = key; opt.textContent = val.label || key; if (key === selectedKey) opt.selected = true;
      select.appendChild(opt);
    }
  }

  const physicsSelect = document.getElementById('physicsSelect');
  const spawnSelect = document.getElementById('spawnSelect');
  const repellerSelect = document.getElementById('repellerSelect');

  if (physicsSelect) fillSelect(physicsSelect, PHYSICS_PRESETS, 'rubberRacquet');
  if (spawnSelect) fillSelect(spawnSelect, SPAWN_PRESETS, 'fullRain');
  if (repellerSelect) fillSelect(repellerSelect, REPELLER_PRESETS, 'off');
  // Populate color template dropdown
  if (colorSelect) fillSelect(colorSelect, COLOR_TEMPLATES, 'industrialTeal');

  // Helper function for UI updates
  function updateSliderAndValue(slider, valueElement, value, decimals = 0) {
    if (slider) slider.value = String(value);
    if (valueElement) valueElement.textContent = decimals > 0 ? value.toFixed(decimals) : value.toString();
  }

  // Reusable event listener factory for sliders
  // Removed unused slider listener factory

  // Apply preset helpers
  function applyPhysicsPreset(key) {
    const p = PHYSICS_PRESETS[key]; if (!p) return;
    // Keep gravity constant (1.1x Earth). Only apply REST and FRICTION from preset.
    REST = p.REST; FRICTION = p.FRICTION;
    MAX_BALLS = p.maxBalls; sizeVariation = p.sizeVariation;
    const newScale = p.sizeScale;
    sizeScale = newScale;
    // Recompute effective scale and proportionally resize existing balls
    updateEffectiveScaleAndBallSizes();
    for (let i=0; i<balls.length; i++) { balls[i].m = ballMassKg; }
    
    // Remove excess balls if new limit is lower (truncate efficiently)
    if (balls.length > MAX_BALLS) { balls.length = MAX_BALLS; }
    
    // Update UI efficiently (gravity is fixed; no slider to update)
    updateSliderAndValue(restitutionSlider, restitutionVal, REST, 2);
    updateSliderAndValue(frictionSlider, frictionVal, FRICTION, 4);
    updateSliderAndValue(sizeSliderGlobal, sizeValGlobal, sizeScale, 1);
    updateSliderAndValue(maxBallsSlider, maxBallsVal, MAX_BALLS, 0);
    updateSliderAndValue(sizeVariationSliderGlobal, sizeVariationValGlobal, sizeVariation, 1);
    
    // Apply the new size variation to existing balls
    updateExistingBallSizes();
  }
  function applySpawnPreset(key) {
    const s = SPAWN_PRESETS[key]; if (!s) return;
    EMIT_INTERVAL = s.EMIT_INTERVAL; SPAWN_X_CENTER_VW = s.xCenter; SPAWN_Y_VH = s.y; SPAWN_W_VW = s.w; SPAWN_H_VH = s.h;
    updateSliderAndValue(emitterSlider, emitterVal, EMIT_INTERVAL, 3);
    updateSliderAndValue(spawnCenterSlider, spawnCenterVal, SPAWN_X_CENTER_VW, 0);
    updateSliderAndValue(spawnYSlider, spawnYVal, SPAWN_Y_VH, 0);
    updateSliderAndValue(spawnWidthSlider, spawnWidthVal, SPAWN_W_VW, 0);
    updateSliderAndValue(spawnHeightSlider, spawnHeightVal, SPAWN_H_VH, 0);
  }
  function applyRepellerPreset(key) {
    const r = REPELLER_PRESETS[key]; if (!r) return;
    repelRadius = r.r; repelPower = r.p * (REPELLER_GLOBAL_MULTIPLIER / 20.0); // keep perceived strength consistent after global doubling
    repellerEnabled = (key !== 'off');
    updateSliderAndValue(repelSizeSlider, repelSizeVal, repelRadius, 0);
    // Sync slider to mapped power and label
    const sliderPos = powerToRepelSlider(repelPower);
    if (repelPowerSlider) repelPowerSlider.value = String(sliderPos);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    updateSliderAndValue(repelSoftSlider, repelSoftVal, repelSoft, 1);
  }
  // Shadow preset function removed

  // Apply sane defaults FIRST (before event listeners to avoid triggering them)
  applyPhysicsPreset('rubberRacquet');
  applySpawnPreset('fullRain');
  applyRepellerPreset('off');
  
  // Initialize color system
  const defaultTemplate = COLOR_TEMPLATES[currentTemplate];
  if (color1 && color1Val) { color1.value = defaultTemplate.colors[0]; color1Val.textContent = defaultTemplate.colors[0].toUpperCase(); }
  if (color2 && color2Val) { color2.value = defaultTemplate.colors[1]; color2Val.textContent = defaultTemplate.colors[1].toUpperCase(); }
  if (color3 && color3Val) { color3.value = defaultTemplate.colors[2]; color3Val.textContent = defaultTemplate.colors[2].toUpperCase(); }
  if (color4 && color4Val) { color4.value = defaultTemplate.colors[3]; color4Val.textContent = defaultTemplate.colors[3].toUpperCase(); }
  if (color5 && color5Val) { color5.value = defaultTemplate.colors[4]; color5Val.textContent = defaultTemplate.colors[4].toUpperCase(); }
  if (color6 && color6Val) { color6.value = defaultTemplate.colors[5]; color6Val.textContent = defaultTemplate.colors[5].toUpperCase(); }
  if (color7 && color7Val) { color7.value = defaultTemplate.colors[6]; color7Val.textContent = defaultTemplate.colors[6].toUpperCase(); }
  if (color8 && color8Val) { color8.value = defaultTemplate.colors[7]; color8Val.textContent = defaultTemplate.colors[7].toUpperCase(); }
  // Sync CSS variables on init
  syncPaletteVars(defaultTemplate.colors);

  // Hook presets to selects AFTER applying defaults
  physicsSelect && physicsSelect.addEventListener('change', () => applyPhysicsPreset(physicsSelect.value));
  spawnSelect && spawnSelect.addEventListener('change', () => applySpawnPreset(spawnSelect.value));
  repellerSelect && repellerSelect.addEventListener('change', () => applyRepellerPreset(repellerSelect.value));

  // Now that sizeScale is set by presets, compute responsive scale once
  updateEffectiveScaleAndBallSizes();
  
  // Initialize text colliders
  updateTextColliders();
  
  // Load saved settings from localStorage
  const settingsLoaded = loadSettings();
  
  // Apply device-specific mode visibility (hide Trail on mobile)
  applyDeviceSpecificModeVisibility();
  
  // Initialize mode (use saved mode or default to Ball Pit)
  setMode(currentMode);
  
  // Save settings on mode change or slider change
  window.addEventListener('beforeunload', saveSettings);
})();
</script>
</body>
</html>
