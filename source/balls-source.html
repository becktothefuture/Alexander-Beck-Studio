<!DOCTYPE html><!--  This site was created in Webflow. https://webflow.com  --><!--  Last Published: Fri Sep 26 2025 23:30:05 GMT+0000 (Coordinated Universal Time)  -->
<html data-wf-page="68cee53d847dda2fd5c39cf1" data-wf-site="68cee53c847dda2fd5c39ce4">
<head>
  <meta charset="utf-8">
  <title>Alexander Beck Studio :: Al Creative :: User Experience :: Product Design</title>
  <meta content="c366" name="description">
  <meta content="width=device-width, initial-scale=1" name="viewport">
  <meta content="Webflow" name="generator">
  <link href="css/normalize.css" rel="stylesheet" type="text/css">
  <link href="css/webflow.css" rel="stylesheet" type="text/css">
  <link href="css/alexander-beck-studio-staging.webflow.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com" rel="preconnect">
  <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin="anonymous">
  <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js" type="text/javascript"></script>
  <script type="text/javascript">WebFont.load({  google: {    families: ["Geist Mono:100,regular,800","Geist:200,regular,600,800"]  }});</script>
  <script type="text/javascript">!function(o,c){var n=c.documentElement,t=" w-mod-";n.className+=t+"js",("ontouchstart"in o||o.DocumentTouch&&c instanceof DocumentTouch)&&(n.className+=t+"touch")}(window,document);</script>
  <link href="images/favicon.ico" rel="shortcut icon" type="image/x-icon">
  <link href="images/webclip.png" rel="apple-touch-icon">
<style>
  /* Ball simulation styles */
  #bravia-balls {
    position: fixed; top: 0; left: 0; width: 100vw; height: 150vh; z-index: -1;
    pointer-events: auto; overflow: hidden;
    user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
  }
  #bravia-balls canvas { 
    display: block; 
    width: 100%; 
    height: 100%; 
    position: absolute;
    bottom: 0;
    left: 0;
    filter: blur(0.5px) contrast(1.05); 
    user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
  }
  @media (prefers-reduced-motion: reduce) { 
    #bravia-balls canvas { filter: none; } 
  }
  #bravia-balls .panel {
    position: fixed; top: 5vh; right: 5vw; z-index: 1000; 
    background: rgba(0,0,0,0.85); color: white; padding: 20px; border-radius: 8px;
    font-family: 'Geist Mono', monospace; font-size: 12px; line-height: 1.4;
    max-width: 320px; max-height: 85vh; overflow-y: auto;
    backdrop-filter: blur(10px); border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 8px 32px rgba(0,0,0,0.3);
  }
  #bravia-balls .panel h3 { margin: 0 0 15px 0; font-size: 14px; font-weight: 600; }
  #bravia-balls .panel .section { margin-bottom: 20px; }
  #bravia-balls .panel .section:last-child { margin-bottom: 0; }
  #bravia-balls .panel label { display: block; margin-bottom: 8px; font-weight: 500; }
  #bravia-balls .panel input[type="range"] { width: 100%; margin-bottom: 5px; }
  #bravia-balls .panel input[type="number"] { width: 60px; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 4px 6px; border-radius: 4px; }
  #bravia-balls .panel select { width: 100%; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 6px; border-radius: 4px; }
  #bravia-balls .panel button { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; margin-right: 8px; margin-bottom: 8px; }
  #bravia-balls .panel button:hover { background: rgba(255,255,255,0.2); }
  #bravia-balls .panel .value { color: #4CAF50; font-weight: 600; }
  #bravia-balls .panel .fps { color: #2196F3; font-weight: 600; }
  #bravia-balls .panel .toggle { display: none; }
  #bravia-balls .panel .toggle + label { cursor: pointer; user-select: none; }
  #bravia-balls .panel .toggle + label:before { content: '▶ '; }
  #bravia-balls .panel .toggle:checked + label:before { content: '▼ '; }
  #bravia-balls .panel .collapsible { max-height: 0; overflow: hidden; transition: max-height 0.3s ease; }
  #bravia-balls .panel .toggle:checked + label + .collapsible { max-height: 500px; }
</style>
</head>
<body class="body">
  <div class="noise"></div>
  <div id="bravia-balls" class="ball-simulation w-embed"><canvas id="c" aria-label="Bouncy balls" role="img" draggable="false"></canvas></div>
  <section></section>
  <section></section>
  <section></section>
  <header class="viewport is-rounded">
    <div id="w-node-e6a615f7-c7b2-8768-3157-95ffa1ec0a09-d5c39cf1" class="legend">
      <div class="w-layout-hflex legend__item">
        <div class="circle"></div>
        <div>Creative Strategy</div>
  </div>
      <div class="w-layout-hflex legend__item">
        <div class="circle"></div>
        <div>Visual Design</div>
  </div>
      <div class="w-layout-hflex legend__item">
        <div class="circle"></div>
        <div>Precision Typography</div>
      </div>
      <div class="w-layout-hflex legend__item">
        <div class="circle"></div>
        <div>Design Strategy</div>
      </div>
      <div class="w-layout-hflex legend__item">
        <div class="circle"></div>
        <div>Brand &amp; Experience</div>
        </div>
      <div class="w-layout-hflex legend__item">
        <div class="circle"></div>
        <div>AI Technologist</div>
      </div>
    </div>
    <div id="w-node-eebae829-2c96-48a2-0317-608359a35cec-d5c39cf1" class="div-block"></div>
    <div id="w-node-_38b28c23-04bb-05c7-72ee-2ae65152e2c6-d5c39cf1" class="header is-align-center">
      <div class="hero__text w-embed"><svg viewbox="0 0 921 123" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M1.76 93L24.288 30.52H34.496L57.024 93H48.752L42.504 75.224H16.28L10.032 93H1.76ZM18.832 67.832H39.952L29.392 37.12L18.832 67.832ZM72.3333 93C69.6346 93 67.4346 92.296 65.7333 90.888C64.0319 89.48 63.1813 87.2507 63.1813 84.2V30.52H70.5733V83.584C70.5733 84.5227 70.8079 85.256 71.2773 85.784C71.8053 86.2533 72.5386 86.488 73.4773 86.488H77.5253V93H72.3333ZM102.218 94.056C97.8182 94.056 94.0049 93.0587 90.7782 91.064C87.6102 89.0693 85.1462 86.2533 83.3862 82.616C81.6849 78.92 80.8342 74.608 80.8342 69.68C80.8342 64.752 81.6849 60.4693 83.3862 56.832C85.1462 53.1947 87.5809 50.3787 90.6902 48.384C93.8582 46.3307 97.5835 45.304 101.866 45.304C105.914 45.304 109.493 46.272 112.602 48.208C115.712 50.0853 118.117 52.8427 119.818 56.48C121.578 60.1173 122.458 64.5467 122.458 69.768V71.968H88.5782C88.8715 76.9547 90.1915 80.7093 92.5382 83.232C94.9435 85.7547 98.1702 87.016 102.218 87.016C105.269 87.016 107.762 86.312 109.698 84.904C111.693 83.4373 113.072 81.5307 113.834 79.184L121.754 79.8C120.522 83.9653 118.176 87.3973 114.714 90.096C111.312 92.736 107.146 94.056 102.218 94.056ZM88.5782 65.456H114.362C114.01 60.9387 112.69 57.624 110.402 55.512C108.173 53.4 105.328 52.344 101.866 52.344C98.2875 52.344 95.3249 53.4587 92.9782 55.688C90.6902 57.8587 89.2235 61.1147 88.5782 65.456ZM126.906 93L144.066 69.064L127.786 46.36H136.41L148.642 63.96L160.522 46.36H169.322L153.218 69.24L170.114 93H161.49L148.642 74.168L135.706 93H126.906ZM192.551 94.056C188.092 94.056 184.396 92.9413 181.463 90.712C178.588 88.4827 176.418 85.52 174.951 81.824C173.543 78.128 172.839 74.08 172.839 69.68C172.839 65.3387 173.543 61.32 174.951 57.624C176.359 53.928 178.5 50.9653 181.375 48.736C184.308 46.448 188.004 45.304 192.463 45.304C195.924 45.304 198.858 45.9787 201.263 47.328C203.727 48.6773 205.604 50.5253 206.895 52.872V46.36H214.287V93H207.599L207.247 82.44L208.303 83.32C207.658 85.4907 206.602 87.3973 205.135 89.04C203.727 90.624 201.967 91.856 199.855 92.736C197.743 93.616 195.308 94.056 192.551 94.056ZM194.047 87.016C197.274 87.016 199.796 86.1947 201.615 84.552C203.492 82.8507 204.842 80.68 205.663 78.04C206.484 75.3413 206.895 72.5547 206.895 69.68C206.895 66.6293 206.484 63.8133 205.663 61.232C204.842 58.592 203.492 56.4507 201.615 54.808C199.796 53.1653 197.274 52.344 194.047 52.344C190.938 52.344 188.386 53.1653 186.391 54.808C184.396 56.392 182.93 58.504 181.991 61.144C181.052 63.7253 180.583 66.5707 180.583 69.68C180.583 72.6133 181.023 75.4293 181.903 78.128C182.842 80.768 184.308 82.9093 186.303 84.552C188.298 86.1947 190.879 87.016 194.047 87.016ZM225.703 93V46.36H232.479L232.743 58.24L231.863 57.448C232.449 54.6907 233.476 52.432 234.943 50.672C236.409 48.8533 238.169 47.504 240.223 46.624C242.335 45.744 244.593 45.304 246.999 45.304C250.577 45.304 253.511 46.096 255.799 47.68C258.145 49.264 259.876 51.4053 260.991 54.104C262.164 56.744 262.751 59.7067 262.751 62.992V93H255.359V65.104C255.359 62.2293 255.007 59.824 254.303 57.888C253.657 55.8933 252.601 54.3973 251.135 53.4C249.668 52.344 247.761 51.816 245.415 51.816C241.836 51.816 238.873 52.96 236.527 55.248C234.239 57.4773 233.095 60.7627 233.095 65.104V93H225.703ZM290.74 94.056C286.692 94.056 283.172 93.0587 280.18 91.064C277.246 89.0693 274.988 86.2533 273.404 82.616C271.82 78.9787 271.028 74.6667 271.028 69.68C271.028 64.6933 271.82 60.3813 273.404 56.744C274.988 53.1067 277.246 50.2907 280.18 48.296C283.172 46.3013 286.692 45.304 290.74 45.304C293.849 45.304 296.694 45.9787 299.276 47.328C301.857 48.6187 303.793 50.4667 305.084 52.872V30.52H312.476V93H305.788L305.524 85.96C304.233 88.4827 302.268 90.4773 299.628 91.944C296.988 93.352 294.025 94.056 290.74 94.056ZM292.236 87.016C294.993 87.016 297.31 86.312 299.188 84.904C301.124 83.496 302.59 81.5013 303.588 78.92C304.585 76.28 305.084 73.2 305.084 69.68C305.084 66.0427 304.585 62.9333 303.588 60.352C302.59 57.7707 301.124 55.8053 299.188 54.456C297.31 53.048 294.993 52.344 292.236 52.344C288.129 52.344 284.844 53.8987 282.38 57.008C279.974 60.0587 278.772 64.2827 278.772 69.68C278.772 75.0187 279.974 79.2427 282.38 82.352C284.844 85.4613 288.129 87.016 292.236 87.016ZM342.108 94.056C337.708 94.056 333.894 93.0587 330.668 91.064C327.5 89.0693 325.036 86.2533 323.276 82.616C321.574 78.92 320.724 74.608 320.724 69.68C320.724 64.752 321.574 60.4693 323.276 56.832C325.036 53.1947 327.47 50.3787 330.58 48.384C333.748 46.3307 337.473 45.304 341.756 45.304C345.804 45.304 349.382 46.272 352.492 48.208C355.601 50.0853 358.006 52.8427 359.708 56.48C361.468 60.1173 362.348 64.5467 362.348 69.768V71.968H328.468C328.761 76.9547 330.081 80.7093 332.428 83.232C334.833 85.7547 338.06 87.016 342.108 87.016C345.158 87.016 347.652 86.312 349.588 84.904C351.582 83.4373 352.961 81.5307 353.724 79.184L361.644 79.8C360.412 83.9653 358.065 87.3973 354.604 90.096C351.201 92.736 347.036 94.056 342.108 94.056ZM328.468 65.456H354.252C353.9 60.9387 352.58 57.624 350.292 55.512C348.062 53.4 345.217 52.344 341.756 52.344C338.177 52.344 335.214 53.4587 332.868 55.688C330.58 57.8587 329.113 61.1147 328.468 65.456ZM370.58 93V46.36H377.092L377.444 58.152L376.74 57.888C377.326 53.8987 378.588 50.9947 380.524 49.176C382.518 47.2987 385.158 46.36 388.444 46.36H393.02V53.4H388.532C386.185 53.4 384.22 53.84 382.636 54.72C381.11 55.5413 379.937 56.8027 379.116 58.504C378.353 60.1467 377.972 62.2587 377.972 64.84V93H370.58ZM419.059 93V30.52H440.531C447.923 30.52 453.467 31.8693 457.163 34.568C460.859 37.2667 462.707 41.52 462.707 47.328C462.707 50.0267 462.121 52.4027 460.947 54.456C459.774 56.5093 458.102 58.1227 455.931 59.296C453.761 60.4107 451.179 60.968 448.187 60.968L448.099 60.44C453.438 60.44 457.633 61.8773 460.683 64.752C463.793 67.568 465.347 71.264 465.347 75.84C465.347 81.5307 463.499 85.8133 459.803 88.688C456.107 91.5627 450.857 93 444.051 93H419.059ZM426.627 85.608H444.051C448.334 85.608 451.619 84.728 453.907 82.968C456.254 81.208 457.427 78.6853 457.427 75.4C457.427 72.1147 456.254 69.5627 453.907 67.744C451.619 65.8667 448.334 64.928 444.051 64.928H426.627V85.608ZM426.627 57.536H440.531C445.107 57.536 448.627 56.6853 451.091 54.984C453.555 53.224 454.787 50.7893 454.787 47.68C454.787 44.3947 453.585 41.96 451.179 40.376C448.833 38.7333 445.283 37.912 440.531 37.912H426.627V57.536ZM492.512 94.056C488.112 94.056 484.299 93.0587 481.072 91.064C477.904 89.0693 475.44 86.2533 473.68 82.616C471.979 78.92 471.128 74.608 471.128 69.68C471.128 64.752 471.979 60.4693 473.68 56.832C475.44 53.1947 477.875 50.3787 480.984 48.384C484.152 46.3307 487.877 45.304 492.16 45.304C496.208 45.304 499.787 46.272 502.896 48.208C506.005 50.0853 508.411 52.8427 510.112 56.48C511.872 60.1173 512.752 64.5467 512.752 69.768V71.968H478.872C479.165 76.9547 480.485 80.7093 482.832 83.232C485.237 85.7547 488.464 87.016 492.512 87.016C495.563 87.016 498.056 86.312 499.992 84.904C501.987 83.4373 503.365 81.5307 504.128 79.184L512.048 79.8C510.816 83.9653 508.469 87.3973 505.008 90.096C501.605 92.736 497.44 94.056 492.512 94.056ZM478.872 65.456H504.656C504.304 60.9387 502.984 57.624 500.696 55.512C498.467 53.4 495.621 52.344 492.16 52.344C488.581 52.344 485.619 53.4587 483.272 55.688C480.984 57.8587 479.517 61.1147 478.872 65.456ZM540.08 94.056C535.739 94.056 531.955 93.0587 528.728 91.064C525.56 89.0693 523.096 86.2533 521.336 82.616C519.576 78.92 518.696 74.608 518.696 69.68C518.696 64.752 519.576 60.4693 521.336 56.832C523.096 53.1947 525.56 50.3787 528.728 48.384C531.955 46.3307 535.739 45.304 540.08 45.304C543.659 45.304 546.827 45.9493 549.584 47.24C552.4 48.472 554.688 50.2907 556.448 52.696C558.208 55.1013 559.352 58.0347 559.88 61.496L552.136 62.024C551.608 58.9147 550.259 56.5387 548.088 54.896C545.917 53.1947 543.248 52.344 540.08 52.344C535.797 52.344 532.453 53.8987 530.048 57.008C527.643 60.0587 526.44 64.2827 526.44 69.68C526.44 75.0773 527.643 79.3307 530.048 82.44C532.453 85.4907 535.797 87.016 540.08 87.016C543.248 87.016 545.917 86.136 548.088 84.376C550.259 82.616 551.608 79.976 552.136 76.456L559.88 76.984C559.352 80.4453 558.208 83.4667 556.448 86.048C554.688 88.5707 552.4 90.536 549.584 91.944C546.827 93.352 543.659 94.056 540.08 94.056ZM567.263 93V30.52H574.655V71.44L597.359 46.36H607.215L588.823 66.16L608.007 93H599.031L583.807 71.176L574.655 80.856V93H567.263ZM655.777 94.408C650.967 94.408 646.772 93.4987 643.193 91.68C639.615 89.8613 636.769 87.368 634.657 84.2C632.604 80.9733 631.401 77.248 631.049 73.024L638.969 72.496C639.38 75.6053 640.289 78.2453 641.697 80.416C643.105 82.5867 644.983 84.2293 647.329 85.344C649.735 86.4587 652.609 87.016 655.953 87.016C658.887 87.016 661.38 86.6347 663.433 85.872C665.487 85.1093 667.041 83.9947 668.097 82.528C669.212 81.0613 669.769 79.272 669.769 77.16C669.769 75.224 669.3 73.5227 668.361 72.056C667.481 70.5307 665.751 69.152 663.169 67.92C660.647 66.6293 656.892 65.368 651.905 64.136C647.095 62.904 643.252 61.5547 640.377 60.088C637.561 58.6213 635.508 56.832 634.217 54.72C632.985 52.608 632.369 49.9973 632.369 46.888C632.369 43.368 633.191 40.288 634.833 37.648C636.535 34.9493 638.94 32.8667 642.049 31.4C645.159 29.8747 648.855 29.112 653.137 29.112C657.713 29.112 661.644 29.992 664.929 31.752C668.215 33.4533 670.825 35.8 672.761 38.792C674.697 41.784 675.9 45.1867 676.369 49L668.449 49.528C668.097 47.0053 667.276 44.776 665.985 42.84C664.753 40.8453 663.052 39.2907 660.881 38.176C658.711 37.0613 656.071 36.504 652.961 36.504C649.089 36.504 646.009 37.4427 643.721 39.32C641.433 41.1387 640.289 43.544 640.289 46.536C640.289 48.472 640.729 50.0853 641.609 51.376C642.548 52.608 644.191 53.7227 646.537 54.72C648.884 55.6587 652.257 56.6853 656.657 57.8C661.879 59.0907 666.015 60.6453 669.065 62.464C672.175 64.224 674.375 66.2773 675.665 68.624C677.015 70.9707 677.689 73.64 677.689 76.632C677.689 80.2693 676.751 83.4373 674.873 86.136C672.996 88.776 670.415 90.8293 667.129 92.296C663.844 93.704 660.06 94.408 655.777 94.408ZM702.21 93C697.986 93 694.848 92.032 692.794 90.096C690.8 88.16 689.802 85.1387 689.802 81.032V35.448H697.194V80.856C697.194 82.968 697.664 84.4347 698.602 85.256C699.541 86.0773 700.978 86.488 702.914 86.488H709.602V93H702.21ZM682.938 52.872V46.36H709.602V52.872H682.938ZM732.271 94.056C727.637 94.056 723.911 92.5013 721.095 89.392C718.338 86.224 716.959 81.8827 716.959 76.368V46.36H724.351V74.344C724.351 78.8613 725.143 82.2053 726.727 84.376C728.37 86.488 730.863 87.544 734.207 87.544C737.903 87.544 740.807 86.3707 742.919 84.024C745.031 81.6187 746.087 78.3333 746.087 74.168V46.36H753.479V93H746.439V81.472L747.583 82.088C746.645 85.9013 744.855 88.864 742.215 90.976C739.575 93.0293 736.261 94.056 732.271 94.056ZM781.481 94.056C777.433 94.056 773.913 93.0587 770.921 91.064C767.987 89.0693 765.729 86.2533 764.145 82.616C762.561 78.9787 761.769 74.6667 761.769 69.68C761.769 64.6933 762.561 60.3813 764.145 56.744C765.729 53.1067 767.987 50.2907 770.921 48.296C773.913 46.3013 777.433 45.304 781.481 45.304C784.59 45.304 787.435 45.9787 790.017 47.328C792.598 48.6187 794.534 50.4667 795.825 52.872V30.52H803.217V93H796.529L796.265 85.96C794.974 88.4827 793.009 90.4773 790.369 91.944C787.729 93.352 784.766 94.056 781.481 94.056ZM782.977 87.016C785.734 87.016 788.051 86.312 789.929 84.904C791.865 83.496 793.331 81.5013 794.329 78.92C795.326 76.28 795.825 73.2 795.825 69.68C795.825 66.0427 795.326 62.9333 794.329 60.352C793.331 57.7707 791.865 55.8053 789.929 54.456C788.051 53.048 785.734 52.344 782.977 52.344C778.87 52.344 775.585 53.8987 773.121 57.008C770.715 60.0587 769.513 64.2827 769.513 69.68C769.513 75.0187 770.715 79.2427 773.121 82.352C775.585 85.4613 778.87 87.016 782.977 87.016ZM814.632 93V46.36H822.024V93H814.632ZM818.416 39.32C817.184 39.32 816.158 38.9387 815.336 38.176C814.574 37.3547 814.192 36.2693 814.192 34.92C814.192 33.6293 814.574 32.5733 815.336 31.752C816.158 30.9307 817.184 30.52 818.416 30.52C819.648 30.52 820.646 30.9307 821.408 31.752C822.23 32.5733 822.64 33.6293 822.64 34.92C822.64 36.2693 822.23 37.3547 821.408 38.176C820.646 38.9387 819.648 39.32 818.416 39.32ZM851.693 94.056C847.41 94.056 843.656 93.0587 840.429 91.064C837.202 89.0693 834.709 86.2533 832.949 82.616C831.189 78.92 830.309 74.608 830.309 69.68C830.309 64.6933 831.189 60.3813 832.949 56.744C834.709 53.1067 837.202 50.2907 840.429 48.296C843.656 46.3013 847.41 45.304 851.693 45.304C855.976 45.304 859.701 46.3013 862.869 48.296C866.096 50.2907 868.589 53.1067 870.349 56.744C872.109 60.3813 872.989 64.6933 872.989 69.68C872.989 74.608 872.109 78.92 870.349 82.616C868.589 86.2533 866.096 89.0693 862.869 91.064C859.701 93.0587 855.976 94.056 851.693 94.056ZM851.693 87.016C855.976 87.016 859.29 85.4907 861.637 82.44C864.042 79.3307 865.245 75.0773 865.245 69.68C865.245 64.2827 864.042 60.0587 861.637 57.008C859.29 53.8987 855.976 52.344 851.693 52.344C847.41 52.344 844.066 53.8987 841.661 57.008C839.256 60.0587 838.053 64.2827 838.053 69.68C838.053 75.0773 839.256 79.3307 841.661 82.44C844.066 85.4907 847.41 87.016 851.693 87.016Z" fill="#161616" style="fill:#161616;fill:color(display-p3 0.0863 0.0863 0.0863);fill-opacity:1;"></path>
          <ellipse cx="904" cy="50.9883" rx="16" ry="16" stroke="black" style="stroke:black;stroke-opacity:1;" stroke-width="1.5578"></ellipse>
          <path d="M909.046 44.9121C910.191 44.9121 911.157 45.2424 911.837 45.8262C912.518 46.4108 912.908 47.2457 912.908 48.2432C912.908 49.4861 912.309 50.4595 911.38 50.7969C912.714 51.1016 913.594 52.194 913.594 53.6748C913.594 55.6619 911.973 57.0575 909.731 57.0576H905.715V44.9121H909.046ZM907.116 55.6562H909.731C910.436 55.6562 911.031 55.4466 911.447 55.0898C911.863 54.7337 912.106 54.2277 912.106 53.624C912.106 53.0203 911.863 52.5144 911.447 52.1582C911.031 51.8013 910.436 51.5909 909.731 51.5908H907.116V55.6562ZM907.116 50.1904H909.046C909.76 50.1904 910.355 49.9887 910.77 49.6465C911.183 49.3052 911.421 48.8204 911.421 48.2432C911.421 47.6656 911.187 47.1854 910.776 46.8486C910.364 46.5108 909.77 46.3135 909.046 46.3135H907.116V50.1904Z" fill="black" stroke="black" style="fill:black;fill-opacity:1;stroke:black;stroke-opacity:1;" stroke-width="0.150092"></path>
          <path d="M900.007 44.9121L900.024 44.9629L904.154 56.958L904.188 57.0576H902.677L902.659 57.0068L901.34 53.1846H896.632L895.312 57.0068L895.295 57.0576H893.782L893.816 56.958L897.946 44.9629L897.964 44.9121H900.007ZM897.111 51.7842H900.859L898.993 46.3486L897.111 51.7842Z" fill="black" stroke="black" style="fill:black;fill-opacity:1;stroke:black;stroke-opacity:1;" stroke-width="0.150092"></path>
        </svg></div>
    </div>
    <ul role="list" aria-label="Social media links" id="w-node-a3bdcba3-22cc-d78c-cb19-91003b154f3e-d5c39cf1" class="footer_icon-group w-list-unstyled">
      <li class="margin-bottom_none">
        <a href="#" class="footer_icon-link w-inline-block"><svg width="100%" height="100%" viewbox="0 0 16 16">
            <path d="M16,8.048a8,8,0,1,0-9.25,7.9V10.36H4.719V8.048H6.75V6.285A2.822,2.822,0,0,1,9.771,3.173a12.2,12.2,0,0,1,1.791.156V5.3H10.554a1.155,1.155,0,0,0-1.3,1.25v1.5h2.219l-.355,2.312H9.25v5.591A8,8,0,0,0,16,8.048Z" fill="currentColor"></path>
          </svg>
          <div class="screen-reader">Facebook</div>
        </a>
      </li>
      <li class="margin-bottom_none">
        <a href="#" class="footer_icon-link w-inline-block"><svg width="100%" height="100%" viewbox="0 0 16 16">
            <path d="M8,1.441c2.136,0,2.389.009,3.233.047a4.419,4.419,0,0,1,1.485.276,2.472,2.472,0,0,1,.92.6,2.472,2.472,0,0,1,.6.92,4.419,4.419,0,0,1,.276,1.485c.038.844.047,1.1.047,3.233s-.009,2.389-.047,3.233a4.419,4.419,0,0,1-.276,1.485,2.644,2.644,0,0,1-1.518,1.518,4.419,4.419,0,0,1-1.485.276c-.844.038-1.1.047-3.233.047s-2.389-.009-3.233-.047a4.419,4.419,0,0,1-1.485-.276,2.472,2.472,0,0,1-.92-.6,2.472,2.472,0,0,1-.6-.92,4.419,4.419,0,0,1-.276-1.485c-.038-.844-.047-1.1-.047-3.233s.009-2.389.047-3.233a4.419,4.419,0,0,1,.276-1.485,2.472,2.472,0,0,1,.6-.92,2.472,2.472,0,0,1,.92-.6,4.419,4.419,0,0,1,1.485-.276c.844-.038,1.1-.047,3.233-.047M8,0C5.827,0,5.555.009,4.7.048A5.868,5.868,0,0,0,2.76.42a3.908,3.908,0,0,0-1.417.923A3.908,3.908,0,0,0,.42,2.76,5.868,5.868,0,0,0,.048,4.7C.009,5.555,0,5.827,0,8s.009,2.445.048,3.3A5.868,5.868,0,0,0,.42,13.24a3.908,3.908,0,0,0,.923,1.417,3.908,3.908,0,0,0,1.417.923,5.868,5.868,0,0,0,1.942.372C5.555,15.991,5.827,16,8,16s2.445-.009,3.3-.048a5.868,5.868,0,0,0,1.942-.372,4.094,4.094,0,0,0,2.34-2.34,5.868,5.868,0,0,0,.372-1.942c.039-.853.048-1.125.048-3.3s-.009-2.445-.048-3.3A5.868,5.868,0,0,0,15.58,2.76a3.908,3.908,0,0,0-.923-1.417A3.908,3.908,0,0,0,13.24.42,5.868,5.868,0,0,0,11.3.048C10.445.009,10.173,0,8,0Z" fill="currentColor"></path>
            <path d="M8,3.892A4.108,4.108,0,1,0,12.108,8,4.108,4.108,0,0,0,8,3.892Zm0,6.775A2.667,2.667,0,1,1,10.667,8,2.667,2.667,0,0,1,8,10.667Z" fill="currentColor"></path>
            <circle cx="12.27" cy="3.73" r="0.96" fill="currentColor"></circle>
          </svg>
          <div class="screen-reader">Instagram<br></div>
        </a>
      </li>
      <li class="margin-bottom_none">
        <a href="#" class="footer_icon-link w-inline-block"><svg width="100%" height="100%" viewbox="0 0 16 16">
            <path d="M15.3,0H0.7C0.3,0,0,0.3,0,0.7v14.7C0,15.7,0.3,16,0.7,16h14.7c0.4,0,0.7-0.3,0.7-0.7V0.7 C16,0.3,15.7,0,15.3,0z M4.7,13.6H2.4V6h2.4V13.6z M3.6,5C2.8,5,2.2,4.3,2.2,3.6c0-0.8,0.6-1.4,1.4-1.4c0.8,0,1.4,0.6,1.4,1.4 C4.9,4.3,4.3,5,3.6,5z M13.6,13.6h-2.4V9.9c0-0.9,0-2-1.2-2c-1.2,0-1.4,1-1.4,2v3.8H6.2V6h2.3v1h0c0.3-0.6,1.1-1.2,2.2-1.2 c2.4,0,2.8,1.6,2.8,3.6V13.6z" fill="currentColor"></path>
          </svg>
          <div class="screen-reader">LinkedIn</div>
        </a>
      </li>
    </ul>
    <a id="w-node-a3bdcba3-22cc-d78c-cb19-91003b154f55-d5c39cf1" href="mailto:alexander@beck.fyi?subject=Hello!" class="footer_link">Get in touch</a>
    <a id="w-node-a3bdcba3-22cc-d78c-cb19-91003b154f57-d5c39cf1" href="mailto:alexander@beck.fyi?subject=Hello!" class="footer_link">Portfolio Tour [offline]</a>
    <div id="w-node-a3bdcba3-22cc-d78c-cb19-91003b154f59-d5c39cf1" class="w-layout-hflex footer_caption">
      <div>Est. 2025</div>
    </div>
  </header>
  <script src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=68cee53c847dda2fd5c39ce4" type="text/javascript" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
  <script src="js/webflow.js" type="text/javascript"></script>
  
<script>
// Version: 2024-09-20 - Removed 3D rendering, simplified shadows
(() => {
  // Constants for magic numbers
  const CONSTANTS = {
    CANVAS_HEIGHT_VH: 1.5,        // 150vh canvas height
    OFFSCREEN_MOUSE: -1e9,        // Offscreen mouse position
    MIN_DISTANCE_EPSILON: 1e-6,   // Minimum distance for collision calculations
    MIN_REPEL_DISTANCE: 1e-4,     // Minimum repeller distance
    ACCUMULATOR_RESET_THRESHOLD: 3, // Reset accumulator if behind by this many frames
    INITIAL_SEED_BALLS: 200,      // Initial balls to seed
    BALL_SPAWN_OFFSET: 2,         // Offset for ball spawning
    BALL_CLUSTER_SPACING: 8,      // Spacing between clustered balls
    BALL_CLUSTER_Y_OFFSET: 12,    // Y offset for clustered balls
    MAX_PHYSICS_STEPS: 2,         // Maximum physics steps per frame
    FPS_UPDATE_INTERVAL: 1.0,     // FPS counter update interval in seconds
    // Spin & squash tuning
    SPIN_DAMP_PER_S: 2.0,         // angular damping per second
    SPIN_GAIN: 0.25,              // how strongly tangential slip converts to spin
    SPIN_GAIN_TANGENT: 0.18,      // ball–ball tangential slip to spin
    ROLL_FRICTION_PER_S: 1.5,     // rolling friction for horizontal speed per second when grounded
    SQUASH_MAX: 0.20,             // maximum squash amount (moderate, prevents elongated look)
    SQUASH_DECAY_PER_S: 18.0,     // faster relaxation for snappy feel
    WALL_REST_VEL_THRESHOLD: 70,  // below this, wall bounce becomes inelastic (settles)
    GROUND_COUPLING_PER_S: 8.0    // match roll (vx) to spin (omega) when grounded
  };

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  const panel = document.getElementById('controlPanel');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // Spawn area controls (viewport-relative)
  // Defaults: xCenter = 50vw, y = -50vh, width = 100vw, height = 50vh
  let SPAWN_X_CENTER_VW = 50;
  let SPAWN_Y_VH = -50;
  let SPAWN_W_VW = 100;
  let SPAWN_H_VH = 50;

  // Resize canvas to 150vh (with top 50vh hidden above viewport)
  function resize() {
    const simHeight = window.innerHeight * CONSTANTS.CANVAS_HEIGHT_VH;
    canvas.width  = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(simHeight * DPR);
  }
  const setCSSSize = () => {
    // CSS size is handled by CSS (150vh, bottom-aligned)
  };
  setCSSSize(); resize();
  window.addEventListener('resize', () => { setCSSSize(); resize(); updateEffectiveScaleAndBallSizes(); updateTextColliders(); updateRepelRadius(); });

  // Physics parameters (initial)
  const GE = 1960;        // Earth gravity in px/s^2 at our scale
  let gravityMultiplier = 1.10; // 1.1× Earth
  let G = GE * gravityMultiplier;
  let REST = 0.88;        // restitution (bounciness) - from screenshot
  let FRICTION = 0.0030;  // air drag per frame - from screenshot
  let EMIT_INTERVAL = 0.030; // seconds between drops - from screenshot
  let MAX_BALLS = 400;    // from screenshot
  const SOLVER_ITERS = 6;    // Optimized for realistic collisions without jitter
  const POS_CORRECT_PERCENT = 0.8; // Reduced for more stable contacts
  const POS_CORRECT_SLOP = 0.5 * DPR; // Slightly more tolerance to prevent jitter
  const REST_VEL_THRESHOLD = 30; // Lower threshold for more realistic settling

  // Base radius values
  const R_MIN_BASE = 6;
  const R_MAX_BASE = 24;
  let sizeScale = 2.0;     // from screenshot
  let sizeVariation = 0.1; // from screenshot
  // Responsive scale: reduce ball size by 60% on mobile breakpoints (≤768px)
  let responsiveScale = 1.0;
  let lastEffectiveScale = null; // tracks previous (sizeScale * responsiveScale)
  // Global mass model: all balls share the same mass in kg
  let ballMassKg = 19.80; // from screenshot
  const MASS_BASELINE_KG = 1.0; // reference mass for scaling drag/forces
  // Mass influence tuning
  const MASS_GRAVITY_EXP = 0.35; // how much mass influences gravity (perceptual)
  const MASS_REST_EXP = 0.15;    // how much mass influences bounce restitution
  let gravityScale = 1.0;        // computed from mass
  function recomputeMassDerivedScales() {
    gravityScale = Math.max(0.5, Math.min(3.0, Math.pow(ballMassKg / MASS_BASELINE_KG, MASS_GRAVITY_EXP)));
  }
  recomputeMassDerivedScales();
  let R_MIN = R_MIN_BASE * sizeScale;
  let R_MAX = R_MAX_BASE * sizeScale;

  function computeResponsiveScale() {
    // Use canvas container width for proper embed behavior
    const containerWidth = canvas.clientWidth || window.innerWidth;
    return (containerWidth <= 768) ? 0.4 : 1.0;
  }

  function updateEffectiveScaleAndBallSizes() {
    responsiveScale = computeResponsiveScale();
    const effectiveScale = sizeScale * responsiveScale;
    if (lastEffectiveScale === null) {
      lastEffectiveScale = effectiveScale;
      R_MIN = R_MIN_BASE * effectiveScale;
      R_MAX = R_MAX_BASE * effectiveScale;
      return;
    }
    const ratio = effectiveScale / lastEffectiveScale;
    if (ratio !== 1) {
      for (let i = 0; i < balls.length; i++) {
        balls[i].r *= ratio;
      }
      lastEffectiveScale = effectiveScale;
    }
    R_MIN = R_MIN_BASE * effectiveScale;
    R_MAX = R_MAX_BASE * effectiveScale;
  }

  // Update text collision rectangles by measuring DOM elements
  function updateTextColliders() {
    textColliders = []; // Clear existing colliders
    
    const textElement = document.querySelector(TEXT_SELECTOR);
    if (!textElement) return; // No text element found
    
    const textRect = textElement.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    
    // Calculate cap height (height of capital letters only)
    const capHeight = calculateCapHeight(textElement);
    
    // Center the collision box vertically on the visual text
    const heightDifference = textRect.height - capHeight;
    const verticalOffset = heightDifference * 0.5; // Center the cap height within the full text height
    
    // Convert to canvas coordinates with device pixel ratio
    const collider = {
      x: (textRect.left - canvasRect.left) * DPR,
      y: (textRect.top - canvasRect.top + verticalOffset) * DPR,
      width: textRect.width * DPR,
      height: capHeight * DPR
    };
    
    // Only add collider if it's within canvas bounds and has valid dimensions
    if (collider.width > 0 && collider.height > 0 && 
        collider.x < canvas.width && collider.y < canvas.height &&
        collider.x + collider.width > 0 && collider.y + collider.height > 0) {
      textColliders.push(collider);
    }
  }
  
  // Calculate the cap height of text element (height of capital letters)
  function calculateCapHeight(element) {
    // Create a temporary element with just capital letters to measure cap height
    const tempElement = document.createElement('span');
    tempElement.style.cssText = window.getComputedStyle(element).cssText;
    tempElement.style.position = 'absolute';
    tempElement.style.visibility = 'hidden';
    tempElement.style.whiteSpace = 'nowrap';
    tempElement.textContent = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    
    document.body.appendChild(tempElement);
    const capHeight = tempElement.getBoundingClientRect().height;
    document.body.removeChild(tempElement);
    
    return capHeight;
  }

  // Emitter sweep (natural hand-like motion across the top band)
  let EMITTER_SWEEP_ENABLED = true;
  let emitterPhase = 0;                 // radians
  const EMITTER_SWEEP_HZ = 0.12;        // cycles per second
  const EMITTER_SWEEP_AMPL_VW = 20;     // sweep amplitude in vw
  let emitterSweepDir = 1;              // +1 sweeping right, -1 sweeping left (derived)

  // 8-Color system with weighted distribution (50%, 25%, 12%, 6%, 3%, 2%, 1%, 1%)
  // Color 1 (50%): Dominant/background color
  // Color 2 (25%): Secondary color  
  // Color 3 (15%): Tertiary color
  // Color 4 (7.5%): Accent color
  // Color 5 (2.5%): Rare/special color
  const COLOR_TEMPLATES = {
    industrialTeal: { label: 'Industrial Teal', colors: ['#b7bcb7', '#e4e9e4', '#ffffff', '#00695c', '#000000', '#ff4013', '#0d5cb6', '#ffa000'] },
    modern: { label: 'Modern European', colors: ['#9ca3af', '#d1d5db', '#ffffff', '#ff3b30', '#000000', '#00e5ff', '#1976d2', '#ffc107'] },
    corporate: { label: 'Corporate Modern', colors: ['#a0a8b1', '#d2d8de', '#ffffff', '#1a73e8', '#000000', '#ff5722', '#7b1fa2', '#ffa000'] },
    minimal: { label: 'Helvetica Minimal', colors: ['#bdbdbd', '#e0e0e0', '#ffffff', '#6b7280', '#000000', '#40e0d0', '#303f9f', '#ff9800'] },
    euroBlue: { label: 'European Blue', colors: ['#9aa6b2', '#d4dde5', '#ffffff', '#0a66c2', '#000000', '#ff4081', '#388e3c', '#ffb300'] },
    scandi: { label: 'Scandinavian Bright', colors: ['#aab2b7', '#e6eaee', '#ffffff', '#74b9ff', '#000000', '#e91e63', '#1976d2', '#4caf50'] },
    neonCyan: { label: 'Graphite Neon Cyan', colors: ['#9aa0a6', '#d5d9dd', '#ffffff', '#00e5ff', '#000000', '#ff9800', '#9c27b0', '#4caf50'] },
    coralTech: { label: 'Coral Tech', colors: ['#9da3a9', '#d8dde2', '#ffffff', '#ff6b6b', '#000000', '#00e676', '#3f51b5', '#ff5722'] },
    violetMidnight: { label: 'Violet Midnight', colors: ['#9fa3b1', '#d9dce3', '#ffffff', '#7c3aed', '#000000', '#e91e63', '#388e3c', '#ffb300'] },
    mintSage: { label: 'Mint Sage', colors: ['#a0a7a2', '#dbe0dd', '#ffffff', '#00c896', '#000000', '#ff1744', '#3f51b5', '#ff9800'] },
    slateAzure: { label: 'Slate Azure', colors: ['#9aa3ad', '#d8dee6', '#ffffff', '#3b82f6', '#000000', '#ff4081', '#388e3c', '#ffc107'] },
    vaporPop: { label: 'Vapor Pop', colors: ['#9ea0a8', '#d6d7dc', '#ffffff', '#ff00e5', '#000000', '#00bcd4', '#673ab7', '#ff5722'] },
    cyberMagenta: { label: 'Cyber Magenta', colors: ['#9c9fad', '#d6d9e3', '#ffffff', '#ff007a', '#000000', '#40e0d0', '#1976d2', '#ff9800'] },
    streetLime: { label: 'Street Lime', colors: ['#9aa19a', '#d6dbd6', '#ffffff', '#baff00', '#000000', '#e91e63', '#3f51b5', '#ff6f00'] },
    cmykPop: { label: 'CMYK Pop', colors: ['#9f9f9f', '#d9d9d9', '#ffffff', '#ffd400', '#000000', '#ff1744', '#7b1fa2', '#4caf50'] }
  };

  let currentTemplate = 'industrialTeal';
  let currentColors = COLOR_TEMPLATES.industrialTeal.colors.slice(); // 8 colors
  // Cursor color: default to Color 6 (highlight)
  let cursorBallIndex = 5;
  let cursorBallColor = currentColors[cursorBallIndex] || '#ff4013';

  // Expose palette as CSS variables for use by page elements
  function syncPaletteVars(colors = currentColors) {
    try {
      const root = document.documentElement;
      const list = (colors && colors.length ? colors : currentColors).slice(0, 8);
      for (let i = 0; i < 8; i++) {
        const hex = list[i] || '#ffffff';
        root.style.setProperty(`--ball-${i+1}`, hex);
      }
    } catch (_) { /* no-op */ }
  }

  // Color weights: Color 1: 50%, Color 2: 25%, Color 3: 15%, Color 4: 7.5%, Color 5: 2.5%
  const COLOR_WEIGHTS = [0.50, 0.25, 0.12, 0.06, 0.03, 0.02, 0.01, 0.01];
  
  function pickRandomColor() {
    try {
      if (!currentColors || currentColors.length === 0) {
        console.warn('No colors available, using fallback');
        return '#ffffff'; // Fallback color
      }
      
      // Use weighted random selection
      const random = Math.random();
      let cumulativeWeight = 0;
      
      for (let i = 0; i < Math.min(currentColors.length, COLOR_WEIGHTS.length); i++) {
        cumulativeWeight += COLOR_WEIGHTS[i];
        if (random <= cumulativeWeight) {
          return currentColors[i];
        }
      }
      
      // Fallback to last color if something goes wrong
      return currentColors[Math.min(currentColors.length - 1, 7)];
    } catch (error) {
      console.error('Error picking random color:', error);
      return '#ffffff'; // Fallback color
    }
  }

  // Repeller controls
  let repelRadius = 135;   // px (CSS px) - from screenshot
  let repelPower = 1536000;  // from screenshot (mapped display value)
  let repelSoft = 3.4;     // exponent falloff - from screenshot
  let mouseX = CONSTANTS.OFFSCREEN_MOUSE, mouseY = CONSTANTS.OFFSCREEN_MOUSE; // offscreen until moved
  let repellerEnabled = false; // disabled by default; enabled by preset or sliders
  const REPELLER_GLOBAL_MULTIPLIER = 20.0; // doubled overall repeller strength
  // Responsive repeller sizing
  let repelResponsive = true;
  let repelMinSize = 60;   // CSS px at 375px viewport
  let repelMaxSize = 200;  // CSS px at 1128px+ viewport
  // Unified input handling state (pointer vs mouse)
  const HAS_POINTER_EVENTS = 'PointerEvent' in window;
  let isTouchActive = false;
  let activePointerId = null;
  let lastPointerType = 'mouse';
  // Hide visual cursor ball on mobile-like inputs
  let hideCursorOnMobile = true;
  function isMobileLikeInput() {
    try {
      const coarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
      const noHover = window.matchMedia && window.matchMedia('(hover: none)').matches;
      return coarse || noHover || (responsiveScale < 1.0);
    } catch (_) {
      return (responsiveScale < 1.0);
    }
  }
  function updateRepellerFromClient(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    mouseX = (clientX - rect.left) * DPR;
    mouseY = (clientY - rect.top) * DPR;
  }

  // Repeller slider mapping (wide dynamic range; midpoint equals 2× previous default)
  const REPEL_BASE_POWER = 12000; // previous default baseline
  const REPEL_SLIDER_MAX = 1000;  // slider range [0..1000]
  const REPEL_CENTER_MULTIPLIER = 2.0; // midpoint = 2× base
  const REPEL_N_OCTAVES = 12; // wide range (~1/32x .. 128x around center)
  function repelSliderToPower(sliderValue) {
    const s = Math.max(0, Math.min(REPEL_SLIDER_MAX, Number(sliderValue))) / REPEL_SLIDER_MAX;
    const mult = REPEL_CENTER_MULTIPLIER * Math.pow(2, (s - 0.5) * REPEL_N_OCTAVES);
    return REPEL_BASE_POWER * mult;
  }

  // Compute responsive repel radius based on viewport width, clamped between min/max
  function computeResponsiveRepelRadius() {
    const minW = 375;
    const maxW = 1128;
    const w = canvas.clientWidth || window.innerWidth;
    const t = clamp((w - minW) / (maxW - minW), 0, 1);
    const minR = Math.min(repelMinSize, repelMaxSize);
    const maxR = Math.max(repelMinSize, repelMaxSize);
    return minR + (maxR - minR) * t;
  }
  function updateRepelRadius() {
    if (repelResponsive) {
      repelRadius = computeResponsiveRepelRadius();
    }
    // sync UI label if present
    const lbl = document.getElementById('repelSizeVal');
    if (lbl) lbl.textContent = Math.round(repelRadius).toString();
  }
  function powerToRepelSlider(power) {
    const safe = Math.max(1, Number(power));
    const x = safe / (REPEL_BASE_POWER * REPEL_CENTER_MULTIPLIER);
    const s = 0.5 + (Math.log2(x) / REPEL_N_OCTAVES);
    return Math.round(Math.max(0, Math.min(1, s)) * REPEL_SLIDER_MAX);
  }

  // Shadows removed for better performance and realism
  
  // High refresh mode is now default
  let highRefreshMode = true; // Always enabled for best performance
  
  // Rounded corners for simulation area
  let cornerRadius = 0; // Corner radius in pixels (0 = square corners)
  
  // Text collision system
  const TEXT_SELECTOR = '#hero-text'; // ID selector for the main text element
  let textColliders = []; // Array of text collision rectangles
  
  // Behavior modes
  const BEHAVIOR_MODES = { pit: 'pit', flies: 'flies', print: 'print' };
  let behaviorMode = BEHAVIOR_MODES.pit;
  // Flies tuning
  let fliesSpeedMul = 3.4;       // percentage 0.25..4.0
  let fliesMaxSpeed = 1910;      // px/s cap (base)
  let fliesSeekGain = 360;       // acceleration towards light (base)
  let fliesWanderStrength = 120; // idle wander force (base)
  let fliesJitter = 3.0;         // randomness around light target
  let fliesScatterRadius = 490;  // desired orbit radius around light
  let fliesScatterVarPct = 1.00; // 0..1 radius variance per fly
  let lightActive = false;       // whether the light (pointer/touch) is present
  // Trail tuning (formerly print)
  let trailSmoothing = 0;        // -500% to 400% trail smoothing
  let generalSmoothing = 0;      // -500% to 400% general smoothing
  let trailLength = 75;          // maximum trail particles (3x longer)
  let trailSpawnRate = 50;       // ms between trail particles
  let trailLastTime = 0;         // timestamp of last trail particle
  let trailColorIndex = 0;       // current color index for alternation
  let trailPositions = [];       // array of smoothed trail positions
  let targetMouseX = 0;          // smoothed mouse X position
  let targetMouseY = 0;          // smoothed mouse Y position
  // Temporal trail for simple motion blur (0 = off, up to ~0.25)
  let trailFade = 0.025; // from screenshot
  let trailSubtlety = 1.80; // from screenshot
  
  // Performance optimizations and FPS tracking
  let renderFrameCount = 0;
  let physicsStepCount = 0;
  let lastFPSTime = 0;
  let currentRenderFPS = 0;
  let currentPhysicsFPS = 0;
  const renderFpsElement = document.getElementById('render-fps');
  const physicsFpsElement = document.getElementById('physics-fps');
  // Removed performance mode indicators
  
  // Shadow system removed for better performance

  // Ball model - updated to remove 3D rendering
  class Ball {
    constructor(x, y, r, color) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random()*2 - 1) * 200; // random lateral kick
      this.vy = -Math.random()*200;          // slight upward variation
      this.r = r;
      this.m = ballMassKg;                    // all balls share the same mass
      this.color = color;
      this.t = 0;
      // Entry drift state for natural side-throw effect
      this.age = 0;           // seconds since spawn
      this.driftAx = 0;       // lateral acceleration during entry (px/s^2)
      this.driftTime = 0;     // duration of entry drift (s)
      // Spin & squash state
      this.omega = 0;         // angular velocity (rad/s)
      this.squash = 1.0;      // visual squash factor (1 = round)
      this.squashDirX = 1;    // squash direction components (unit vector)
      this.squashDirY = 0;
      // Improved rotation & world-aligned squash
      this.theta = 0;               // integrated angular position (rad)
      this.squashAmount = 0.0;      // 0 = no squash, up to SQUASH_MAX
      this.squashNormalAngle = 0.0; // world-space normal direction for squash
      // Flies/wander state
      this.wanderAngle = Math.random() * Math.PI * 2;
      this.wanderTimer = 0;
      // Snake chain helpers
      this.prevX = x; this.prevY = y;
    }
    // Integrate motion with simple Euler step
    step(dt) {
      // Advance timers
        this.t += dt;
      this.age += dt;

      // Flies mode uses custom integrator (no gravity/standard drag). Early return.
      if (behaviorMode === BEHAVIOR_MODES.flies) {
        stepFlies(this, dt);
        return;
      }
      

      // Gravity scaled by mass to make weight perceptible without changing G globally
      this.vy += (G * gravityScale) * dt;
      // Mass-aware drag (heavier balls lose proportionally less velocity)
      const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
      const drag = Math.max(0, 1 - (FRICTION / massScale));
      this.vx *= drag;
      this.vy *= drag;
      // Apply short-lived lateral drift to simulate being thrown from the side above
      if (this.driftAx !== 0 && this.age < this.driftTime) {
        this.vx += (this.driftAx * dt) / massScale;
      } else if (this.driftAx !== 0) {
        this.driftAx = 0; // Clear drift when expired to skip future checks
      }
      if (behaviorMode === BEHAVIOR_MODES.pit) {
        applyRepeller(this, dt);
      } else if (behaviorMode === BEHAVIOR_MODES.print) {
        // Print mode uses normal physics with gravity
      }
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      // Angular damping
      const spinDamp = Math.max(0, 1 - CONSTANTS.SPIN_DAMP_PER_S * dt);
      this.omega *= spinDamp;
      // Integrate angular position for visible rotation
      this.theta += this.omega * dt;
      if (this.theta > Math.PI) this.theta -= Math.PI * 2; else if (this.theta < -Math.PI) this.theta += Math.PI * 2;
      // Relax squash amount back to 0 (area-preserving)
      const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
      this.squashAmount += (0 - this.squashAmount) * decay;
      this.squash = 1 - this.squashAmount;
    }
    // Resolve collision with walls (with rounded corners)
    // Skip wall collisions for flies behavior
    walls(w, h, dt) {
      if (behaviorMode === BEHAVIOR_MODES.flies) {
        return; // Flies can move beyond boundaries
      }
      if (cornerRadius === 0) {
        // Standard rectangular collision
      if (this.y + this.r > h) { 
        this.y = h - this.r; 
        // Pre-impact speed for squash amplitude
        const preVy = this.vy;
        // Rolling friction & spin from tangential slip
        const slip = this.vx - this.omega * this.r; // world x is tangential at bottom contact
        const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
        // convert part of slip to spin, reduce horizontal speed (rolling tendency)
        this.omega += (slip / this.r) * CONSTANTS.SPIN_GAIN / massScale;
        const rollDamp = Math.max(0, 1 - CONSTANTS.ROLL_FRICTION_PER_S * dt / massScale);
        this.vx *= rollDamp;
        // Bounce with mass-aware restitution
        const wallRest = Math.abs(preVy) < CONSTANTS.WALL_REST_VEL_THRESHOLD ? 0 : REST;
        this.vy = -this.vy * (wallRest * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash on impact using pre-impact speed
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = -Math.PI / 2; // ground normal upwards
        // Ground coupling: tend towards pure rolling without slipping
        const rollTarget = this.vx / this.r;
        this.omega += (rollTarget - this.omega) * Math.min(1, CONSTANTS.GROUND_COUPLING_PER_S * dt);
      }
      if (this.vy > 0 && this.y - this.r < 0) { 
        this.y = this.r; 
        const preVy = this.vy;
        this.vy = -this.vy * REST; 
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI / 2; // ceiling normal downwards
      }
      if (this.x + this.r > w) { 
        this.x = w - this.r; 
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * REST; 
        const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
        this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // right wall normal leftwards
      }
        if (this.x - this.r < 0) { 
          this.x = this.r; 
          {
            const slip = this.vy - this.omega * this.r;
            const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
            this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
          }
          this.vx = -this.vx * REST; 
          const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
          this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
          this.squash = 1 - this.squashAmount;
          this.squashNormalAngle = 0; // left wall normal rightwards
        }
      } else {
        // Rounded corner collision detection
        this.handleRoundedWallCollision(w, h);
      }
      
      // Text collision detection
      this.checkTextCollisions(dt);
    }
    
    // Check collision with text elements
    checkTextCollisions(dt) {
      for (let i = 0; i < textColliders.length; i++) {
        const rect = textColliders[i];
        
        // Check if ball overlaps with text rectangle
        const closestX = Math.max(rect.x, Math.min(this.x, rect.x + rect.width));
        const closestY = Math.max(rect.y, Math.min(this.y, rect.y + rect.height));
        
        const dx = this.x - closestX;
        const dy = this.y - closestY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < this.r) {
          // Collision detected - resolve it
          if (distance === 0) {
            // Ball center is inside rectangle - push out in shortest direction
            const distToLeft = this.x - rect.x;
            const distToRight = (rect.x + rect.width) - this.x;
            const distToTop = this.y - rect.y;
            const distToBottom = (rect.y + rect.height) - this.y;
            
            const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
            
            if (minDist === distToLeft) {
              this.x = rect.x - this.r;
              this.vx = -Math.abs(this.vx) * REST;
            } else if (minDist === distToRight) {
              this.x = rect.x + rect.width + this.r;
              this.vx = Math.abs(this.vx) * REST;
            } else if (minDist === distToTop) {
              this.y = rect.y - this.r;
              this.vy = -Math.abs(this.vy) * REST;
            } else {
              this.y = rect.y + rect.height + this.r;
              this.vy = Math.abs(this.vy) * REST;
            }
          } else {
            // Normal collision resolution
            const overlap = this.r - distance;
            const nx = dx / distance;
            const ny = dy / distance;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity with restitution
            const dotProduct = this.vx * nx + this.vy * ny;
            if (dotProduct < 0) {
              this.vx -= 2 * dotProduct * nx * REST;
              this.vy -= 2 * dotProduct * ny * REST;
              
              // Add squash effect for visual impact
              const impact = Math.min(1, Math.abs(dotProduct) / (this.r * 70));
              this.squash = 1 - CONSTANTS.SQUASH_MAX * impact;
              this.squashDirX = Math.abs(nx) > Math.abs(ny) ? 1 : 0;
              this.squashDirY = Math.abs(ny) > Math.abs(nx) ? 1 : 0;
            }
          }
        }
      }
    }
    
    // Handle collision with rounded corner boundaries
    handleRoundedWallCollision(w, h) {
      const r = cornerRadius;
      
      // Check collision with each corner circle
      const corners = [
        { x: r, y: r },           // Top-left
        { x: w - r, y: r },       // Top-right
        { x: w - r, y: h - r },   // Bottom-right
        { x: r, y: h - r }        // Bottom-left
      ];
      
      for (let i = 0; i < corners.length; i++) {
        const corner = corners[i];
        const dx = this.x - corner.x;
        const dy = this.y - corner.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Check if ball is in corner region and colliding with corner circle
        const inCornerRegion = this.isInCornerRegion(corner, w, h, r);
        if (inCornerRegion && dist + this.r > r) {
          // Collision with corner circle
          const overlap = r - (dist - this.r);
          if (overlap > 0 && dist > 0) {
            const nx = dx / dist;
            const ny = dy / dist;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity
            const dot = this.vx * nx + this.vy * ny;
            this.vx -= 2 * dot * nx * REST;
            this.vy -= 2 * dot * ny * REST;
            // Squash aligned to corner normal, proportional to impact
            const impact = Math.min(1, Math.abs(dot) / (this.r * 90));
            this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
            this.squash = 1 - this.squashAmount;
            this.squashNormalAngle = Math.atan2(ny, nx);
          }
        }
      }
      
      // Handle straight wall collisions (outside corner regions)
      // Bottom wall
      if (this.y + this.r > h && (this.x < r || this.x > w - r)) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      
      // Top wall
      if (this.y - this.r < 0 && (this.x < r || this.x > w - r)) {
        this.y = this.r;
        this.vy = -this.vy * REST;
      }
      
      // Right wall
      if (this.x + this.r > w && (this.y < r || this.y > h - r)) {
        this.x = w - this.r;
        // Wall contact: add spin from tangential slip (vertical normal)
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash aligned to wall normal
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // normal leftwards
      }
      
      // Left wall
      if (this.x - this.r < 0 && (this.y < r || this.y > h - r)) {
        this.x = this.r;
        {
          const slip = this.vy - this.omega * this.r;
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = 0; // normal rightwards
      }
      
      // Handle straight sections of walls
      if (this.y + this.r > h && this.x >= r && this.x <= w - r) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.y - this.r < 0 && this.x >= r && this.x <= w - r) {
        this.y = this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x + this.r > w && this.y >= r && this.y <= h - r) {
        this.x = w - this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x - this.r < 0 && this.y >= r && this.y <= h - r) {
        this.x = this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
    }
    
    // Check if ball is in a corner region
    isInCornerRegion(corner, w, h, r) {
      // Top-left corner
      if (corner.x === r && corner.y === r) {
        return this.x <= r && this.y <= r;
      }
      // Top-right corner
      if (corner.x === w - r && corner.y === r) {
        return this.x >= w - r && this.y <= r;
      }
      // Bottom-right corner
      if (corner.x === w - r && corner.y === h - r) {
        return this.x >= w - r && this.y >= h - r;
      }
      // Bottom-left corner
      if (corner.x === r && corner.y === h - r) {
        return this.x <= r && this.y >= h - r;
      }
      return false;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      // World-aligned squash/stretch only if significant
      const amt = Math.min(CONSTANTS.SQUASH_MAX, Math.max(0, this.squashAmount));
      if (amt > 0.001) {
        // Area-preserving squash: s * (1/s) maintains roundness perception
        const s = 1 + amt;
        const inv = 1 / s;
        ctx.rotate(this.squashNormalAngle);
        ctx.scale(s, inv);
        ctx.rotate(-this.squashNormalAngle);
      }
      // Body
      ctx.beginPath();
      ctx.arc(0, 0, this.r, 0, Math.PI*2);
      ctx.fillStyle = this.color;
      ctx.fill();
      // Spin indicator removed for cleaner visuals and performance
      ctx.restore();
    }
  }

  const balls = [];
  // For snake mode, we treat the balls array as an ordered chain
  function initTrail() {
    balls.length = 0; // Clear existing balls
    trailColorIndex = 0; // Reset color alternation
    trailLastTime = 0; // Reset timer
    trailPositions = []; // Clear trail positions
    targetMouseX = mouseX !== CONSTANTS.OFFSCREEN_MOUSE ? mouseX : canvas.width / 2;
    targetMouseY = mouseY !== CONSTANTS.OFFSCREEN_MOUSE ? mouseY : canvas.height / 2;
  }

  function updateTrail(dt, currentTime) {
    // Update smoothed mouse position with general smoothing
    if (mouseX !== CONSTANTS.OFFSCREEN_MOUSE && mouseY !== CONSTANTS.OFFSCREEN_MOUSE) {
      const generalSmoothFactor = getSmoothingFactor(generalSmoothing);
      const smoothRate = generalSmoothFactor * dt * 60; // 60fps normalized
      targetMouseX += (mouseX - targetMouseX) * smoothRate;
      targetMouseY += (mouseY - targetMouseY) * smoothRate;
    }
    
    // Check if it's time to spawn a new trail particle
    if (currentTime - trailLastTime >= trailSpawnRate) {
      if (mouseX !== CONSTANTS.OFFSCREEN_MOUSE && mouseY !== CONSTANTS.OFFSCREEN_MOUSE) {
        // Remove oldest ball if we've reached the trail length limit
        if (balls.length >= trailLength) {
          balls.shift(); // Remove first (oldest) ball
        }
        
        // Create new ball with alternating color
        const r = (R_MIN + R_MAX) / 2; // consistent size
        const color = currentColors[trailColorIndex % currentColors.length];
        trailColorIndex = (trailColorIndex + 1) % currentColors.length;
        
        const ball = new Ball(targetMouseX, targetMouseY, r, color);
        ball.vx = 0; // No initial velocity for trail mode
        ball.vy = 0;
        balls.push(ball);
        
        trailLastTime = currentTime;
      }
    }
    
    // Update existing trail particles to follow with degrading smoothing
    const trailSmoothFactor = getSmoothingFactor(trailSmoothing);
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      const distanceFromHead = balls.length - 1 - i; // 0 for newest, higher for older
      const smoothingDegradation = Math.pow(0.85, distanceFromHead); // Each segment is 15% less smooth
      const followFactor = trailSmoothFactor * smoothingDegradation * dt * 60;
      
      if (i === balls.length - 1) {
        // Newest ball follows the smoothed mouse position
        ball.x += (targetMouseX - ball.x) * followFactor;
        ball.y += (targetMouseY - ball.y) * followFactor;
      } else {
        // Older balls follow the ball ahead of them in the chain
        const nextBall = balls[i + 1];
        ball.x += (nextBall.x - ball.x) * followFactor;
        ball.y += (nextBall.y - ball.y) * followFactor;
      }
    }
  }

  // Convert smoothing percentage (-500% to 400%) to usable factor
  function getSmoothingFactor(smoothingPercent) {
    if (smoothingPercent === 0) return 1.0; // Default: immediate response
    if (smoothingPercent > 0) {
      // Positive values: slower response (more smoothing)
      return 1.0 / (1.0 + smoothingPercent / 100.0);
    } else {
      // Negative values: faster response (less smoothing, more jittery)
      return Math.min(10.0, 1.0 + Math.abs(smoothingPercent) / 100.0);
    }
  }

  // Helpers
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function randBetween(a, b) { return a + Math.random() * (b - a); }
  // Compute mass from radius using current weight slider as density baseline
  // Removed radius-based mass; shared mass is used instead
  
  // Draw rounded boundary visualization
  function drawRoundedBoundary(ctx, w, h) {
    const r = cornerRadius;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    // Start from top-left corner (after the curve)
    ctx.moveTo(r, 0);
    
    // Top edge
    ctx.lineTo(w - r, 0);
    
    // Top-right corner
    ctx.arcTo(w, 0, w, r, r);
    
    // Right edge
    ctx.lineTo(w, h - r);
    
    // Bottom-right corner
    ctx.arcTo(w, h, w - r, h, r);
    
    // Bottom edge
    ctx.lineTo(r, h);
    
    // Bottom-left corner
    ctx.arcTo(0, h, 0, h - r, r);
    
    // Left edge
    ctx.lineTo(0, r);
    
    // Top-left corner
    ctx.arcTo(0, 0, r, 0, r);
    
    ctx.closePath();
    ctx.stroke();
  }
  
  function spawnBall(x, y, color = pickRandomColor()) {
    // Calculate size range with variation (ensure positive values)
    const baseSize = (R_MIN + R_MAX) / 2;
    
    let r;
    if (sizeVariation === 0) {
      // No variation: all balls exactly the same size
      r = baseSize;
    } else {
      // Apply variation
      const range = (R_MAX - R_MIN) / 2;
      const variedRange = range * sizeVariation;
      const minR = Math.max(1, baseSize - variedRange);
      const maxR = baseSize + variedRange;
      r = randBetween(minR, maxR);
    }
    
    const ball = new Ball(x, y, r, color);

    // Natural entry throw with size-aware impulse and sweep-aware direction
    const centerX = canvas.width * 0.5;
    // Prefer current sweep direction if enabled; otherwise side-based
    const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((x < centerX) ? 1 : -1);
    const sizeInfluence = clamp((r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
    const baseKick = 140 * sizeInfluence;  // scale with size
    const randKick = 180 * sizeInfluence;  // scale with size
    const upwardKick = 120;                // small upward speed to soften entry
    ball.vx = dir * (baseKick + Math.random() * randKick);
    ball.vy = -Math.random() * upwardKick;

    // Short lived lateral acceleration to feel like being pushed from the side (size-aware)
    ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence; // px/s^2
    ball.driftTime = 0.22 + Math.random() * 0.28;                    // 0.22–0.5s of drift

    balls.push(ball);
    return ball;
  }

  // Continuous emitter within a vw/vh-defined rectangle
  let emitterTimer = 0;
  function pickSpawnPoint() {
    const wCss = canvas.clientWidth;
    const hCss = canvas.clientHeight;
    const widthCss = clamp((SPAWN_W_VW / 100) * wCss, 0, wCss);
    let xCenterCss = clamp((SPAWN_X_CENTER_VW / 100) * wCss, 0, wCss);
    // Apply sweeping emitter motion across the band for natural hand-like movement
    if (EMITTER_SWEEP_ENABLED) {
      const amplPx = (EMITTER_SWEEP_AMPL_VW / 100) * wCss;
      const sweepOffset = Math.sin(emitterPhase) * amplPx;
      const prevX = xCenterCss;
      xCenterCss = clamp(xCenterCss + sweepOffset, 0, wCss);
      emitterSweepDir = (xCenterCss >= prevX) ? 1 : -1;
    }
    // Allow slight offscreen horizontal spawn for natural side entry feel
    const offX = Math.min(40, widthCss * 0.1); // up to 40px or 10% width
    const xLeftCss = clamp(xCenterCss - widthCss / 2 - offX, -offX, wCss);
    const xRightCss = clamp(xCenterCss + widthCss / 2 + offX, -offX, wCss);
    const yTopCss = (SPAWN_Y_VH / 100) * hCss;
    const yBotCss = yTopCss + (SPAWN_H_VH / 100) * hCss;
    // Slight bias along sweep direction to emit closer to the leading edge
    const bias = 0.3; // 0 = uniform, 1 = fully biased to leading edge
    const u = Math.random();
    const biased = bias > 0 ? (emitterSweepDir > 0 ? Math.pow(u, 1 - bias) : 1 - Math.pow(1 - u, 1 - bias)) : u;
    const x = (xLeftCss + (xRightCss - xLeftCss) * biased) * DPR;
    // Add slight upward randomness to spawn height for organic feel
    const y = randBetween(yTopCss * DPR, yBotCss * DPR) - (R_MAX + CONSTANTS.BALL_SPAWN_OFFSET + randBetween(0, 10 * DPR));
    return { x, y };
  }
  function emit(dt) {
    emitterTimer += dt;
    while (emitterTimer >= EMIT_INTERVAL) {
      // Jitter emissions slightly for organic timing
      const jitter = (Math.random() - 0.5) * EMIT_INTERVAL * 0.5; // ±25%
      emitterTimer -= (EMIT_INTERVAL + jitter);
      // Advance sweep phase based on elapsed time segment (approx)
      emitterPhase += (2 * Math.PI) * EMITTER_SWEEP_HZ * (EMIT_INTERVAL + jitter);
      const p = pickSpawnPoint();
      // Occasionally emit small clusters to mimic handful tosses
      const drops = (Math.random() < 0.35 ? 3 : 1);
      for (let i=0; i<drops; i++) {
        if (balls.length < MAX_BALLS) {
          // Slight horizontal staggering to suggest sideways motion
          const xOffset = i * CONSTANTS.BALL_CLUSTER_SPACING * (Math.random() < 0.5 ? 1 : -1);
          spawnBall(p.x + xOffset, p.y - i * CONSTANTS.BALL_CLUSTER_Y_OFFSET);
        }
      }
    }
  }

  // Spatial hash grid to accelerate broad-phase (optimized)
  const spatialGrid = new Map();
  
  function collectPairsSorted() {
    const n = balls.length;
    if (n < 2) return []; // Early exit for trivial cases
    const cellSize = Math.max(1, R_MAX * 2); // Optimized cell size
    const gridWidth = Math.ceil(canvas.width / cellSize) + 1; // Dynamic grid width
    spatialGrid.clear(); // Reuse map
    
    // Build grid with numeric keys (faster than string concatenation)
    for (let i = 0; i < n; i++) {
      const b = balls[i];
      const cx = (b.x / cellSize) | 0;
      const cy = (b.y / cellSize) | 0;
      const key = cy * gridWidth + cx; // Numeric key
      let arr = spatialGrid.get(key);
      if (!arr) { arr = []; spatialGrid.set(key, arr); }
      arr.push(i);
    }
    
    const pairs = [];
    for (const [key, arr] of spatialGrid) {
      const cy = (key / gridWidth) | 0;
      const cx = key % gridWidth;
      
      // Check 9 neighboring cells (including self)
      for (let oy = -1; oy <= 1; oy++) {
        for (let ox = -1; ox <= 1; ox++) {
          const neighborKey = (cy + oy) * gridWidth + (cx + ox);
          const nb = spatialGrid.get(neighborKey);
          if (!nb) continue;
          
          for (let ii = 0; ii < arr.length; ii++) {
            const i = arr[ii];
            for (let jj = 0; jj < nb.length; jj++) {
              const j = nb[jj];
              if (j <= i) continue;
              
              const A = balls[i], B = balls[j];
              const dx = B.x - A.x, dy = B.y - A.y;
              const rSum = A.r + B.r;
              const dist2 = dx*dx + dy*dy;
              
              if (dist2 < rSum*rSum) {
                const dist = Math.sqrt(Math.max(dist2, CONSTANTS.MIN_DISTANCE_EPSILON));
                const overlap = rSum - dist;
                pairs.push({ i, j, overlap });
              }
            }
          }
        }
      }
    }
    
    // Sort by overlap (most overlapping first for stability)
    pairs.sort((a, b) => b.overlap - a.overlap);
    return pairs;
  }

  // Circle–circle collisions: sequential impulses + Baumgarte positional correction
  function resolveCollisions(iterations = SOLVER_ITERS) {
    const pairs = collectPairsSorted();
    for (let iter = 0; iter < iterations; iter++) {
      for (let k = 0; k < pairs.length; k++) {
        const { i, j } = pairs[k];
        const A = balls[i];
        const B = balls[j];
        const dx = B.x - A.x;
        const dy = B.y - A.y;
        const rSum = A.r + B.r;
        const dist2 = dx * dx + dy * dy;
        // Performance optimization: early exits
        if (dist2 === 0 || dist2 > rSum * rSum) continue;
        // Skip very small overlaps for performance (< 5% overlap)
        if (dist2 > rSum * rSum * 0.95) continue;
        const dist = Math.sqrt(dist2);
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = rSum - dist;
        const invA = 1 / Math.max(A.m, 0.001);
        const invB = 1 / Math.max(B.m, 0.001);

        // Positional correction
        const correctionMag = POS_CORRECT_PERCENT * Math.max(overlap - POS_CORRECT_SLOP, 0) / (invA + invB);
        const cx = correctionMag * nx;
        const cy = correctionMag * ny;
        A.x -= cx * invA; A.y -= cy * invA;
        B.x += cx * invB; B.y += cy * invB;

        // Velocity impulse along the normal
        const rvx = B.vx - A.vx;
        const rvy = B.vy - A.vy;
        const velAlongNormal = rvx * nx + rvy * ny;
        if (velAlongNormal < 0) {
          const e = Math.abs(velAlongNormal) < REST_VEL_THRESHOLD ? 0 : REST;
          const j = -(1 + e) * velAlongNormal / (invA + invB);
          const ix = j * nx;
          const iy = j * ny;
          A.vx -= ix * invA; A.vy -= iy * invA;
          B.vx += ix * invB; B.vy += iy * invB;

          // Tangential slip to spin (approximate rolling/spin transfer)
          const tvx = rvx - velAlongNormal * nx;
          const tvy = rvy - velAlongNormal * ny;
          const slipMag = Math.hypot(tvx, tvy);
          if (slipMag > 1e-3) {
            const tangentSign = (tvx * -ny + tvy * nx) >= 0 ? 1 : -1; // right-hand tangent
            const gain = CONSTANTS.SPIN_GAIN_TANGENT;
            A.omega -= tangentSign * gain * slipMag / Math.max(A.r, 1);
            B.omega += tangentSign * gain * slipMag / Math.max(B.r, 1);
          }
          // Visual squash aligned to contact normal based on impact
          const impact = Math.min(1, Math.abs(velAlongNormal) / ((A.r + B.r) * 50));
          const sAmt = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
          A.squashAmount = Math.max(A.squashAmount, sAmt * 0.8);
          A.squashNormalAngle = Math.atan2(-ny, -nx);
          B.squashAmount = Math.max(B.squashAmount, sAmt * 0.8);
          B.squashNormalAngle = Math.atan2(ny, nx);
        }
      }
    }
  }

  // Main loop optimized for 120fps
  let last = performance.now() / 1000;
  let acc = 0;
  const DT = 1/120; // Target 120fps physics
  function frame(nowMs) {
    const now = nowMs / 1000;
    let dt = Math.min(0.008, now - last); // Cap at ~120fps for high refresh displays
    last = now;
    acc += dt;

  // FPS counters (render and physics) - only update if elements exist
    renderFrameCount++;
    if ((renderFpsElement || physicsFpsElement) && now - lastFPSTime >= CONSTANTS.FPS_UPDATE_INTERVAL) {
      if (renderFpsElement && renderFrameCount !== currentRenderFPS) {
        currentRenderFPS = renderFrameCount;
        renderFpsElement.textContent = currentRenderFPS.toString();
      }
      if (physicsFpsElement && physicsStepCount !== currentPhysicsFPS) {
        currentPhysicsFPS = physicsStepCount;
        physicsFpsElement.textContent = currentPhysicsFPS.toString();
      }
      
      renderFrameCount = 0;
      physicsStepCount = 0;
      lastFPSTime = now;
    }

    // Emit only for pit/flies (other modes manage their own balls)
    if (behaviorMode !== BEHAVIOR_MODES.print) emit(dt);
    
    // Update text colliders periodically (every ~60 frames for performance)
    if (renderFrameCount % 60 === 0) {
      updateTextColliders();
    }

    // Physics iterations optimized for realistic, stable simulation
    let physicsSteps = 0;
    while (acc >= DT && physicsSteps < CONSTANTS.MAX_PHYSICS_STEPS) {
      if (behaviorMode === BEHAVIOR_MODES.print) {
        updateTrail(DT, now * 1000); // Convert to milliseconds
      } else {
        for (let i=0; i<balls.length; i++) balls[i].step(DT);
        resolveCollisions(3); // Balanced quality vs performance
        for (let i=0; i<balls.length; i++) balls[i].walls(canvas.width, canvas.height, DT);
      }
      acc -= DT;
      physicsSteps++;
      physicsStepCount++; // Count physics steps for FPS measurement
    }
    
    // Reset accumulator if we're falling behind
    if (acc > DT * CONSTANTS.ACCUMULATOR_RESET_THRESHOLD) acc = 0;

    // Clear or fade canvas for motion blur trail
    if (trailFade > 0 && trailSubtlety > 0) {
      // Map sliders to effective fade alpha
      const TRAIL_FADE_UI_MAX = 1.5;      // slider max for trail length
      const TRAIL_SUBTLE_UI_MAX = 3.0;    // slider max for subtlety
      const maxAlpha = 0.35;              // shortest trail (more aggressive clear)
      const minAlpha = 0.0015;            // longest trail (very subtle clear)
      const normLen = Math.max(0, Math.min(1, trailFade / TRAIL_FADE_UI_MAX));
      const baseFade = maxAlpha + (minAlpha - maxAlpha) * normLen; // low slider -> big fade
      const subtleNorm = Math.max(0, Math.min(1, trailSubtlety / TRAIL_SUBTLE_UI_MAX));
      // Blend between full clear (1.0 alpha) at low subtlety and baseFade at high subtlety
      let effectiveFade = 1.0 + (baseFade - 1.0) * subtleNorm;
      // Clamp to safe bounds
      effectiveFade = Math.max(0.001, Math.min(1.0, effectiveFade));
      ctx.fillStyle = `rgba(0,0,0,${effectiveFade})`;
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'source-over';
    } else {
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }
    
    // Draw rounded boundary if corner radius > 0 (cache boundary path for performance)
    if (cornerRadius > 0) {
      drawRoundedBoundary(ctx, canvas.width, canvas.height);
    }
    
    // Shadow rendering removed for better performance and realism
    
    // Render balls with individual colors
    for (let i=0; i<balls.length; i++) balls[i].draw(ctx);
    // Draw cursor ball last
    drawCursorBall(ctx);

    // Use requestAnimationFrame for proper vsync
    requestAnimationFrame(frame);
  }
  
  // Start the main loop with requestAnimationFrame
  console.log('High refresh mode enabled - using requestAnimationFrame');
  requestAnimationFrame(frame);

  // Reset balls to spawn positions (preserves all settings)
  function resetBallsToSpawn() {
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      const p = pickSpawnPoint();
      ball.x = p.x;
      ball.y = p.y;
      // Re-apply natural entry throw on reset (sweep-aware, size-aware)
      const centerX = canvas.width * 0.5;
      const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((ball.x < centerX) ? 1 : -1);
      const sizeInfluence = clamp((ball.r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
      const baseKick = 140 * sizeInfluence;
      const randKick = 180 * sizeInfluence;
      const upwardKick = 120;
      ball.vx = dir * (baseKick + Math.random() * randKick);
      ball.vy = -Math.random() * upwardKick;
      ball.age = 0;
      ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence;
      ball.driftTime = 0.22 + Math.random() * 0.28;
    }
  }

  // Keyboard: reset balls to spawn, toggle panel
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k === 'r') {
      // Move balls back to spawn area - preserve all parameter settings
      resetBallsToSpawn();
      e.preventDefault(); // Prevent any default browser behavior
    }
    if (k === '/' && panel) {
      e.preventDefault();
      panel.classList.toggle('hidden');
    }
  });

  // Seed initial balls across the spawn area for quicker fill
  function seedArea(n = 160) {
    for (let i=0; i<n && balls.length < MAX_BALLS; i++) {
      const p = pickSpawnPoint();
      spawnBall(p.x, p.y);
    }
  }
  seedArea(CONSTANTS.INITIAL_SEED_BALLS);

  // Initialize panel to show correct controls for default mode
  updatePanelForMode(behaviorMode);

  // Shadow system removed for better performance



  // Pointer-first input for repeller (covers mouse, pen, touch)
  if (HAS_POINTER_EVENTS) {
    canvas.addEventListener('pointerdown', (e) => {
      lastPointerType = e.pointerType || 'mouse';
      if (e.pointerType === 'touch') {
        isTouchActive = true;
        activePointerId = e.pointerId;
        updateRepellerFromClient(e.clientX, e.clientY);
        if (repelPower > 0 && repelRadius > 0) repellerEnabled = true;
        lightActive = true;
        try { canvas.setPointerCapture(e.pointerId); } catch (_) {}
      } else {
        updateRepellerFromClient(e.clientX, e.clientY);
        if (repelPower > 0 && repelRadius > 0) repellerEnabled = true;
        lightActive = true;
      }
    }, { passive: true });

    canvas.addEventListener('pointermove', (e) => {
      lastPointerType = e.pointerType || lastPointerType;
      if (e.pointerType === 'touch') {
        if (isTouchActive && e.pointerId === activePointerId) {
          updateRepellerFromClient(e.clientX, e.clientY);
        }
      } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
        updateRepellerFromClient(e.clientX, e.clientY);
        if (repelPower > 0 && repelRadius > 0) repellerEnabled = true;
        lightActive = true;
      }
    }, { passive: true });

    const clearTouch = () => { isTouchActive = false; activePointerId = null; mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE; };
    canvas.addEventListener('pointerup', (e) => { if (e.pointerType === 'touch') { clearTouch(); lightActive = false; } }, { passive: true });
    canvas.addEventListener('pointercancel', (e) => { if (e.pointerType === 'touch') { clearTouch(); lightActive = false; } }, { passive: true });
    canvas.addEventListener('pointerleave', (e) => {
      if (e.pointerType === 'mouse' || e.pointerType === 'pen') { mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE; lightActive = false; }
    }, { passive: true });
  } else {
    // Fallback: mouse + touch events
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * DPR;
      mouseY = (e.clientY - rect.top) * DPR;
      if (repelPower > 0 && repelRadius > 0) repellerEnabled = true;
      lightActive = true;
    });
    canvas.addEventListener('mouseleave', () => { mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE; lightActive = false; });

    canvas.addEventListener('touchstart', (e) => {
      if (!e.touches || e.touches.length === 0) return;
      isTouchActive = true;
      const t = e.touches[0];
      updateRepellerFromClient(t.clientX, t.clientY);
      if (repelPower > 0 && repelRadius > 0) repellerEnabled = true;
      lightActive = true;
    }, { passive: true });
    canvas.addEventListener('touchmove', (e) => {
      if (!isTouchActive || !e.touches || e.touches.length === 0) return;
      const t = e.touches[0];
      updateRepellerFromClient(t.clientX, t.clientY);
      // prevent page scroll while interacting with the canvas
      if (typeof e.preventDefault === 'function') e.preventDefault();
    }, { passive: false });
    const endTouch = () => { isTouchActive = false; mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE; lightActive = false; };
    canvas.addEventListener('touchend', endTouch, { passive: true });
    canvas.addEventListener('touchcancel', endTouch, { passive: true });
  }

  // Draw a cursor as a ball matching the simulation style
  function drawCursorBall(ctx) {
    // Hide cursor ball entirely on mobile-like inputs
    if (hideCursorOnMobile && isMobileLikeInput()) return;
    // Hide cursor ball while actively touching (finger occludes)
    if (isTouchActive && lastPointerType === 'touch') return;
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    const x = mouseX, y = mouseY;
    const baseSize = (R_MIN + R_MAX) / 2;
    const r = baseSize;
    const color = cursorBallColor;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
  }

  function applyRepeller(b, dt) {
    // Respect "Off" template by treating zero or near-zero params as disabled
    if (!repellerEnabled) return;
    if (repelPower <= 0 || repelRadius <= 0) return;
    const rPx = repelRadius * DPR;
    const dx = b.x - mouseX;
    const dy = b.y - mouseY;
    const d2 = dx*dx + dy*dy;
    const r2 = rPx * rPx;
    if (d2 > r2) return;
    const d = Math.max(Math.sqrt(d2), CONSTANTS.MIN_REPEL_DISTANCE);
    const nx = dx / d;
    const ny = dy / d;
    const q = Math.max(0, 1 - d / rPx);
    const strength = (repelPower * REPELLER_GLOBAL_MULTIPLIER) * Math.pow(q, repelSoft);
    // Heavier balls respond less to the same field
    const massScale = Math.max(0.25, b.m / MASS_BASELINE_KG);
    b.vx += (nx * strength * dt) / massScale;
    b.vy += (ny * strength * dt) / massScale;
  }

  // Flies behavior: boids-like wander + seek with drift; custom integrator
  function stepFlies(b, dt) {
    const massScale = Math.max(0.25, b.m / MASS_BASELINE_KG);
    // Slight air drag only
    const drag = Math.max(0, 1 - (FRICTION * 0.2 / massScale));
    b.vx *= drag; b.vy *= drag;

    // Wander: slowly rotate a unit vector and add as acceleration
    b.wanderTimer += dt;
    if (b.wanderTimer > 0.08) {
      b.wanderTimer = 0;
      b.wanderAngle += (Math.random() - 0.5) * 0.9;
    }
    let ax = Math.cos(b.wanderAngle) * (fliesWanderStrength * fliesSpeedMul);
    let ay = Math.sin(b.wanderAngle) * (fliesWanderStrength * fliesSpeedMul);

    // Seek the light when active: spring-damper towards a moving orbit target with jitter
    if (lightActive && mouseX !== CONSTANTS.OFFSCREEN_MOUSE && mouseY !== CONSTANTS.OFFSCREEN_MOUSE) {
      // Each fly gets a pseudo-stable orbit radius using its inherent random seed
      if (b._scatterPhase === undefined) { b._scatterPhase = Math.random() * Math.PI * 2; }
      if (b._scatterFactor === undefined) { b._scatterFactor = 1 + (Math.random() * 2 - 1) * fliesScatterVarPct; }
      const radius = Math.max(0, fliesScatterRadius * b._scatterFactor) * DPR;
      b._scatterPhase += dt * (0.6 + Math.random() * 0.8) * fliesSpeedMul; // slow orbiting
      // Orbit center around mouse
      let tx = mouseX + Math.cos(b._scatterPhase) * radius;
      let ty = mouseY + Math.sin(b._scatterPhase) * radius;
      // Jitter to avoid lock-step
      tx += (Math.random() - 0.5) * fliesJitter * 20 * DPR;
      ty += (Math.random() - 0.5) * fliesJitter * 20 * DPR;
      const dx = tx - b.x; const dy = ty - b.y;
      // Critical damping approx: a = k*dx - c*v
      const k = (fliesSeekGain * 0.8) * fliesSpeedMul; // slightly lower to keep orbit-y feel
      const c = Math.sqrt(k) * 1.8; // damping term to prevent overshoot
      ax += k * dx - c * b.vx;
      ay += k * dy - c * b.vy;
    }

    // Apply acceleration (mass-aware), integrate
    b.vx += (ax * dt) / massScale;
    b.vy += (ay * dt) / massScale;

    // Clamp speed for lively motion, not slow-mo
    const maxS = Math.max(200, fliesMaxSpeed * fliesSpeedMul);
    const sp = Math.hypot(b.vx, b.vy);
    if (sp > maxS) { const k = maxS / sp; b.vx *= k; b.vy *= k; }

    b.x += b.vx * dt;
    b.y += b.vy * dt;
    
    // Ensure balls remain circular by resetting squash in flies mode
    const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
    b.squashAmount += (0 - b.squashAmount) * decay;
    b.squash = 1 - b.squashAmount;
  }

  // UI elements
  const frictionSlider = document.getElementById('frictionSlider');
  const emitterSlider = document.getElementById('emitterSlider');
    
    // Apply liquid forces
    applyLiquidCohesion(b, dt);
    applyLiquidSurfaceTension(b, dt);
    applyLiquidBuoyancy(b, dt);
    
    // Integrate motion
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    
    // Maintain circular shape (liquid particles stay round)
    const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
    b.squashAmount += (0 - b.squashAmount) * decay;
    b.squash = 1 - b.squashAmount;
  }

  // UI elements
  const frictionSlider = document.getElementById('frictionSlider');
  const emitterSlider = document.getElementById('emitterSlider');
  const sizeSlider = document.getElementById('sizeSlider');
  const maxBallsSlider = document.getElementById('maxBallsSlider');
  const sizeVariationSlider = document.getElementById('sizeVariationSlider');
  const weightSlider = document.getElementById('weightSlider');
  const spawnYSlider = document.getElementById('spawnYSlider');
  const spawnWidthSlider = document.getElementById('spawnWidthSlider');
  const spawnCenterSlider = document.getElementById('spawnCenterSlider');
  const spawnHeightSlider = document.getElementById('spawnHeightSlider');
  const repelSizeSlider = document.getElementById('repelSizeSlider');
  const repelPowerSlider = document.getElementById('repelPowerSlider');
  const repelSoftSlider = document.getElementById('repelSoftSlider');
  // Color controls
  const colorSelect = document.getElementById('colorSelect');
  const color1 = document.getElementById('color1');
  const color2 = document.getElementById('color2');
  const color3 = document.getElementById('color3');
            const dist = Math.sqrt(distSq);
            const strength = liquidCohesion * (1 - dist / cohesionRadius);
            const nx = deltaX / dist;
            const ny = deltaY / dist;
            
            fx += nx * strength;
            fy += ny * strength;
            neighborCount++;
          }
        }
      }
    }
    
    if (neighborCount > 0) {
      ball.vx += (fx * dt) / massScale;
      ball.vy += (fy * dt) / massScale;
    }
  }

  // Apply surface tension: smooth out blob surfaces (optimized with spatial grid)
  function applyLiquidSurfaceTension(ball, dt) {
    const tensionRadius = ball.r * 1.8;
    const massScale = Math.max(0.25, ball.m / MASS_BASELINE_KG);
    let fx = 0, fy = 0;
    let neighborCount = 0;
    
    // Use spatial grid for performance - only check nearby cells
    const cellSize = Math.max(1, R_MAX * 2);
    const gridWidth = Math.ceil(canvas.width / cellSize) + 1;
    const cx = (ball.x / cellSize) | 0;
    const cy = (ball.y / cellSize) | 0;
    
    // Check 3x3 grid around ball
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const key = (cy + dy) * gridWidth + (cx + dx);
        const cellBalls = spatialGrid.get(key);
        if (!cellBalls) continue;
        
        for (let i = 0; i < cellBalls.length; i++) {
          const otherIndex = cellBalls[i];
          const other = balls[otherIndex];
          if (other === ball) continue;
          
          const deltaX = other.x - ball.x;
          const deltaY = other.y - ball.y;
          const distSq = deltaX * deltaX + deltaY * deltaY;
          const tensionRadiusSq = tensionRadius * tensionRadius;
          
          if (distSq < tensionRadiusSq && distSq > 0.01) {
            const dist = Math.sqrt(distSq);
            const desiredDist = (ball.r + other.r) * 1.1;
            const diff = desiredDist - dist;
            const strength = liquidSurfaceTension * diff * 0.5;
            
            const nx = deltaX / dist;
            const ny = deltaY / dist;
            
            fx += nx * strength;
            fy += ny * strength;
            neighborCount++;
          }
        }
      }
    }
    
    if (neighborCount > 0) {
      ball.vx += (fx * dt) / massScale;
      ball.vy += (fy * dt) / massScale;
    }
  }

  // Apply temperature-based buoyancy (lava lamp effect)
  function applyLiquidBuoyancy(ball, dt) {
    const massScale = Math.max(0.25, ball.m / MASS_BASELINE_KG);
    
    // Get temperature at ball position (higher near mouse/touch)
    const temp = getLiquidTemperature(ball.x, ball.y);
    
    // Hot liquid rises, cool liquid sinks
    const buoyancyForce = (temp - 0.5) * liquidBuoyancy * liquidTempSensitivity;
    ball.vy -= (buoyancyForce * dt) / massScale;
    
    // Add slight thermal convection (horizontal movement)
    const convectionForce = Math.sin(ball.x * 0.01 + performance.now() * 0.001) * buoyancyForce * 0.3;
    ball.vx += (convectionForce * dt) / massScale;
  }

  // Get temperature at a position (0 = cold, 1 = hot)
  function getLiquidTemperature(x, y) {
    // Update temperature map periodically for performance
    liquidTempUpdateTimer += 16; // Assume ~60fps
    if (liquidTempUpdateTimer > 100) { // Update every ~6 frames
      updateLiquidTemperatureMap();
      liquidTempUpdateTimer = 0;
    }
    
    // Base temperature (cooler at bottom, warmer at top for lava lamp effect)
    let temp = 0.3 + (canvas.height - y) / canvas.height * 0.2;
    
    // Add heat from mouse/touch interaction
    if (mouseX !== CONSTANTS.OFFSCREEN_MOUSE && mouseY !== CONSTANTS.OFFSCREEN_MOUSE) {
      const dx = x - mouseX;
      const dy = y - mouseY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const heatRadius = 150 * DPR;
      
      if (dist < heatRadius) {
        const heatStrength = (1 - dist / heatRadius) * 0.6;
        temp += heatStrength;
      }
    }
    
    return Math.max(0, Math.min(1, temp));
  }

  // Update temperature map for spatial caching (performance optimization)
  function updateLiquidTemperatureMap() {
    liquidTemperatureMap.clear();
    // Temperature map is computed on-demand in getLiquidTemperature for simplicity
    // This function exists for future spatial caching optimizations
  }

  // Metaball rendering for liquid behavior
  function drawLiquidMetaballs(ctx) {
    if (balls.length === 0) return;
    
    // Performance optimization: use composite operation for metaball effect
    ctx.save();
    
    // First pass: draw all balls with additive blending
    ctx.globalCompositeOperation = 'lighter';
    
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      
      // Get temperature for color variation
      const temp = getLiquidTemperature(ball.x, ball.y);
      
      // Create gradient based on temperature
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, ball.r);
      
      // Hot areas are brighter/more orange, cool areas are darker
      const baseColor = ball.color;
      const rgb = hexToRgb(baseColor);
      if (rgb) {
        const intensity = 0.3 + temp * 0.7;
        const warmth = temp * 0.3;
        
        gradient.addColorStop(0, `rgba(${Math.min(255, rgb.r + warmth * 100)}, ${Math.min(255, rgb.g + warmth * 50)}, ${rgb.b}, ${intensity})`);
        gradient.addColorStop(0.7, `rgba(${Math.min(255, rgb.r + warmth * 50)}, ${Math.min(255, rgb.g + warmth * 25)}, ${rgb.b}, ${intensity * 0.6})`);
        gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
      } else {
        // Fallback if color parsing fails
        gradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 + temp * 0.7})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      }
      
      ctx.save();
      ctx.translate(ball.x, ball.y);
      
      // Draw metaball with gradient
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, ball.r * liquidMergeThreshold, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
    
    ctx.restore();
  }

  // Helper function to convert hex color to RGB
  function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  // Magnetic behavior: balls act as magnetic particles with polarity and field interactions
  function stepMagnetic(ball, dt) {
    // Initialize magnetic properties if not set
    if (ball.magneticPolarity === undefined) {
      ball.magneticPolarity = Math.random() < 0.5 ? 1 : -1; // North or South
      ball.magneticCharge = Math.random() * 0.5 + 0.5; // 0.5 to 1.0 charge strength
    }
    
    // Apply standard gravity (reduced)
    ball.vy += (G * gravityScale * 0.3) * dt;
    
    // Apply magnetic forces
    applyMagneticFieldForces(ball, dt);
    applyMagneticInteractions(ball, dt);
    
    // Random polarity flips based on chaos setting
    if (Math.random() < (magnetPolarityChaos / 100) * dt) {
      ball.magneticPolarity *= -1;
      // Chance to switch color on polarity flip
      if (Math.random() < (magnetColorSwitch / 100)) {
        ball.color = pickRandomColor();
      }
    }
    
    // Integrate motion
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;
    
    // Maintain circular shape
    const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
    ball.squashAmount += (0 - ball.squashAmount) * decay;
    ball.squash = 1 - ball.squashAmount;
  }

  // Apply magnetic field forces (invisible field lines across the canvas)
  function applyMagneticFieldForces(ball, dt) {
    // Update field directions periodically
    magnetFieldTimer += dt;
    if (magnetFieldTimer > 2.0 || magnetFieldDirections.length === 0) {
      magnetFieldDirections = [];
      for (let i = 0; i < magnetFieldLines; i++) {
        magnetFieldDirections.push({
          angle: (i / magnetFieldLines) * Math.PI * 2,
          strength: 0.5 + Math.random() * 0.5,
          centerX: Math.random() * canvas.width,
          centerY: Math.random() * canvas.height
        });
      }
      magnetFieldTimer = 0;
    }
    
    // Apply forces from each field line
    for (let i = 0; i < magnetFieldDirections.length; i++) {
      const field = magnetFieldDirections[i];
      const dx = ball.x - field.centerX;
      const dy = ball.y - field.centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > magnetRange) continue;
      
      // Field strength decreases with distance
      const fieldInfluence = (1 - dist / magnetRange) * field.strength;
      const force = magnetFieldStrength * ball.magneticCharge * ball.magneticPolarity * fieldInfluence;
      
      // Force perpendicular to field line (like magnetic field)
      const fieldDx = Math.cos(field.angle);
      const fieldDy = Math.sin(field.angle);
      
      // Cross product for perpendicular force
      const perpX = -fieldDy;
      const perpY = fieldDx;
      
      ball.vx += perpX * force * dt;
      ball.vy += perpY * force * dt;
      
      // Add spinning motion around field lines
      if (magnetSpinForce > 0) {
        const spinForce = magnetSpinForce * fieldInfluence * ball.magneticPolarity;
        const spinX = -dy / Math.max(dist, 1);
        const spinY = dx / Math.max(dist, 1);
        
        ball.vx += spinX * spinForce * dt;
        ball.vy += spinY * spinForce * dt;
      }
    }
  }

  // Apply magnetic interactions between balls
  function applyMagneticInteractions(ball, dt) {
    for (let i = 0; i < balls.length; i++) {
      const other = balls[i];
      if (other === ball) continue;
      if (other.magneticPolarity === undefined) continue;
      
      const dx = other.x - ball.x;
      const dy = other.y - ball.y;
      const distSq = dx * dx + dy * dy;
      const maxInteractionDist = magnetRange * 0.8;
      
      if (distSq > maxInteractionDist * maxInteractionDist) continue;
      if (distSq < 1) continue; // Avoid singularity
      
      const dist = Math.sqrt(distSq);
      const nx = dx / dist;
      const ny = dy / dist;
      
      // Magnetic force: opposite polarities attract, same polarities repel
      const polarityProduct = ball.magneticPolarity * other.magneticPolarity;
      const chargeProduct = ball.magneticCharge * other.magneticCharge;
      const force = -polarityProduct * chargeProduct * magnetFieldStrength * 0.5 / distSq;
      
      ball.vx += nx * force * dt;
      ball.vy += ny * force * dt;
    }
  }

  // Initialize magnetic behavior
  function initMagnetic() {
    balls.length = 0; // Clear existing balls
    magnetFieldDirections = []; // Reset field directions
    magnetFieldTimer = 0;
    
    // Create magnetic particles
    const numParticles = Math.min(80, MAX_BALLS);
    for (let i = 0; i < numParticles; i++) {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      const r = (R_MIN + R_MAX) / 2;
      const color = pickRandomColor();
      
      const ball = new Ball(x, y, r, color);
      ball.magneticPolarity = Math.random() < 0.5 ? 1 : -1;
      ball.magneticCharge = Math.random() * 0.5 + 0.5;
      
      // Small initial velocities
      ball.vx = (Math.random() - 0.5) * 100;
      ball.vy = (Math.random() - 0.5) * 100;
      
      balls.push(ball);
    }
  }

  // UI elements
  const restitutionSlider = document.getElementById('restitutionSlider');
  const frictionSlider = document.getElementById('frictionSlider');
  const emitterSlider = document.getElementById('emitterSlider');
  const sizeSlider = document.getElementById('sizeSlider');
  const maxBallsSlider = document.getElementById('maxBallsSlider');
  const sizeVariationSlider = document.getElementById('sizeVariationSlider');
  const weightSlider = document.getElementById('weightSlider');
  const spawnYSlider = document.getElementById('spawnYSlider');
  const spawnWidthSlider = document.getElementById('spawnWidthSlider');
  const spawnCenterSlider = document.getElementById('spawnCenterSlider');
  const spawnHeightSlider = document.getElementById('spawnHeightSlider');
  const repelSizeSlider = document.getElementById('repelSizeSlider');
  const repelPowerSlider = document.getElementById('repelPowerSlider');
  const repelSoftSlider = document.getElementById('repelSoftSlider');
  // Color controls
  const colorSelect = document.getElementById('colorSelect');
  const color1 = document.getElementById('color1');
  const color2 = document.getElementById('color2');
  const color3 = document.getElementById('color3');
  const color4 = document.getElementById('color4');
  const color5 = document.getElementById('color5');
  const color6 = document.getElementById('color6');
  const color7 = document.getElementById('color7');
  const color8 = document.getElementById('color8');
  const cursorColorSelect = document.getElementById('cursorColorSelect');
  // Hex spans
  const color1Val = document.getElementById('color1Val');
  const color2Val = document.getElementById('color2Val');
  const color3Val = document.getElementById('color3Val');
  const color4Val = document.getElementById('color4Val');
  const color5Val = document.getElementById('color5Val');
  const color6Val = document.getElementById('color6Val');
  const color7Val = document.getElementById('color7Val');
  const color8Val = document.getElementById('color8Val');
  // Tooltip hint for copy action
  [color1Val, color2Val, color3Val, color4Val, color5Val, color6Val, color7Val, color8Val].forEach(el => {
    if (el) el.setAttribute('title', 'Click to copy');
  });
  // Scene controls
  const cornerRadiusSlider = document.getElementById('cornerRadiusSlider');
  const cornerRadiusVal = document.getElementById('cornerRadiusVal');
  const trailFadeSlider = document.getElementById('trailFadeSlider');
  const trailFadeVal = document.getElementById('trailFadeVal');
  const trailSubtletySlider = document.getElementById('trailSubtletySlider');
  const trailSubtletyVal = document.getElementById('trailSubtletyVal');
  
  // Behavior sliders/controls
  const behaviorSelect = document.getElementById('behaviorSelect');
  const fliesMaxSpeedSlider = document.getElementById('fliesMaxSpeedSlider');
  const fliesSeekGainSlider = document.getElementById('fliesSeekGainSlider');
  const fliesWanderSlider = document.getElementById('fliesWanderSlider');
  const fliesJitterSlider = document.getElementById('fliesJitterSlider');
  const fliesSpeedMulSlider = document.getElementById('fliesSpeedMulSlider');
  const fliesScatterRadiusSlider = document.getElementById('fliesScatterRadiusSlider');
  const fliesScatterVarSlider = document.getElementById('fliesScatterVarSlider');
  const fliesMaxSpeedVal = document.getElementById('fliesMaxSpeedVal');
  const fliesSeekGainVal = document.getElementById('fliesSeekGainVal');
  const fliesWanderVal = document.getElementById('fliesWanderVal');
  const fliesJitterVal = document.getElementById('fliesJitterVal');
  const fliesSpeedMulVal = document.getElementById('fliesSpeedMulVal');
  const fliesScatterRadiusVal = document.getElementById('fliesScatterRadiusVal');
  const fliesScatterVarVal = document.getElementById('fliesScatterVarVal');
  const snakeSegmentsSlider = document.getElementById('snakeSegmentsSlider');
  const snakeSpacingSlider = document.getElementById('snakeSpacingSlider');
  // Removed explicit head gain and max speed sliders to simplify UI
  const snakeSpeedMulSlider = document.getElementById('snakeSpeedMulSlider');
  const snakeSegmentsVal = document.getElementById('snakeSegmentsVal');
  const snakeSpacingVal = document.getElementById('snakeSpacingVal');
  // Values are derived from speed multiplier and defaults now
  const snakeSpeedMulVal = document.getElementById('snakeSpeedMulVal');
  const snakeSwayAmpSlider = document.getElementById('snakeSwayAmpSlider');
  const snakeSwayFreqSlider = document.getElementById('snakeSwayFreqSlider');
  const snakeIdleWanderSlider = document.getElementById('snakeIdleWanderSlider');
  const snakeSwayAmpVal = document.getElementById('snakeSwayAmpVal');
  const snakeSwayFreqVal = document.getElementById('snakeSwayFreqVal');
  const snakeIdleWanderVal = document.getElementById('snakeIdleWanderVal');

  const restitutionVal = document.getElementById('restitutionVal');
  const frictionVal = document.getElementById('frictionVal');
  const emitterVal = document.getElementById('emitterVal');
  const sizeVal = document.getElementById('sizeVal');
  const maxBallsVal = document.getElementById('maxBallsVal');
  const sizeVariationVal = document.getElementById('sizeVariationVal');
  const weightVal = document.getElementById('weightVal');
  const spawnYVal = document.getElementById('spawnYVal');
  const spawnWidthVal = document.getElementById('spawnWidthVal');
  const spawnCenterVal = document.getElementById('spawnCenterVal');
  const spawnHeightVal = document.getElementById('spawnHeightVal');
  const repelSizeVal = document.getElementById('repelSizeVal');
  const repelPowerVal = document.getElementById('repelPowerVal');
  const repelSoftVal = document.getElementById('repelSoftVal');
  // Scene controls vals (shadows removed)

  // Config capture and build functionality (restored)
  function captureCurrentConfig() {
    return {
      gravityMultiplier,
      restitution: REST,
      friction: FRICTION,
      ballMass: ballMassKg,
      emitRate: EMIT_INTERVAL,
      maxBalls: MAX_BALLS,
      ballScale: sizeScale,
      ballVariation: sizeVariation,
      spawnX: SPAWN_X_CENTER_VW,
      spawnY: SPAWN_Y_VH,
      spawnWidth: SPAWN_W_VW,
      spawnHeight: SPAWN_H_VH,
      sweepEnabled: EMITTER_SWEEP_ENABLED,
      repelRadius,
      repelPower,
      repelSoftness: repelSoft,
      repelResponsive,
      repelMinSize,
      repelMaxSize,
      trailFade,
      trailSubtlety,
      behaviorMode,
      // Flies
      fliesSpeedMul,
      fliesMaxSpeed,
      fliesSeekGain,
      fliesWanderStrength,
      fliesJitter,
      fliesScatterRadius,
      fliesScatterVarPct,
      // Trail (formerly Print)
      trailSmoothing,
      generalSmoothing,
      trailLength,
      trailSpawnRate,
      colors: currentColors.slice(),
      colorWeights: COLOR_WEIGHTS.slice(),
      currentTemplate,
      cursorColorIndex: cursorBallIndex
    };
  }
  function generateConfigCode(config) {
    return `// Generated configuration from frontend\nconst CONFIG = ${JSON.stringify(config, null, 2)};`;
  }
  const saveConfigBtn = document.getElementById('saveConfigBtn');
  const buildBtn = document.getElementById('buildBtn');
  const configOutput = document.getElementById('configOutput');
  if (saveConfigBtn && buildBtn && configOutput) {
    saveConfigBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      const configJson = JSON.stringify(config, null, 2);
      
      // Show the config and instructions
      configOutput.style.display = 'block';
      configOutput.innerHTML = `
<strong>💾 Configuration Export</strong><br><br>
<strong>Option 1: Auto-save to file</strong><br>
Copy this command and run in terminal:<br>
<code style="background: #f0f0f0; padding: 2px 4px; border-radius: 2px; font-size: 9px; display: block; margin: 4px 0; word-break: break-all;">echo '${configJson.replace(/'/g, "\\'")}' | npm run save-config</code><br>
<strong>Option 2: Manual download</strong><br>
<button id="downloadConfigBtn" style="background: #FF9800; color: white; border: none; padding: 4px 8px; border-radius: 2px; cursor: pointer; font-size: 10px; margin: 4px 0;">📥 Download JSON</button><br><br>
<strong>Current Configuration:</strong><br>
<pre style="background: #f8f8f8; padding: 6px; border-radius: 3px; font-size: 8px; max-height: 100px; overflow-y: auto; margin: 4px 0;">${configJson}</pre>`;
      
      // Add download functionality
      const downloadBtn = document.getElementById('downloadConfigBtn');
      if (downloadBtn) {
        downloadBtn.addEventListener('click', () => {
          const blob = new Blob([configJson], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'current-config.json';
          a.click();
          URL.revokeObjectURL(url);
          
          downloadBtn.textContent = '✅ Downloaded!';
          setTimeout(() => { downloadBtn.textContent = '📥 Download JSON'; }, 1200);
        });
      }
      
      // Copy the terminal command to clipboard
      const command = `echo '${configJson.replace(/'/g, "\\'")}' | npm run save-config`;
      navigator.clipboard.writeText(command).then(() => {
        const old = saveConfigBtn.textContent;
        saveConfigBtn.textContent = '✅ Command Copied!';
        setTimeout(() => { saveConfigBtn.textContent = old; }, 2000);
      }).catch(() => {
        console.warn('Clipboard copy failed');
        const old = saveConfigBtn.textContent;
        saveConfigBtn.textContent = '⚠️ Copy failed';
        setTimeout(() => { saveConfigBtn.textContent = old; }, 1200);
      });
    });
    buildBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      configOutput.style.display = 'block';
      configOutput.innerHTML = `
<strong>🚀 Build Instructions:</strong><br>
1. Run: <code>npm run build</code><br>
2. Your current config will be baked into <code>public/js/bouncy-balls-embed.js</code>`;
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'current-config.json'; a.click();
      URL.revokeObjectURL(url);
    });
  }

  // Click-to-copy helper
  function bindCopyOnClick(el, getText) {
    if (!el) return;
    el.addEventListener('click', async () => {
      const text = typeof getText === 'function' ? getText() : String(getText || '').trim();
      try {
        await navigator.clipboard.writeText(text);
        const old = el.textContent;
        el.textContent = 'COPIED';
        el.style.color = '#3ddc84';
        setTimeout(() => { el.textContent = old; el.style.color = '#888'; }, 900);
      } catch (e) {
        console.warn('Clipboard unavailable');
      }
    });
  }

  // Sliders
  restitutionSlider && restitutionSlider.addEventListener('input', () => { REST = parseFloat(restitutionSlider.value); restitutionVal && (restitutionVal.textContent = REST.toFixed(2)); });
  frictionSlider && frictionSlider.addEventListener('input', () => { FRICTION = parseFloat(frictionSlider.value); frictionVal && (frictionVal.textContent = FRICTION.toFixed(4)); });
  emitterSlider && emitterSlider.addEventListener('input', () => { EMIT_INTERVAL = parseFloat(emitterSlider.value); emitterVal && (emitterVal.textContent = EMIT_INTERVAL.toFixed(3)); });
  sizeSlider && sizeSlider.addEventListener('input', () => {
    const newScale = parseFloat(sizeSlider.value);
    sizeVal && (sizeVal.textContent = newScale.toFixed(1));
    sizeScale = newScale;
    // Recompute effective scale and proportionally resize existing balls
    updateEffectiveScaleAndBallSizes();
    // Keep shared mass
    for (let i=0; i<balls.length; i++) { balls[i].m = ballMassKg; }
  });
  maxBallsSlider && maxBallsSlider.addEventListener('input', () => {
    MAX_BALLS = parseInt(maxBallsSlider.value, 10);
    maxBallsVal && (maxBallsVal.textContent = MAX_BALLS.toString());
    // Remove excess balls if current count exceeds new limit (remove from end for better performance)
    if (balls.length > MAX_BALLS) {
      balls.length = MAX_BALLS; // Truncate array efficiently
    }
  });
  sizeVariationSlider && sizeVariationSlider.addEventListener('input', () => {
    sizeVariation = parseFloat(sizeVariationSlider.value);
    sizeVariationVal && (sizeVariationVal.textContent = sizeVariation.toFixed(1));
    
    // Update existing ball sizes to reflect new variation
    updateExistingBallSizes();
  });
  weightSlider && weightSlider.addEventListener('input', () => {
    ballMassKg = parseFloat(weightSlider.value);
    weightVal && (weightVal.textContent = ballMassKg.toFixed(2));
    // Apply shared mass to all balls
    for (let i=0; i<balls.length; i++) { balls[i].m = ballMassKg; }
    // Recompute derived scaling so gravity visibly changes with weight
    recomputeMassDerivedScales();
  });
  
  // Function to update existing ball sizes based on current sizeVariation
  function updateExistingBallSizes() {
    const baseSize = (R_MIN + R_MAX) / 2;
    
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      
      if (sizeVariation === 0) {
        // No variation: all balls exactly the same size
        ball.r = baseSize;
      } else {
        // Apply variation
        const range = (R_MAX - R_MIN) / 2;
        const variedRange = range * sizeVariation;
        const minR = Math.max(1, baseSize - variedRange);
        const maxR = baseSize + variedRange;
        ball.r = randBetween(minR, maxR);
      }
      
      // Keep shared mass model (no per-ball recompute)
      ball.m = ballMassKg;
    }
  }
  spawnYSlider && spawnYSlider.addEventListener('input', () => {
    SPAWN_Y_VH = parseFloat(spawnYSlider.value);
    spawnYVal && (spawnYVal.textContent = SPAWN_Y_VH.toFixed(0));
    setCSSSize(); resize();
  });
  spawnWidthSlider && spawnWidthSlider.addEventListener('input', () => { SPAWN_W_VW = parseFloat(spawnWidthSlider.value); spawnWidthVal && (spawnWidthVal.textContent = SPAWN_W_VW.toFixed(0)); });
  spawnCenterSlider && spawnCenterSlider.addEventListener('input', () => { SPAWN_X_CENTER_VW = parseFloat(spawnCenterSlider.value); spawnCenterVal && (spawnCenterVal.textContent = SPAWN_X_CENTER_VW.toFixed(0)); });
  spawnHeightSlider && spawnHeightSlider.addEventListener('input', () => { SPAWN_H_VH = parseFloat(spawnHeightSlider.value); spawnHeightVal && (spawnHeightVal.textContent = SPAWN_H_VH.toFixed(0)); });
  repelSizeSlider && repelSizeSlider.addEventListener('input', () => {
    const v = parseFloat(repelSizeSlider.value);
    // When user adjusts explicit size, temporarily disable responsive sizing
    repelResponsive = false;
    repelRadius = v;
    repelSizeVal && (repelSizeVal.textContent = repelRadius.toFixed(0));
    repellerEnabled = repellerEnabled || (repelPower > 0 && repelRadius > 0); 
  });

  // Responsive repel UI controls
  const repelResponsiveToggle = document.getElementById('repelResponsiveToggle');
  const repelMinSizeSlider = document.getElementById('repelMinSizeSlider');
  const repelMaxSizeSlider = document.getElementById('repelMaxSizeSlider');
  const repelMinSizeVal = document.getElementById('repelMinSizeVal');
  const repelMaxSizeVal = document.getElementById('repelMaxSizeVal');
  repelResponsiveToggle && repelResponsiveToggle.addEventListener('change', () => {
    repelResponsive = !!repelResponsiveToggle.checked;
    if (repelResponsive) {
      updateRepelRadius();
    }
  });
  repelMinSizeSlider && repelMinSizeSlider.addEventListener('input', () => {
    repelMinSize = parseFloat(repelMinSizeSlider.value);
    if (repelMinSizeVal) repelMinSizeVal.textContent = Math.round(repelMinSize).toString();
    if (repelResponsive) updateRepelRadius();
  });
  repelMaxSizeSlider && repelMaxSizeSlider.addEventListener('input', () => {
    repelMaxSize = parseFloat(repelMaxSizeSlider.value);
    if (repelMaxSizeVal) repelMaxSizeVal.textContent = Math.round(repelMaxSize).toString();
    if (repelResponsive) updateRepelRadius();
  });
  repelPowerSlider && repelPowerSlider.addEventListener('input', () => {
    repelPower = repelSliderToPower(repelPowerSlider.value);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    // Do not auto-enable when template is Off; only enable via template or size/power explicit >0 with mouse over
    if (repellerSelect && repellerSelect.value !== 'off') {
      repellerEnabled = repelPower > 0 && repelRadius > 0; 
    }
  });
  repelSoftSlider && repelSoftSlider.addEventListener('input', () => {
    repelSoft = parseFloat(repelSoftSlider.value);
    repelSoftVal && (repelSoftVal.textContent = repelSoft.toFixed(1));
  });
  // Shadow event listeners removed
  
  // Color controls
  colorSelect && colorSelect.addEventListener('change', () => {
    const template = COLOR_TEMPLATES[colorSelect.value];
    if (!template) return;
    currentTemplate = colorSelect.value;
    currentColors = template.colors.slice();
    // Keep cursor index and update color
    cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor;
    // Update color pickers + hex spans
    if (color1 && color1Val) { color1.value = currentColors[0]; color1Val.textContent = currentColors[0].toUpperCase(); }
    if (color2 && color2Val) { color2.value = currentColors[1]; color2Val.textContent = currentColors[1].toUpperCase(); }
    if (color3 && color3Val) { color3.value = currentColors[2]; color3Val.textContent = currentColors[2].toUpperCase(); }
    if (color4 && color4Val) { color4.value = currentColors[3]; color4Val.textContent = currentColors[3].toUpperCase(); }
    if (color5 && color5Val) { color5.value = currentColors[4]; color5Val.textContent = currentColors[4].toUpperCase(); }
    if (color6 && color6Val) { color6.value = currentColors[5]; color6Val.textContent = currentColors[5].toUpperCase(); }
    if (color7 && color7Val) { color7.value = currentColors[6]; color7Val.textContent = currentColors[6].toUpperCase(); }
    if (color8 && color8Val) { color8.value = currentColors[7]; color8Val.textContent = currentColors[7].toUpperCase(); }
    // Update existing ball colors
    updateExistingBallColors();
    // Sync CSS variables
    syncPaletteVars();
  });

  // Individual color picker listeners (with existing ball color update)
  function updateExistingBallColors() {
    // Update colors of existing balls to use new color palette
    for (let i = 0; i < balls.length; i++) {
      balls[i].color = pickRandomColor();
    }
  }
  
  color1 && color1.addEventListener('input', () => { currentColors[0] = color1.value; color1Val && (color1Val.textContent = color1.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color2 && color2.addEventListener('input', () => { currentColors[1] = color2.value; color2Val && (color2Val.textContent = color2.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color3 && color3.addEventListener('input', () => { currentColors[2] = color3.value; color3Val && (color3Val.textContent = color3.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color4 && color4.addEventListener('input', () => { currentColors[3] = color4.value; color4Val && (color4Val.textContent = color4.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color5 && color5.addEventListener('input', () => { currentColors[4] = color5.value; color5Val && (color5Val.textContent = color5.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color6 && color6.addEventListener('input', () => { currentColors[5] = color6.value; color6Val && (color6Val.textContent = color6.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color7 && color7.addEventListener('input', () => { currentColors[6] = color7.value; color7Val && (color7Val.textContent = color7.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color8 && color8.addEventListener('input', () => { currentColors[7] = color8.value; color8Val && (color8Val.textContent = color8.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  cursorColorSelect && cursorColorSelect.addEventListener('change', () => { const idx = Math.max(1, Math.min(8, parseInt(cursorColorSelect.value, 10))) - 1; cursorBallIndex = idx; cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor; });

  // Bind click-to-copy on hex badges
  bindCopyOnClick(color1Val, () => color1.value.toUpperCase());
  bindCopyOnClick(color2Val, () => color2.value.toUpperCase());
  bindCopyOnClick(color3Val, () => color3.value.toUpperCase());
  bindCopyOnClick(color4Val, () => color4.value.toUpperCase());
  bindCopyOnClick(color5Val, () => color5.value.toUpperCase());
  bindCopyOnClick(color6Val, () => color6.value.toUpperCase());
  bindCopyOnClick(color7Val, () => color7.value.toUpperCase());
  bindCopyOnClick(color8Val, () => color8.value.toUpperCase());
  // If the user changes any color, keep the cursor color stable unless it was the one changed
  // To keep behavior simple, we do not auto-switch the cursor color here.
  
  // Scene control event listeners
  cornerRadiusSlider && cornerRadiusSlider.addEventListener('input', () => { 
    cornerRadius = parseFloat(cornerRadiusSlider.value); 
    cornerRadiusVal && (cornerRadiusVal.textContent = cornerRadius.toFixed(0)); 
  });
  trailFadeSlider && trailFadeSlider.addEventListener('input', () => { 
    trailFade = parseFloat(trailFadeSlider.value); 
    trailFadeVal && (trailFadeVal.textContent = trailFade.toFixed(3)); 
  });
  trailSubtletySlider && trailSubtletySlider.addEventListener('input', () => {
    trailSubtlety = parseFloat(trailSubtletySlider.value);
    trailSubtletyVal && (trailSubtletyVal.textContent = trailSubtlety.toFixed(2) + '×');
  });

  // Segmented behavior control listeners
  const segmentButtons = document.querySelectorAll('.segment-button');
  segmentButtons.forEach(button => {
    button.addEventListener('click', () => {
      // Remove active class from all buttons
      segmentButtons.forEach(btn => btn.classList.remove('active'));
      // Add active class to clicked button
      button.classList.add('active');
      
      // Update behavior mode
      const mode = button.getAttribute('data-behavior');
      behaviorMode = (BEHAVIOR_MODES[mode] || BEHAVIOR_MODES.pit);
      
      // Update panel to show relevant controls
      updatePanelForMode(behaviorMode);
      
      if (behaviorMode === BEHAVIOR_MODES.print) {
        initTrail();
      }
    });
  });
  fliesSpeedMulSlider && fliesSpeedMulSlider.addEventListener('input', () => { fliesSpeedMul = parseFloat(fliesSpeedMulSlider.value) / 100; fliesSpeedMulVal && (fliesSpeedMulVal.textContent = Math.round(parseFloat(fliesSpeedMulSlider.value)) + '%'); });
  fliesMaxSpeedSlider && fliesMaxSpeedSlider.addEventListener('input', () => { fliesMaxSpeed = parseFloat(fliesMaxSpeedSlider.value); fliesMaxSpeedVal && (fliesMaxSpeedVal.textContent = Math.round(fliesMaxSpeed).toString()); });
  fliesSeekGainSlider && fliesSeekGainSlider.addEventListener('input', () => { fliesSeekGain = parseFloat(fliesSeekGainSlider.value); fliesSeekGainVal && (fliesSeekGainVal.textContent = Math.round(fliesSeekGain).toString()); });
  fliesWanderSlider && fliesWanderSlider.addEventListener('input', () => { fliesWanderStrength = parseFloat(fliesWanderSlider.value); fliesWanderVal && (fliesWanderVal.textContent = Math.round(fliesWanderStrength).toString()); });
  fliesJitterSlider && fliesJitterSlider.addEventListener('input', () => { fliesJitter = parseFloat(fliesJitterSlider.value); fliesJitterVal && (fliesJitterVal.textContent = fliesJitter.toFixed(1)); });
  fliesScatterRadiusSlider && fliesScatterRadiusSlider.addEventListener('input', () => { fliesScatterRadius = parseFloat(fliesScatterRadiusSlider.value); fliesScatterRadiusVal && (fliesScatterRadiusVal.textContent = Math.round(fliesScatterRadius).toString()); });
  fliesScatterVarSlider && fliesScatterVarSlider.addEventListener('input', () => { fliesScatterVarPct = parseFloat(fliesScatterVarSlider.value) / 100; fliesScatterVarVal && (fliesScatterVarVal.textContent = Math.round(parseFloat(fliesScatterVarSlider.value)) + '%'); });
  // Trail behavior event listeners
  const trailSmoothingSlider = document.getElementById('trailSmoothingSlider');
  const trailSmoothingVal = document.getElementById('trailSmoothingVal');
  const generalSmoothingSlider = document.getElementById('generalSmoothingSlider');
  const generalSmoothingVal = document.getElementById('generalSmoothingVal');
  const trailLengthSlider = document.getElementById('trailLengthSlider');
  const trailLengthVal = document.getElementById('trailLengthVal');
  const trailSpawnRateSlider = document.getElementById('trailSpawnRateSlider');
  const trailSpawnRateVal = document.getElementById('trailSpawnRateVal');
  
  trailSmoothingSlider && trailSmoothingSlider.addEventListener('input', () => { 
    trailSmoothing = parseInt(trailSmoothingSlider.value, 10); 
    trailSmoothingVal && (trailSmoothingVal.textContent = trailSmoothing + '%'); 
  });
  generalSmoothingSlider && generalSmoothingSlider.addEventListener('input', () => { 
    generalSmoothing = parseInt(generalSmoothingSlider.value, 10); 
    generalSmoothingVal && (generalSmoothingVal.textContent = generalSmoothing + '%'); 
  });
  trailLengthSlider && trailLengthSlider.addEventListener('input', () => { 
    trailLength = parseInt(trailLengthSlider.value, 10); 
    trailLengthVal && (trailLengthVal.textContent = trailLength.toString()); 
  });
  trailSpawnRateSlider && trailSpawnRateSlider.addEventListener('input', () => { 
    trailSpawnRate = parseInt(trailSpawnRateSlider.value, 10); 
    trailSpawnRateVal && (trailSpawnRateVal.textContent = trailSpawnRate.toString()); 
  });

  // Liquid behavior event listeners
  const liquidViscositySlider = document.getElementById('liquidViscositySlider');
  const liquidViscosityVal = document.getElementById('liquidViscosityVal');
  const liquidCohesionSlider = document.getElementById('liquidCohesionSlider');
  const liquidCohesionVal = document.getElementById('liquidCohesionVal');
  const liquidSurfaceTensionSlider = document.getElementById('liquidSurfaceTensionSlider');
  const liquidSurfaceTensionVal = document.getElementById('liquidSurfaceTensionVal');
  const liquidTempSensitivitySlider = document.getElementById('liquidTempSensitivitySlider');
  const liquidTempSensitivityVal = document.getElementById('liquidTempSensitivityVal');
  const liquidMergeThresholdSlider = document.getElementById('liquidMergeThresholdSlider');
  const liquidMergeThresholdVal = document.getElementById('liquidMergeThresholdVal');
  const liquidBuoyancySlider = document.getElementById('liquidBuoyancySlider');
  const liquidBuoyancyVal = document.getElementById('liquidBuoyancyVal');

  liquidViscositySlider && liquidViscositySlider.addEventListener('input', () => { 
    liquidViscosity = parseFloat(liquidViscositySlider.value); 
    liquidViscosityVal && (liquidViscosityVal.textContent = liquidViscosity.toFixed(2)); 
  });
  liquidCohesionSlider && liquidCohesionSlider.addEventListener('input', () => { 
    liquidCohesion = parseFloat(liquidCohesionSlider.value); 
    liquidCohesionVal && (liquidCohesionVal.textContent = Math.round(liquidCohesion).toString()); 
  });
  liquidSurfaceTensionSlider && liquidSurfaceTensionSlider.addEventListener('input', () => { 
    liquidSurfaceTension = parseFloat(liquidSurfaceTensionSlider.value); 
    liquidSurfaceTensionVal && (liquidSurfaceTensionVal.textContent = liquidSurfaceTension.toFixed(2)); 
  });
  liquidTempSensitivitySlider && liquidTempSensitivitySlider.addEventListener('input', () => { 
    liquidTempSensitivity = parseFloat(liquidTempSensitivitySlider.value); 
    liquidTempSensitivityVal && (liquidTempSensitivityVal.textContent = liquidTempSensitivity.toFixed(1)); 
  });
  liquidMergeThresholdSlider && liquidMergeThresholdSlider.addEventListener('input', () => { 
    liquidMergeThreshold = parseFloat(liquidMergeThresholdSlider.value); 
    liquidMergeThresholdVal && (liquidMergeThresholdVal.textContent = liquidMergeThreshold.toFixed(1)); 
  });
  liquidBuoyancySlider && liquidBuoyancySlider.addEventListener('input', () => { 
    liquidBuoyancy = parseFloat(liquidBuoyancySlider.value); 
    liquidBuoyancyVal && (liquidBuoyancyVal.textContent = Math.round(liquidBuoyancy).toString()); 
  });

  // Magnetic behavior event listeners
  const magnetFieldStrengthSlider = document.getElementById('magnetFieldStrengthSlider');
  const magnetFieldStrengthVal = document.getElementById('magnetFieldStrengthVal');
  const magnetPolarityChaosSlider = document.getElementById('magnetPolarityChaosSlider');
  const magnetPolarityChaosVal = document.getElementById('magnetPolarityChaosVal');
  const magnetFieldLinesSlider = document.getElementById('magnetFieldLinesSlider');
  const magnetFieldLinesVal = document.getElementById('magnetFieldLinesVal');
  const magnetSpinForceSlider = document.getElementById('magnetSpinForceSlider');
  const magnetSpinForceVal = document.getElementById('magnetSpinForceVal');
  const magnetRangeSlider = document.getElementById('magnetRangeSlider');
  const magnetRangeVal = document.getElementById('magnetRangeVal');
  const magnetColorSwitchSlider = document.getElementById('magnetColorSwitchSlider');
  const magnetColorSwitchVal = document.getElementById('magnetColorSwitchVal');

  magnetFieldStrengthSlider && magnetFieldStrengthSlider.addEventListener('input', () => { 
    magnetFieldStrength = parseFloat(magnetFieldStrengthSlider.value); 
    magnetFieldStrengthVal && (magnetFieldStrengthVal.textContent = Math.round(magnetFieldStrength).toString()); 
  });
  magnetPolarityChaosSlider && magnetPolarityChaosSlider.addEventListener('input', () => { 
    magnetPolarityChaos = parseFloat(magnetPolarityChaosSlider.value); 
    magnetPolarityChaosVal && (magnetPolarityChaosVal.textContent = Math.round(magnetPolarityChaos) + '%'); 
  });
  magnetFieldLinesSlider && magnetFieldLinesSlider.addEventListener('input', () => { 
    magnetFieldLines = parseInt(magnetFieldLinesSlider.value, 10); 
    magnetFieldLinesVal && (magnetFieldLinesVal.textContent = magnetFieldLines.toString()); 
    magnetFieldDirections = []; // Reset field directions when count changes
  });
  magnetSpinForceSlider && magnetSpinForceSlider.addEventListener('input', () => { 
    magnetSpinForce = parseFloat(magnetSpinForceSlider.value); 
    magnetSpinForceVal && (magnetSpinForceVal.textContent = Math.round(magnetSpinForce).toString()); 
  });
  magnetRangeSlider && magnetRangeSlider.addEventListener('input', () => { 
    magnetRange = parseFloat(magnetRangeSlider.value); 
    magnetRangeVal && (magnetRangeVal.textContent = Math.round(magnetRange).toString()); 
  });
  magnetColorSwitchSlider && magnetColorSwitchSlider.addEventListener('input', () => { 
    magnetColorSwitch = parseFloat(magnetColorSwitchSlider.value); 
    magnetColorSwitchVal && (magnetColorSwitchVal.textContent = Math.round(magnetColorSwitch) + '%'); 
  });

  // Presets (10 each)
  // Rubber-focused physics presets under Earth gravity (≈1960 px/s²)
  const PHYSICS_PRESETS = {
    rubberPlayground: { label: 'Rubber – Playground', G: 1960, REST: 0.90, FRICTION: 0.0025, sizeScale: 1.8, maxBalls: 450, sizeVariation: 0.20 },
    rubberRacquet:    { label: 'Rubber – Racquetball', G: 3320, REST: 0.97, FRICTION: 0.0035, sizeScale: 2.1, maxBalls: 350, sizeVariation: 0.30 },
    rubberSuperball:  { label: 'Rubber – Superball', G: 1960, REST: 0.95, FRICTION: 0.0015, sizeScale: 1.2, maxBalls: 450, sizeVariation: 0.05 },
    rubberSoft:       { label: 'Rubber – Soft', G: 1960, REST: 0.86, FRICTION: 0.0035, sizeScale: 2.2, maxBalls: 350, sizeVariation: 0.25 },
    rubberHeavy:      { label: 'Rubber – Heavy', G: 1960, REST: 0.88, FRICTION: 0.0030, sizeScale: 2.0, maxBalls: 400, sizeVariation: 0.15 }
  };

  const SPAWN_PRESETS = {
    fullRain:       { label: 'Full Rain (top-half)', EMIT_INTERVAL: 0.030, xCenter: 50, y: -50, w: 100, h: 50 },
    narrowStrip:    { label: 'Narrow Strip Top', EMIT_INTERVAL: 0.050, xCenter: 50, y: -40, w: 20,  h: 10 },
    leftGutter:     { label: 'Left Gutter', EMIT_INTERVAL: 0.045, xCenter: 10, y: -60, w: 18,  h: 20 },
    rightGutter:    { label: 'Right Gutter', EMIT_INTERVAL: 0.045, xCenter: 90, y: -60, w: 18,  h: 20 },
    centerFountain: { label: 'Center Fountain', EMIT_INTERVAL: 0.020, xCenter: 50, y: -30, w: 30,  h: 20 },
    stormBurst:     { label: 'Storm Burst', EMIT_INTERVAL: 0.005, xCenter: 50, y: -80, w: 100, h: 30 },
    slowSnow:       { label: 'Slow Snow', EMIT_INTERVAL: 0.200, xCenter: 50, y: -30, w: 100, h: 20 },
    edgeDrizzle:    { label: 'Edge Drizzle', EMIT_INTERVAL: 0.080, xCenter: 15, y: -40, w: 30,  h: 15 },
    twinColumns:    { label: 'Twin Columns', EMIT_INTERVAL: 0.030, xCenter: 30, y: -50, w: 10,  h: 40 },
    focusedBeam:    { label: 'Focused Beam', EMIT_INTERVAL: 0.015, xCenter: 50, y: -70, w: 6,   h: 12 }
  };

  const REPELLER_PRESETS = {
    off:         { label: 'Off', r: 710,   p: 27400 * 10, s: 4.4 },
    gentle:      { label: 'Gentle Breeze', r: 120, p: 2500, s: 2.5 },
    pushField:   { label: 'Push Field', r: 240, p: 8000 * 10, s: 2.0 },
    tractor:     { label: 'Tractor Push', r: 320, p: 14000 * 10, s: 1.6 },
    magnet:      { label: 'Magnet Repel', r: 200, p: 18000 * 10, s: 3.0 },
    pulse:       { label: 'Pulse Strong', r: 280, p: 22000 * 10, s: 1.2 },
    wideSoft:    { label: 'Wide Soft', r: 500, p: 8000 * 10, s: 4.5 },
    needle:      { label: 'Needle Point', r: 80,  p: 26000 * 10, s: 0.8 },
    wall:        { label: 'Invisible Wall', r: 700, p: 16000 * 10, s: 5.0 },
    singularity: { label: 'Singularity', r: 600, p: 30000 * 10, s: 0.5 }
  };

  // Shadow presets removed for better performance


  // Populate selects
  function fillSelect(select, dict, selectedKey) {
    select.innerHTML = '';
    for (const [key, val] of Object.entries(dict)) {
      const opt = document.createElement('option');
      opt.value = key; opt.textContent = val.label || key; if (key === selectedKey) opt.selected = true;
      select.appendChild(opt);
    }
  }

  const physicsSelect = document.getElementById('physicsSelect');
  const spawnSelect = document.getElementById('spawnSelect');
  const repellerSelect = document.getElementById('repellerSelect');

  if (physicsSelect) fillSelect(physicsSelect, PHYSICS_PRESETS, 'rubberHeavy');
  if (spawnSelect) fillSelect(spawnSelect, SPAWN_PRESETS, 'fullRain');
  if (repellerSelect) fillSelect(repellerSelect, REPELLER_PRESETS, 'off');
  // Populate color template dropdown
  if (colorSelect) fillSelect(colorSelect, COLOR_TEMPLATES, 'industrialTeal');

  // Helper function for UI updates
  function updateSliderAndValue(slider, valueElement, value, decimals = 0) {
    if (slider) slider.value = String(value);
    if (valueElement) valueElement.textContent = decimals > 0 ? value.toFixed(decimals) : value.toString();
  }

  // Update panel to show controls relevant to the current mode
  function updatePanelForMode(mode) {
    const modeControlsTitle = document.getElementById('modeControlsTitle');
    const pitControls = document.getElementById('pitControls');
    const fliesControls = document.getElementById('fliesControls');
    const trailControls = document.getElementById('trailControls');
    
    // Hide all mode-specific controls
    if (pitControls) pitControls.style.display = 'none';
    if (fliesControls) fliesControls.style.display = 'none';
    if (trailControls) trailControls.style.display = 'none';
    
    // Show relevant controls and update title
    switch (mode) {
      case BEHAVIOR_MODES.pit:
        if (modeControlsTitle) modeControlsTitle.textContent = '🎯 Ball Pit Controls';
        if (pitControls) pitControls.style.display = 'block';
        break;
      case BEHAVIOR_MODES.flies:
        if (modeControlsTitle) modeControlsTitle.textContent = '🕊️ Flies to Light Controls';
        if (fliesControls) fliesControls.style.display = 'block';
        break;
      case BEHAVIOR_MODES.print:
        if (modeControlsTitle) modeControlsTitle.textContent = '🖱️ Mouse Trail Controls';
        if (trailControls) trailControls.style.display = 'block';
        break;
      default:
        if (modeControlsTitle) modeControlsTitle.textContent = '🎯 Ball Pit Controls';
        if (pitControls) pitControls.style.display = 'block';
        break;
    }
  }

  // Reusable event listener factory for sliders
  // Removed unused slider listener factory

  // Apply preset helpers
  function applyPhysicsPreset(key) {
    const p = PHYSICS_PRESETS[key]; if (!p) return;
    // Keep gravity constant (1.1x Earth). Only apply REST and FRICTION from preset.
    REST = p.REST; FRICTION = p.FRICTION;
    MAX_BALLS = p.maxBalls; sizeVariation = p.sizeVariation;
    const newScale = p.sizeScale;
    sizeScale = newScale;
    // Recompute effective scale and proportionally resize existing balls
    updateEffectiveScaleAndBallSizes();
    for (let i=0; i<balls.length; i++) { balls[i].m = ballMassKg; }
    
    // Remove excess balls if new limit is lower (truncate efficiently)
    if (balls.length > MAX_BALLS) { balls.length = MAX_BALLS; }
    
    // Update UI efficiently (gravity is fixed; no slider to update)
    updateSliderAndValue(restitutionSlider, restitutionVal, REST, 2);
    updateSliderAndValue(frictionSlider, frictionVal, FRICTION, 4);
    updateSliderAndValue(sizeSlider, sizeVal, sizeScale, 1);
    updateSliderAndValue(maxBallsSlider, maxBallsVal, MAX_BALLS, 0);
    updateSliderAndValue(sizeVariationSlider, sizeVariationVal, sizeVariation, 1);
    
    // Apply the new size variation to existing balls
    updateExistingBallSizes();
  }
  function applySpawnPreset(key) {
    const s = SPAWN_PRESETS[key]; if (!s) return;
    EMIT_INTERVAL = s.EMIT_INTERVAL; SPAWN_X_CENTER_VW = s.xCenter; SPAWN_Y_VH = s.y; SPAWN_W_VW = s.w; SPAWN_H_VH = s.h;
    updateSliderAndValue(emitterSlider, emitterVal, EMIT_INTERVAL, 3);
    updateSliderAndValue(spawnCenterSlider, spawnCenterVal, SPAWN_X_CENTER_VW, 0);
    updateSliderAndValue(spawnYSlider, spawnYVal, SPAWN_Y_VH, 0);
    updateSliderAndValue(spawnWidthSlider, spawnWidthVal, SPAWN_W_VW, 0);
    updateSliderAndValue(spawnHeightSlider, spawnHeightVal, SPAWN_H_VH, 0);
  }
  function applyRepellerPreset(key) {
    const r = REPELLER_PRESETS[key]; if (!r) return;
    repelRadius = r.r; repelPower = r.p * (REPELLER_GLOBAL_MULTIPLIER / 20.0); // keep perceived strength consistent after global doubling
    repellerEnabled = (key !== 'off');
    updateSliderAndValue(repelSizeSlider, repelSizeVal, repelRadius, 0);
    // Sync slider to mapped power and label
    const sliderPos = powerToRepelSlider(repelPower);
    if (repelPowerSlider) repelPowerSlider.value = String(sliderPos);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    updateSliderAndValue(repelSoftSlider, repelSoftVal, repelSoft, 1);
    if (repelResponsive) updateRepelRadius();
  }
  // Shadow preset function removed

  // Apply sane defaults FIRST (before event listeners to avoid triggering them)
  applyPhysicsPreset('rubberHeavy');
  applySpawnPreset('fullRain');
  applyRepellerPreset('off');
  // Initialize responsive repel radius on load
  updateRepelRadius();
  
  // Initialize color system
  const defaultTemplate = COLOR_TEMPLATES[currentTemplate];
  if (color1 && color1Val) { color1.value = defaultTemplate.colors[0]; color1Val.textContent = defaultTemplate.colors[0].toUpperCase(); }
  if (color2 && color2Val) { color2.value = defaultTemplate.colors[1]; color2Val.textContent = defaultTemplate.colors[1].toUpperCase(); }
  if (color3 && color3Val) { color3.value = defaultTemplate.colors[2]; color3Val.textContent = defaultTemplate.colors[2].toUpperCase(); }
  if (color4 && color4Val) { color4.value = defaultTemplate.colors[3]; color4Val.textContent = defaultTemplate.colors[3].toUpperCase(); }
  if (color5 && color5Val) { color5.value = defaultTemplate.colors[4]; color5Val.textContent = defaultTemplate.colors[4].toUpperCase(); }
  if (color6 && color6Val) { color6.value = defaultTemplate.colors[5]; color6Val.textContent = defaultTemplate.colors[5].toUpperCase(); }
  if (color7 && color7Val) { color7.value = defaultTemplate.colors[6]; color7Val.textContent = defaultTemplate.colors[6].toUpperCase(); }
  if (color8 && color8Val) { color8.value = defaultTemplate.colors[7]; color8Val.textContent = defaultTemplate.colors[7].toUpperCase(); }
  // Sync CSS variables on init
  syncPaletteVars(defaultTemplate.colors);

  // Hook presets to selects AFTER applying defaults
  physicsSelect && physicsSelect.addEventListener('change', () => applyPhysicsPreset(physicsSelect.value));
  spawnSelect && spawnSelect.addEventListener('change', () => applySpawnPreset(spawnSelect.value));
  repellerSelect && repellerSelect.addEventListener('change', () => applyRepellerPreset(repellerSelect.value));

  // Now that sizeScale is set by presets, compute responsive scale once
  updateEffectiveScaleAndBallSizes();
  
  // Initialize text colliders
  updateTextColliders();
})();
</script>

</body>
</html>
