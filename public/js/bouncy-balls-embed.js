(() => {const MODES = {PIT: 'pit',FLIES: 'flies',WEIGHTLESS: 'weightless' }; const MODE_AVAILABILITY = {[MODES.PIT]: {desktop: true,mobile: true },[MODES.FLIES]: {desktop: true,mobile: true },[MODES.WEIGHTLESS]: {desktop: true,mobile: true }}; let currentMode = MODES.PIT; let ballSoftness = 40; let gravityMultiplierPit = 1.15; let repellerEnabledPit = true; let attractionPower = 5000; let orbitRadius = 180; let swarmSpeed = 3.5; let weightlessCount = 80; let weightlessInitialSpeed = 250; let weightlessBounce = 0.97; let weightlessRepellerPower = 300; let weightlessRepellerRadius = 150; let glassMorphismEnabled = true; const ILLUMINATION_TEMPLATES = {classicRaised: {label: 'Classic Raised Button',shadow1: {offsetX: 4,offsetY: 6,opacity: 0.35,color: '#000000',sizeMultiplier: 1.12,blurRadius: 6 },shadow2: {offsetX: -2,offsetY: -3,opacity: 0.25,color: '#ffffff',sizeMultiplier: 1.03,blurRadius: 2 },shadow3: {offsetX: 1,offsetY: 2,opacity: 0.15,color: '#ffffff',sizeMultiplier: 1.01,blurRadius: 1 }},pressedInset: {label: 'Pressed/Inset Button',shadow1: {offsetX: -2,offsetY: -3,opacity: 0.3,color: '#000000',sizeMultiplier: 1.08,blurRadius: 4 },shadow2: {offsetX: 3,offsetY: 4,opacity: 0.2,color: '#ffffff',sizeMultiplier: 1.05,blurRadius: 3 },shadow3: {offsetX: 0,offsetY: 1,opacity: 0.1,color: '#cccccc',sizeMultiplier: 1.0,blurRadius: 1 }},softGlow: {label: 'Soft Glow Button',shadow1: {offsetX: 0,offsetY: 8,opacity: 0.25,color: '#000000',sizeMultiplier: 1.25,blurRadius: 12 },shadow2: {offsetX: -1,offsetY: -2,opacity: 0.3,color: '#ffffff',sizeMultiplier: 1.15,blurRadius: 8 },shadow3: {offsetX: 1,offsetY: 1,opacity: 0.2,color: '#ffffff',sizeMultiplier: 1.08,blurRadius: 4 }},sharpGlass: {label: 'Sharp Glass Button',shadow1: {offsetX: 3,offsetY: 5,opacity: 0.4,color: '#000000',sizeMultiplier: 1.05,blurRadius: 2 },shadow2: {offsetX: -1,offsetY: -2,opacity: 0.35,color: '#ffffff',sizeMultiplier: 0.98,blurRadius: 1 },shadow3: {offsetX: 2,offsetY: 3,opacity: 0.2,color: '#ffffff',sizeMultiplier: 0.95,blurRadius: 1 }},dramaticDepth: {label: 'Dramatic Depth Button',shadow1: {offsetX: 8,offsetY: 12,opacity: 0.45,color: '#000000',sizeMultiplier: 1.4,blurRadius: 16 },shadow2: {offsetX: -4,offsetY: -6,opacity: 0.4,color: '#ffffff',sizeMultiplier: 1.2,blurRadius: 6 },shadow3: {offsetX: 2,offsetY: 3,opacity: 0.25,color: '#ffffff',sizeMultiplier: 1.1,blurRadius: 3 }}}; let currentIlluminationTemplate = 'classicRaised'; function applyIlluminationTemplate(templateName) {const template = ILLUMINATION_TEMPLATES[templateName]; if (!template) return; currentIlluminationTemplate = templateName; shadow1OffsetX = template.shadow1.offsetX; shadow1OffsetY = template.shadow1.offsetY; shadow1Opacity = template.shadow1.opacity; shadow1Color = template.shadow1.color; shadow1SizeMultiplier = template.shadow1.sizeMultiplier; shadow1BlurRadius = template.shadow1.blurRadius; shadow2OffsetX = template.shadow2.offsetX; shadow2OffsetY = template.shadow2.offsetY; shadow2Opacity = template.shadow2.opacity; shadow2Color = template.shadow2.color; shadow2SizeMultiplier = template.shadow2.sizeMultiplier; shadow2BlurRadius = template.shadow2.blurRadius; shadow3OffsetX = template.shadow3.offsetX; shadow3OffsetY = template.shadow3.offsetY; shadow3Opacity = template.shadow3.opacity; shadow3Color = template.shadow3.color; shadow3SizeMultiplier = template.shadow3.sizeMultiplier; shadow3BlurRadius = template.shadow3.blurRadius; updateIlluminationUI(); console.log('ðŸ”® Applied illumination template:',templateName);}function updateIlluminationUI() {if (shadow1OffsetXEl) {shadow1OffsetXEl.value = shadow1OffsetX; shadow1OffsetXVal.textContent = shadow1OffsetX + 'px';}if (shadow1OffsetYEl) {shadow1OffsetYEl.value = shadow1OffsetY; shadow1OffsetYVal.textContent = shadow1OffsetY + 'px';}if (shadow1OpacityEl) {shadow1OpacityEl.value = shadow1Opacity; shadow1OpacityVal.textContent = shadow1Opacity.toFixed(2);}if (shadow1ColorEl) {shadow1ColorEl.value = shadow1Color; shadow1ColorVal.textContent = shadow1Color.toUpperCase();}if (shadow1SizeMultiplierEl) {shadow1SizeMultiplierEl.value = shadow1SizeMultiplier; shadow1SizeMultiplierVal.textContent = shadow1SizeMultiplier.toFixed(2) + 'Ã—';}if (shadow2OffsetXEl) {shadow2OffsetXEl.value = shadow2OffsetX; shadow2OffsetXVal.textContent = shadow2OffsetX + 'px';}if (shadow2OffsetYEl) {shadow2OffsetYEl.value = shadow2OffsetY; shadow2OffsetYVal.textContent = shadow2OffsetY + 'px';}if (shadow2OpacityEl) {shadow2OpacityEl.value = shadow2Opacity; shadow2OpacityVal.textContent = shadow2Opacity.toFixed(2);}if (shadow2ColorEl) {shadow2ColorEl.value = shadow2Color; shadow2ColorVal.textContent = shadow2Color.toUpperCase();}if (shadow2SizeMultiplierEl) {shadow2SizeMultiplierEl.value = shadow2SizeMultiplier; shadow2SizeMultiplierVal.textContent = shadow2SizeMultiplier.toFixed(2) + 'Ã—';}if (shadow3OffsetXEl) {shadow3OffsetXEl.value = shadow3OffsetX; shadow3OffsetXVal.textContent = shadow3OffsetX + 'px';}if (shadow3OffsetYEl) {shadow3OffsetYEl.value = shadow3OffsetY; shadow3OffsetYVal.textContent = shadow3OffsetY + 'px';}if (shadow3OpacityEl) {shadow3OpacityEl.value = shadow3Opacity; shadow3OpacityVal.textContent = shadow3Opacity.toFixed(2);}if (shadow3ColorEl) {shadow3ColorEl.value = shadow3Color; shadow3ColorVal.textContent = shadow3Color.toUpperCase();}if (shadow3SizeMultiplierEl) {shadow3SizeMultiplierEl.value = shadow3SizeMultiplier; shadow3SizeMultiplierVal.textContent = shadow3SizeMultiplier.toFixed(2) + 'Ã—';}}let shadow1OffsetX = 6; let shadow1OffsetY = 8; let shadow1Opacity = 0.3; let shadow1Color = '#000000'; let shadow1SizeMultiplier = 1.15; let shadow1BlurRadius = 8; let shadow2OffsetX = -3; let shadow2OffsetY = -4; let shadow2Opacity = 0.2; let shadow2Color = '#ffffff'; let shadow2SizeMultiplier = 1.05; let shadow2BlurRadius = 3; let shadow3OffsetX = 2; let shadow3OffsetY = 3; let shadow3Opacity = 0.15; let shadow3Color = '#ffffff'; let shadow3SizeMultiplier = 1.02; let shadow3BlurRadius = 2; let cursorBallVisible = true; const MASS_BASELINE_KG = 1.0; const CONSTANTS = {CANVAS_HEIGHT_VH_PIT: 1.5,CANVAS_HEIGHT_VH_DEFAULT: 1.0,OFFSCREEN_MOUSE: -1e9,MIN_DISTANCE_EPSILON: 1e-6,MIN_REPEL_DISTANCE: 1e-4,ACCUMULATOR_RESET_THRESHOLD: 3,INITIAL_SEED_BALLS: 200,BALL_SPAWN_OFFSET: 2,BALL_CLUSTER_SPACING: 8,BALL_CLUSTER_Y_OFFSET: 12,MAX_PHYSICS_STEPS: 2,FPS_UPDATE_INTERVAL: 1.0,SPIN_DAMP_PER_S: 2.0,SPIN_GAIN: 0.25,SPIN_GAIN_TANGENT: 0.18,ROLL_FRICTION_PER_S: 1.5,SQUASH_MAX_BASE: 0.20,SQUASH_DECAY_PER_S: 18.0,WALL_REST_VEL_THRESHOLD: 70,GROUND_COUPLING_PER_S: 8.0 }; function getSquashMax() {if (ballSoftness === 0) return 0; return CONSTANTS.SQUASH_MAX_BASE * (ballSoftness / 40.0);}const canvas = document.getElementById('c'); const ctx = canvas.getContext('2d',{alpha: true }); const panel = document.getElementById('controlPanel'); const container = document.getElementById('bravia-balls'); const DPR = Math.max(1,Math.min(2,window.devicePixelRatio || 1)); let useWebGL = false; let pixiApp = null; let ballSprites = new Map(); async function initWebGLRenderer() {if (!window.PIXI) {console.error('âŒ PixiJS not loaded'); return false;}try {pixiApp = new PIXI.Application({width: canvas.width,height: canvas.height,resolution: DPR,backgroundColor: 0xCECECE,antialias: true,autoDensity: true,}); pixiApp.view.style.position = 'absolute'; pixiApp.view.style.bottom = '0'; pixiApp.view.style.left = '0'; pixiApp.view.style.width = '100%'; pixiApp.view.style.height = '100%'; pixiApp.view.style.display = 'block'; pixiApp.view.style.cursor = 'none'; pixiApp.view.style.touchAction = 'none'; pixiApp.view.id = 'webgl-canvas'; container.appendChild(pixiApp.view); console.log('âœ… WebGL Renderer initialized:',pixiApp.renderer.type === PIXI.RENDERER_TYPE.WEBGL ? 'WebGL' : 'Canvas2D Fallback'); console.log('ðŸ“Š Resolution:',DPR,'| Viewport:',canvas.width,'x',canvas.height); return true;}catch (error) {console.error('âŒ WebGL initialization failed:',error); useWebGL = false; return false;}}function destroyWebGLRenderer() {if (pixiApp) {ballSprites.forEach(sprite => sprite.destroy()); ballSprites.clear(); pixiApp.destroy(true,{children: true,texture: true,baseTexture: true }); pixiApp = null; console.log('ðŸ—‘ï¸ WebGL Renderer destroyed');}}function toggleRenderer() {useWebGL = !useWebGL; if (useWebGL) {canvas.style.display = 'none'; initWebGLRenderer(); console.log('ðŸ”„ Switched to WebGL Renderer');}else {destroyWebGLRenderer(); canvas.style.display = 'block'; console.log('ðŸ”„ Switched to Canvas2D Renderer');}const toggle = document.getElementById('useWebGLToggle'); if (toggle) toggle.checked = useWebGL;}function createBallSprite(ball) {if (!pixiApp) return null; const sprite = getPooledSprite(); sprite.zIndex = 0; sprite._lastRadius = -1; sprite._lastColor = ''; sprite._lastGlassMorphismEnabled = null; sprite._lastShadow1OffsetX = null; sprite._lastShadow1OffsetY = null; sprite._lastShadow1Opacity = null; sprite._lastShadow2OffsetX = null; sprite._lastShadow2OffsetY = null; sprite._lastShadow2Opacity = null; sprite._lastShadow3OffsetX = null; sprite._lastShadow3OffsetY = null; sprite._lastShadow3Opacity = null; sprite._lastSquash = -1; pixiApp.stage.addChild(sprite); ballSprites.set(ball,sprite); return sprite;}function renderBallWebGL(ball) {if (!pixiApp) return; let sprite = ballSprites.get(ball); if (!sprite) {sprite = createBallSprite(ball); if (!sprite) return;}const colorNum = parseInt(ball.color.replace('#',''),16); const currentSquash = ball.squashAmount || 0; const needsRedraw = ( sprite._lastRadius !== ball.r || sprite._lastColor !== ball.color || sprite._lastGlassMorphismEnabled !== glassMorphismEnabled || sprite._lastShadow1OffsetX !== shadow1OffsetX || sprite._lastShadow1OffsetY !== shadow1OffsetY || sprite._lastShadow1Opacity !== shadow1Opacity || sprite._lastShadow2OffsetX !== shadow2OffsetX || sprite._lastShadow2OffsetY !== shadow2OffsetY || sprite._lastShadow2Opacity !== shadow2Opacity || sprite._lastShadow3OffsetX !== shadow3OffsetX || sprite._lastShadow3OffsetY !== shadow3OffsetY || sprite._lastShadow3Opacity !== shadow3Opacity || Math.abs(sprite._lastSquash - currentSquash) > 0.01 ); if (needsRedraw) {sprite.clear(); if (glassMorphismEnabled && (!enableShadowCulling || ball.r >= minShadowRadius)) {renderBallWithGlassMorphismWebGL(sprite,ball.r,colorNum);}else {sprite.beginFill(colorNum,1.0); sprite.drawCircle(0,0,ball.r); sprite.endFill();}sprite._lastRadius = ball.r; sprite._lastColor = ball.color; sprite._lastGlassMorphismEnabled = glassMorphismEnabled; sprite._lastShadow1OffsetX = shadow1OffsetX; sprite._lastShadow1OffsetY = shadow1OffsetY; sprite._lastShadow1Opacity = shadow1Opacity; sprite._lastShadow2OffsetX = shadow2OffsetX; sprite._lastShadow2OffsetY = shadow2OffsetY; sprite._lastShadow2Opacity = shadow2Opacity; sprite._lastShadow3OffsetX = shadow3OffsetX; sprite._lastShadow3OffsetY = shadow3OffsetY; sprite._lastShadow3Opacity = shadow3Opacity; sprite._lastSquash = currentSquash;}sprite.x = ball.x; sprite.y = ball.y; if (ball.r > 15 && ball.squashAmount > 0.001) {const amt = Math.min(getSquashMax(),Math.max(0,ball.squashAmount)); const s = 1 + amt; const inv = 1 / s; sprite.rotation = ball.squashNormalAngle; sprite.scale.x = s; sprite.scale.y = inv;}else {sprite.rotation = ball.omega ? ball.omega * 0.01 : 0; sprite.scale.x = 1; sprite.scale.y = 1;}}let cachedShadow1ColorNum = 0x000000; let cachedShadow2ColorNum = 0xffffff; let cachedShadow3ColorNum = 0xffffff; let lastShadow1Color = ''; let lastShadow2Color = ''; let lastShadow3Color = ''; function updateCachedShadowColors() {if (shadow1Color !== lastShadow1Color) {cachedShadow1ColorNum = parseInt(shadow1Color.replace('#',''),16); lastShadow1Color = shadow1Color;}if (shadow2Color !== lastShadow2Color) {cachedShadow2ColorNum = parseInt(shadow2Color.replace('#',''),16); lastShadow2Color = shadow2Color;}if (shadow3Color !== lastShadow3Color) {cachedShadow3ColorNum = parseInt(shadow3Color.replace('#',''),16); lastShadow3Color = shadow3Color;}}function renderBallWithGlassMorphismWebGL(sprite,radius,baseColor) {updateCachedShadowColors(); const isSmallBall = radius < 12; const qualityMultiplier = isSmallBall ? 0.5 : adaptiveQuality; const shadow1Radius = radius * shadow1SizeMultiplier; const shadow1Steps = Math.max(2,Math.floor(shadow1BlurRadius * qualityMultiplier)); for (let i = 0; i < shadow1Steps; i++) {const t = i / Math.max(1,shadow1Steps - 1); const blurOpacity = shadow1Opacity * (1 - t) * 0.3; const blurRadius = shadow1Radius + i * 0.5; sprite.beginFill(cachedShadow1ColorNum,blurOpacity); sprite.drawCircle(shadow1OffsetX,shadow1OffsetY,blurRadius); sprite.endFill();}const shadow2Radius = radius * shadow2SizeMultiplier; const shadow2Steps = Math.max(1,Math.floor(shadow2BlurRadius * qualityMultiplier)); for (let i = 0; i < shadow2Steps; i++) {const t = i / Math.max(1,shadow2Steps - 1); const blurOpacity = shadow2Opacity * (1 - t) * 0.4; const blurRadius = shadow2Radius + i * 0.3; sprite.beginFill(cachedShadow2ColorNum,blurOpacity); sprite.drawCircle(shadow2OffsetX,shadow2OffsetY,blurRadius); sprite.endFill();}const shadow3Radius = radius * shadow3SizeMultiplier; const shadow3Steps = Math.max(1,Math.floor(shadow3BlurRadius * qualityMultiplier)); for (let i = 0; i < shadow3Steps; i++) {const t = i / Math.max(1,shadow3Steps - 1); const blurOpacity = shadow3Opacity * (1 - t) * 0.6; const blurRadius = shadow3Radius + i * 0.1; sprite.beginFill(cachedShadow3ColorNum,blurOpacity); sprite.drawCircle(shadow3OffsetX,shadow3OffsetY,blurRadius); sprite.endFill();}sprite.beginFill(baseColor,1.0); sprite.drawCircle(0,0,radius); sprite.endFill();}function cleanupRemovedBalls() {const ballSet = new Set(balls); for (const [ball,sprite] of ballSprites.entries()) {if (!ballSet.has(ball)) {pixiApp.stage.removeChild(sprite); returnSpriteToPool(sprite); ballSprites.delete(ball);}}}let boundarySprite = null; function renderRoundedBoundaryWebGL() {if (!pixiApp || cornerRadius <= 0) return; if (!boundarySprite) {boundarySprite = new PIXI.Graphics(); boundarySprite.zIndex = -1; pixiApp.stage.addChild(boundarySprite);}boundarySprite.clear(); boundarySprite.lineStyle(2,0xffffff,0.1); const w = canvas.width; const h = canvas.height; const r = cornerRadius; boundarySprite.moveTo(r,0); boundarySprite.lineTo(w - r,0); boundarySprite.arcTo(w,0,w,r,r); boundarySprite.lineTo(w,h - r); boundarySprite.arcTo(w,h,w - r,h,r); boundarySprite.lineTo(r,h); boundarySprite.arcTo(0,h,0,h - r,r); boundarySprite.lineTo(0,r); boundarySprite.arcTo(0,0,r,0,r); boundarySprite.closePath();}function renderCursorBallWebGL() {if (!pixiApp || !cursorBallVisible) return; if (!cursorBallSprite) {cursorBallSprite = new PIXI.Graphics(); cursorBallSprite.zIndex = 1000; pixiApp.stage.addChild(cursorBallSprite);}cursorBallSprite.clear(); const colorNum = parseInt(cursorBallColor.replace('#',''),16); if (glassMorphismEnabled) {renderBallWithGlassMorphismWebGL(cursorBallSprite,cursorBallRadius,colorNum);}else {cursorBallSprite.beginFill(colorNum,0.8); cursorBallSprite.drawCircle(0,0,cursorBallRadius); cursorBallSprite.endFill();}cursorBallSprite.x = mouseX; cursorBallSprite.y = mouseY;}function renderModeIndicatorWebGL() {if (!pixiApp || isTouchDevice) return; if (!modeIndicatorSprite) {modeIndicatorSprite = new PIXI.Text('',{fontFamily: 'system-ui,-apple-system,sans-serif',fontSize: 14,fill: 0xffffff,alpha: 0.3 }); modeIndicatorSprite.zIndex = 999; modeIndicatorSprite.x = 10; modeIndicatorSprite.y = canvas.height - 30; pixiApp.stage.addChild(modeIndicatorSprite);}const modeName = currentMode.charAt(0).toUpperCase() + currentMode.slice(1); modeIndicatorSprite.text = modeName + ' Mode'; modeIndicatorSprite.y = canvas.height - 30;}let cursorBallSprite = null; let modeIndicatorSprite = null; let frameCount = 0; let lastFPSCheck = 0; let currentFPS = 60; let adaptiveQuality = 1.0; let enableLOD = true; let enableShadowCulling = true; let minShadowRadius = 8; let enableSpritePooling = true; let maxPoolSize = 100; let spritePool = []; function getPooledSprite() {if (spritePool.length > 0) {return spritePool.pop();}return new PIXI.Graphics();}function returnSpriteToPool(sprite) {if (enableSpritePooling && spritePool.length < maxPoolSize) {sprite.clear(); sprite.visible = true; sprite.x = 0; sprite.y = 0; sprite.rotation = 0; sprite.scale.set(1,1); spritePool.push(sprite);}else {sprite.destroy();}}function updateAdaptiveQuality() {frameCount++; const now = performance.now(); if (now - lastFPSCheck >= 1000) {currentFPS = frameCount; frameCount = 0; lastFPSCheck = now; if (currentFPS < 45) {adaptiveQuality = Math.max(0.3,adaptiveQuality - 0.1);}else if (currentFPS > 55) {adaptiveQuality = Math.min(1.0,adaptiveQuality + 0.05);}const shadowsSkipped = balls.filter(b => enableShadowCulling && b.r < minShadowRadius).length; const totalShadowLayers = balls.length * 3; const actualShadowLayers = (balls.length - shadowsSkipped) * 3; console.log(`ðŸŽ® WebGL FPS: ${currentFPS},Quality: ${(adaptiveQuality * 100).toFixed(0)}%,Shadows: ${actualShadowLayers}/${totalShadowLayers},Pool: ${spritePool.length}`);}}let SPAWN_X_CENTER_VW = 50; let SPAWN_Y_VH = -50; let SPAWN_W_VW = 100; let SPAWN_H_VH = 50; function resize() {const heightMultiplier = (currentMode === MODES.PIT) ? CONSTANTS.CANVAS_HEIGHT_VH_PIT : CONSTANTS.CANVAS_HEIGHT_VH_DEFAULT; const simHeight = window.innerHeight * heightMultiplier; canvas.width = Math.floor(window.innerWidth * DPR); canvas.height = Math.floor(simHeight * DPR);}const setCSSSize = () => {}; let resizeTimeout; function handleResize() {clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => {setCSSSize(); resize(); updateEffectiveScaleAndBallSizes(); updateTextColliders();},150);}setCSSSize(); resize(); window.addEventListener('resize',handleResize); const GE = 1960; let gravityMultiplier = 0; let G = GE * gravityMultiplier; let REST = 0.88; let FRICTION = 0.003; let EMIT_INTERVAL = 0.03; let MAX_BALLS = 350; const SOLVER_ITERS = 6; const POS_CORRECT_PERCENT = 0.8; const POS_CORRECT_SLOP = 0.5 * DPR; const REST_VEL_THRESHOLD = 30; const R_MIN_BASE = 6; const R_MAX_BASE = 24; let sizeScale = 0.7; let sizeVariation = 0.15; let responsiveScale = 1.0; let lastEffectiveScale = null; let ballMassKg = 19.8; const MASS_GRAVITY_EXP = 0.35; const MASS_REST_EXP = 0.15; let gravityScale = 1.0; function recomputeMassDerivedScales() {gravityScale = Math.max(0.5,Math.min(3.0,Math.pow(ballMassKg / MASS_BASELINE_KG,MASS_GRAVITY_EXP)));}recomputeMassDerivedScales(); let R_MIN = R_MIN_BASE * sizeScale; let R_MAX = R_MAX_BASE * sizeScale; function computeResponsiveScale() {const containerWidth = canvas.clientWidth || window.innerWidth; return (containerWidth <= 768) ? 0.4 : 1.0;}function updateEffectiveScaleAndBallSizes() {responsiveScale = computeResponsiveScale(); const effectiveScale = sizeScale * responsiveScale; if (lastEffectiveScale === null) {lastEffectiveScale = effectiveScale; R_MIN = R_MIN_BASE * effectiveScale; R_MAX = R_MAX_BASE * effectiveScale; return;}const ratio = effectiveScale / lastEffectiveScale; if (ratio !== 1) {for (let i = 0; i < balls.length; i++) {balls[i].r *= ratio;}lastEffectiveScale = effectiveScale;}R_MIN = R_MIN_BASE * effectiveScale; R_MAX = R_MAX_BASE * effectiveScale;}function updateTextColliders() {textColliders = []; const textElement = document.querySelector(TEXT_SELECTOR); if (!textElement) return; const textRect = textElement.getBoundingClientRect(); const canvasRect = canvas.getBoundingClientRect(); const capHeight = calculateCapHeight(textElement); const heightDifference = textRect.height - capHeight; const verticalOffset = heightDifference * 0.5; const collider = {x: (textRect.left - canvasRect.left) * DPR,y: (textRect.top - canvasRect.top + verticalOffset) * DPR,width: textRect.width * DPR,height: capHeight * DPR }; if (collider.width > 0 && collider.height > 0 && collider.x < canvas.width && collider.y < canvas.height && collider.x + collider.width > 0 && collider.y + collider.height > 0) {textColliders.push(collider);}}function calculateCapHeight(element) {const tempElement = document.createElement('span'); tempElement.style.cssText = window.getComputedStyle(element).cssText; tempElement.style.position = 'absolute'; tempElement.style.visibility = 'hidden'; tempElement.style.whiteSpace = 'nowrap'; tempElement.textContent = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; document.body.appendChild(tempElement); const capHeight = tempElement.getBoundingClientRect().height; document.body.removeChild(tempElement); return capHeight;}let EMITTER_SWEEP_ENABLED = false; let emitterPhase = 0; const EMITTER_SWEEP_HZ = 0.12; const EMITTER_SWEEP_AMPL_VW = 20; let emitterSweepDir = 1; const COLOR_TEMPLATES = {industrialTeal: {label: 'Industrial Teal',colors: ['#b7bcb7','#e4e9e4','#ffffff','#00695c','#000000','#ff4013','#0d5cb6','#ffa000'] },sunsetCoral: {label: 'Sunset Coral',colors: ['#b8b5b1','#e5e3df','#ffffff','#ff6b6b','#000000','#00d4aa','#2563eb','#f59e0b'] },violetPunch: {label: 'Violet Punch',colors: ['#b5b4bd','#e3e2e9','#ffffff','#8b5cf6','#000000','#ef4444','#06b6d4','#fbbf24'] },citrusBlast: {label: 'Citrus Blast',colors: ['#b9b7b0','#e6e4dd','#ffffff','#f59e0b','#000000','#ec4899','#3b82f6','#10b981'] },cobaltSpark: {label: 'Cobalt Spark',colors: ['#b3b6bc','#e1e4e9','#ffffff','#2563eb','#000000','#f97316','#ec4899','#eab308'] }}; let currentTemplate = 'industrialTeal'; let currentColors = COLOR_TEMPLATES.industrialTeal.colors.slice(); let cursorBallIndex = 5; let cursorBallColor = currentColors[cursorBallIndex] || '#ff4013'; function syncPaletteVars(colors = currentColors) {try {const root = document.documentElement; const list = (colors && colors.length ? colors : currentColors).slice(0,8); for (let i = 0; i < 8; i++) {const hex = list[i] || '#ffffff'; root.style.setProperty(`--ball-${i+1}`,hex);}}catch (_) {}}const COLOR_WEIGHTS = [0.50,0.25,0.12,0.06,0.03,0.02,0.01,0.01]; function pickRandomColor() {try {if (!currentColors || currentColors.length === 0) {console.warn('No colors available,using fallback'); return '#ffffff';}const random = Math.random(); let cumulativeWeight = 0; for (let i = 0; i < Math.min(currentColors.length,COLOR_WEIGHTS.length); i++) {cumulativeWeight += COLOR_WEIGHTS[i]; if (random <= cumulativeWeight) {return currentColors[i];}}return currentColors[Math.min(currentColors.length - 1,7)];}catch (error) {console.error('Error picking random color:',error); return '#ffffff';}}let repelRadius = 135; let repelPower = 1536000; let repelSoft = 3.4; let mouseX = CONSTANTS.OFFSCREEN_MOUSE,mouseY = CONSTANTS.OFFSCREEN_MOUSE; let repellerEnabled = false; const REPELLER_GLOBAL_MULTIPLIER = 20.0; let isTouchDevice = false; if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {isTouchDevice = true;}function applyDeviceSpecificModeVisibility() {}const STORAGE_KEY = 'bouncyBallsSettings'; function saveSettings() {const settings = {currentMode,gravityMultiplierPit,repellerEnabledPit,attractionPower,orbitRadius,swarmSpeed,weightlessInitialSpeed,weightlessBounce,weightlessMaxBalls,weightlessRepellerPower,weightlessRepellerRadius,restitution: REST,friction: FRICTION,sizeScale,sizeVariation,ballMassKg,ballSoftness,repelPower,repelRadius,repelSoft,cornerRadius,motionBlur: trailFade,trailSubtlety,currentTemplate,cursorBallColor }; try {localStorage.setItem(STORAGE_KEY,JSON.stringify(settings)); console.log('âœ“ Settings saved');}catch (e) {console.warn('Could not save settings:',e);}}function loadSettings() {try {const saved = localStorage.getItem(STORAGE_KEY); if (saved) {const settings = JSON.parse(saved); if (settings.currentMode) currentMode = settings.currentMode; if (settings.gravityMultiplierPit !== undefined) gravityMultiplierPit = settings.gravityMultiplierPit; if (settings.repellerEnabledPit !== undefined) repellerEnabledPit = settings.repellerEnabledPit; if (settings.attractionPower) attractionPower = settings.attractionPower; if (settings.orbitRadius) orbitRadius = settings.orbitRadius; if (settings.swarmSpeed) swarmSpeed = settings.swarmSpeed; if (settings.weightlessInitialSpeed) weightlessInitialSpeed = settings.weightlessInitialSpeed; if (settings.weightlessBounce) weightlessBounce = settings.weightlessBounce; if (settings.weightlessMaxBalls) weightlessMaxBalls = settings.weightlessMaxBalls; if (settings.weightlessRepellerPower !== undefined) weightlessRepellerPower = settings.weightlessRepellerPower; if (settings.weightlessRepellerRadius !== undefined) weightlessRepellerRadius = settings.weightlessRepellerRadius; if (settings.restitution) REST = settings.restitution; if (settings.friction !== undefined) FRICTION = settings.friction; if (settings.sizeScale) sizeScale = settings.sizeScale; if (settings.sizeVariation !== undefined) sizeVariation = settings.sizeVariation; if (settings.ballMassKg) ballMassKg = settings.ballMassKg; if (settings.repelPower) repelPower = settings.repelPower; if (settings.repelRadius) repelRadius = settings.repelRadius; if (settings.repelSoft) repelSoft = settings.repelSoft; if (settings.cornerRadius !== undefined) cornerRadius = settings.cornerRadius; if (settings.motionBlur !== undefined) trailFade = settings.motionBlur; if (settings.trailSubtlety) trailSubtlety = settings.trailSubtlety; if (settings.currentTemplate) currentTemplate = settings.currentTemplate; if (settings.cursorBallColor) cursorBallColor = settings.cursorBallColor; console.log('âœ“ Settings loaded'); return true;}}catch (e) {console.warn('Could not load settings:',e);}return false;}function autoSaveSettings() {clearTimeout(window.settingsSaveTimeout); window.settingsSaveTimeout = setTimeout(saveSettings,500);}const REPEL_BASE_POWER = 12000; const REPEL_SLIDER_MAX = 10000; const REPEL_CENTER_MULTIPLIER = 2.0; const REPEL_N_OCTAVES = 12; function repelSliderToPower(sliderValue) {const s = Math.max(0,Math.min(REPEL_SLIDER_MAX,Number(sliderValue))) / REPEL_SLIDER_MAX; const mult = REPEL_CENTER_MULTIPLIER * Math.pow(2,(s - 0.5) * REPEL_N_OCTAVES); return REPEL_BASE_POWER * mult;}function powerToRepelSlider(power) {const safe = Math.max(1,Number(power)); const x = safe / (REPEL_BASE_POWER * REPEL_CENTER_MULTIPLIER); const s = 0.5 + (Math.log2(x) / REPEL_N_OCTAVES); return Math.round(Math.max(0,Math.min(1,s)) * REPEL_SLIDER_MAX);}let highRefreshMode = true; let cornerRadius = 0; const TEXT_SELECTOR = '#hero-text'; let textColliders = []; let motionBlurFade = 0.025; let trailSubtlety = 1.80; let renderFrameCount = 0; let physicsStepCount = 0; let lastFPSTime = 0; let currentRenderFPS = 0; let currentPhysicsFPS = 0; const renderFpsElement = document.getElementById('render-fps'); const physicsFpsElement = document.getElementById('physics-fps'); let adaptiveQualityEnabled = true; let currentCollisionIters = 2; let lastQualityCheck = 0; const QUALITY_CHECK_INTERVAL = 2.0; function updateAdaptiveQuality(now) {if (!adaptiveQualityEnabled) return; if (now - lastQualityCheck < QUALITY_CHECK_INTERVAL) return; lastQualityCheck = now; if (currentRenderFPS < 50) {currentCollisionIters = 1; console.log('âš¡ Adaptive Quality: LOW (1 collision iter) - FPS:',currentRenderFPS);}else if (currentRenderFPS < 70) {currentCollisionIters = 2; console.log('âš¡ Adaptive Quality: MEDIUM (2 collision iters) - FPS:',currentRenderFPS);}else {currentCollisionIters = 3; console.log('âš¡ Adaptive Quality: HIGH (3 collision iters) - FPS:',currentRenderFPS);}}class Ball {constructor(x,y,r,color) {this.x = x; this.y = y; this.vx = (Math.random()*2 - 1) * 200; this.vy = -Math.random()*200; this.r = r; this.rBase = r; this.m = ballMassKg; this.color = color; this.t = 0; this.age = 0; this.driftAx = 0; this.driftTime = 0; this.omega = 0; this.squash = 1.0; this.squashDirX = 1; this.squashDirY = 0; this.theta = 0; this.squashAmount = 0.0; this.squashNormalAngle = 0.0; this.alpha = 1.0;}step(dt) {this.t += dt; this.age += dt; if (currentMode !== MODES.WEIGHTLESS) {this.vy += (G * gravityScale) * dt;}const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); const dragAmount = (currentMode === MODES.WEIGHTLESS) ? 0.0001 : FRICTION; const drag = Math.max(0,1 - (dragAmount / massScale)); this.vx *= drag; this.vy *= drag; if (this.driftAx !== 0 && this.age < this.driftTime) {this.vx += (this.driftAx * dt) / massScale;}else if (this.driftAx !== 0) {this.driftAx = 0;}applyExternalForces(this,dt); this.x += this.vx * dt; this.y += this.vy * dt; const spinDamp = Math.max(0,1 - CONSTANTS.SPIN_DAMP_PER_S * dt); this.omega *= spinDamp; this.theta += this.omega * dt; if (this.theta > Math.PI) this.theta -= Math.PI * 2; else if (this.theta < -Math.PI) this.theta += Math.PI * 2; const decay = Math.min(1,CONSTANTS.SQUASH_DECAY_PER_S * dt); this.squashAmount += (0 - this.squashAmount) * decay; this.squash = 1 - this.squashAmount;}walls(w,h,dt,customRest = REST) {const rest = customRest; if (cornerRadius === 0) {if (this.y + this.r > h) {this.y = h - this.r; const preVy = this.vy; const slip = this.vx - this.omega * this.r; const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); this.omega += (slip / this.r) * CONSTANTS.SPIN_GAIN / massScale; const rollDamp = Math.max(0,1 - CONSTANTS.ROLL_FRICTION_PER_S * dt / massScale); this.vx *= rollDamp; const wallRest = Math.abs(preVy) < CONSTANTS.WALL_REST_VEL_THRESHOLD ? 0 : rest; this.vy = -this.vy * (wallRest * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP)); const impact = Math.min(1,Math.abs(preVy) / (this.r * 90)); this.squashAmount = Math.min(getSquashMax(),impact * 0.8); this.squash = 1 - this.squashAmount; this.squashNormalAngle = -Math.PI / 2; const rollTarget = this.vx / this.r; this.omega += (rollTarget - this.omega) * Math.min(1,CONSTANTS.GROUND_COUPLING_PER_S * dt);}const viewportTop = (currentMode === MODES.PIT) ? (h / 3) : 0; if (this.y - this.r < viewportTop) {this.y = viewportTop + this.r; const preVy = this.vy; this.vy = -this.vy * rest; const impact = Math.min(1,Math.abs(preVy) / (this.r * 90)); this.squashAmount = Math.min(getSquashMax(),impact * 0.8); this.squash = 1 - this.squashAmount; this.squashNormalAngle = Math.PI / 2;}if (this.x + this.r > w) {this.x = w - this.r; {const slip = this.vy - this.omega * this.r; const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;}this.vx = -this.vx * rest; const impact = Math.min(1,Math.abs(this.vx) / (this.r * 90)); this.squashAmount = Math.min(getSquashMax(),impact * 0.8); this.squash = 1 - this.squashAmount; this.squashNormalAngle = Math.PI;}if (this.x - this.r < 0) {this.x = this.r; {const slip = this.vy - this.omega * this.r; const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;}this.vx = -this.vx * rest; const impact = Math.min(1,Math.abs(this.vx) / (this.r * 90)); this.squashAmount = Math.min(getSquashMax(),impact * 0.8); this.squash = 1 - this.squashAmount; this.squashNormalAngle = 0;}}else {this.handleRoundedWallCollision(w,h);}this.checkTextCollisions(dt);}checkTextCollisions(dt) {for (let i = 0; i < textColliders.length; i++) {const rect = textColliders[i]; const closestX = Math.max(rect.x,Math.min(this.x,rect.x + rect.width)); const closestY = Math.max(rect.y,Math.min(this.y,rect.y + rect.height)); const dx = this.x - closestX; const dy = this.y - closestY; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < this.r) {if (distance === 0) {const distToLeft = this.x - rect.x; const distToRight = (rect.x + rect.width) - this.x; const distToTop = this.y - rect.y; const distToBottom = (rect.y + rect.height) - this.y; const minDist = Math.min(distToLeft,distToRight,distToTop,distToBottom); if (minDist === distToLeft) {this.x = rect.x - this.r; this.vx = -Math.abs(this.vx) * REST;}else if (minDist === distToRight) {this.x = rect.x + rect.width + this.r; this.vx = Math.abs(this.vx) * REST;}else if (minDist === distToTop) {this.y = rect.y - this.r; this.vy = -Math.abs(this.vy) * REST;}else {this.y = rect.y + rect.height + this.r; this.vy = Math.abs(this.vy) * REST;}}else {const overlap = this.r - distance; const nx = dx / distance; const ny = dy / distance; this.x += nx * overlap; this.y += ny * overlap; const dotProduct = this.vx * nx + this.vy * ny; if (dotProduct < 0) {this.vx -= 2 * dotProduct * nx * REST; this.vy -= 2 * dotProduct * ny * REST; const impact = Math.min(1,Math.abs(dotProduct) / (this.r * 70)); this.squash = 1 - getSquashMax() * impact; this.squashDirX = Math.abs(nx) > Math.abs(ny) ? 1 : 0; this.squashDirY = Math.abs(ny) > Math.abs(nx) ? 1 : 0;}}}}}handleRoundedWallCollision(w,h) {const r = cornerRadius; const corners = [ {x: r,y: r },{x: w - r,y: r },{x: w - r,y: h - r },{x: r,y: h - r }]; for (let i = 0; i < corners.length; i++) {const corner = corners[i]; const dx = this.x - corner.x; const dy = this.y - corner.y; const dist = Math.sqrt(dx * dx + dy * dy); const inCornerRegion = this.isInCornerRegion(corner,w,h,r); if (inCornerRegion && dist + this.r > r) {const overlap = r - (dist - this.r); if (overlap > 0 && dist > 0) {const nx = dx / dist; const ny = dy / dist; this.x += nx * overlap; this.y += ny * overlap; const dot = this.vx * nx + this.vy * ny; this.vx -= 2 * dot * nx * REST; this.vy -= 2 * dot * ny * REST; const impact = Math.min(1,Math.abs(dot) / (this.r * 90)); this.squashAmount = Math.min(getSquashMax(),impact * 0.8); this.squash = 1 - this.squashAmount; this.squashNormalAngle = Math.atan2(ny,nx);}}}if (this.y + this.r > h && (this.x < r || this.x > w - r)) {this.y = h - this.r; this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP));}if (this.y - this.r < 0 && (this.x < r || this.x > w - r)) {this.y = this.r; this.vy = -this.vy * REST;}if (this.x + this.r > w && (this.y < r || this.y > h - r)) {this.x = w - this.r; {const slip = this.vy - this.omega * this.r; const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;}this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP)); const impact = Math.min(1,Math.abs(this.vx)/(this.r*70)); this.squashAmount = Math.min(getSquashMax(),impact); this.squash = 1 - this.squashAmount; this.squashNormalAngle = Math.PI;}if (this.x - this.r < 0 && (this.y < r || this.y > h - r)) {this.x = this.r; {const slip = this.vy - this.omega * this.r; const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;}this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP)); const impact = Math.min(1,Math.abs(this.vx)/(this.r*70)); this.squashAmount = Math.min(getSquashMax(),impact); this.squash = 1 - this.squashAmount; this.squashNormalAngle = 0;}if (this.y + this.r > h && this.x >= r && this.x <= w - r) {this.y = h - this.r; this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP));}if (this.y - this.r < 0 && this.x >= r && this.x <= w - r) {this.y = this.r; this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP));}if (this.x + this.r > w && this.y >= r && this.y <= h - r) {this.x = w - this.r; this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP));}if (this.x - this.r < 0 && this.y >= r && this.y <= h - r) {this.x = this.r; this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP));}}isInCornerRegion(corner,w,h,r) {if (corner.x === r && corner.y === r) {return this.x <= r && this.y <= r;}if (corner.x === w - r && corner.y === r) {return this.x >= w - r && this.y <= r;}if (corner.x === w - r && corner.y === h - r) {return this.x >= w - r && this.y >= h - r;}if (corner.x === r && corner.y === h - r) {return this.x <= r && this.y >= h - r;}return false;}draw(ctx) {ctx.save(); ctx.translate(this.x,this.y); const amt = Math.min(getSquashMax(),Math.max(0,this.squashAmount)); if (this.r > 15 && amt > 0.001) {const s = 1 + amt; const inv = 1 / s; ctx.rotate(this.squashNormalAngle); ctx.scale(s,inv); ctx.rotate(-this.squashNormalAngle);}if (glassMorphismEnabled && (!enableShadowCulling || this.r >= minShadowRadius)) {const isSmallBall = this.r < 12; const qualityMultiplier = isSmallBall ? 0.5 : 1.0; const shadow1Radius = this.r * shadow1SizeMultiplier; const shadow1Steps = Math.max(2,Math.floor(shadow1BlurRadius * qualityMultiplier)); for (let i = 0; i < shadow1Steps; i++) {const t = i / Math.max(1,shadow1Steps - 1); ctx.save(); ctx.globalAlpha = shadow1Opacity * (1 - t) * 0.3; ctx.fillStyle = shadow1Color; ctx.beginPath(); ctx.arc(shadow1OffsetX,shadow1OffsetY,shadow1Radius + i * 0.5,0,Math.PI*2); ctx.fill(); ctx.restore();}const shadow2Radius = this.r * shadow2SizeMultiplier; const shadow2Steps = Math.max(1,Math.floor(shadow2BlurRadius * qualityMultiplier)); for (let i = 0; i < shadow2Steps; i++) {const t = i / Math.max(1,shadow2Steps - 1); ctx.save(); ctx.globalAlpha = shadow2Opacity * (1 - t) * 0.4; ctx.fillStyle = shadow2Color; ctx.beginPath(); ctx.arc(shadow2OffsetX,shadow2OffsetY,shadow2Radius + i * 0.3,0,Math.PI*2); ctx.fill(); ctx.restore();}const shadow3Radius = this.r * shadow3SizeMultiplier; const shadow3Steps = Math.max(1,Math.floor(shadow3BlurRadius * qualityMultiplier)); for (let i = 0; i < shadow3Steps; i++) {const t = i / Math.max(1,shadow3Steps - 1); ctx.save(); ctx.globalAlpha = shadow3Opacity * (1 - t) * 0.6; ctx.fillStyle = shadow3Color; ctx.beginPath(); ctx.arc(shadow3OffsetX,shadow3OffsetY,shadow3Radius + i * 0.1,0,Math.PI*2); ctx.fill(); ctx.restore();}}ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fillStyle = this.color; ctx.fill(); ctx.restore();}}const balls = []; function clamp(v,lo,hi) {return Math.max(lo,Math.min(hi,v));}function randBetween(a,b) {return a + Math.random() * (b - a);}function drawRoundedBoundary(ctx,w,h) {const r = cornerRadius; ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(r,0); ctx.lineTo(w - r,0); ctx.arcTo(w,0,w,r,r); ctx.lineTo(w,h - r); ctx.arcTo(w,h,w - r,h,r); ctx.lineTo(r,h); ctx.arcTo(0,h,0,h - r,r); ctx.lineTo(0,r); ctx.arcTo(0,0,r,0,r); ctx.closePath(); ctx.stroke();}function spawnBall(x,y,color = pickRandomColor()) {const baseSize = (R_MIN + R_MAX) / 2; let r; if (sizeVariation === 0) {r = baseSize;}else {const maxVariation = baseSize * 0.1; const minR = Math.max(1,baseSize - maxVariation); const maxR = baseSize + maxVariation; r = randBetween(minR,maxR);}const ball = new Ball(x,y,r,color); const centerX = canvas.width * 0.5; const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((x < centerX) ? 1 : -1); const sizeInfluence = clamp((r / ((R_MIN + R_MAX) * 0.5)),0.6,1.4); const baseKick = 140 * sizeInfluence; const randKick = 180 * sizeInfluence; const upwardKick = 120; ball.vx = dir * (baseKick + Math.random() * randKick); ball.vy = -Math.random() * upwardKick; ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence; ball.driftTime = 0.22 + Math.random() * 0.28; balls.push(ball); return ball;}let emitterTimer = 0; function pickSpawnPoint() {const wCss = canvas.clientWidth; const hCss = canvas.clientHeight; const widthCss = clamp((SPAWN_W_VW / 100) * wCss,0,wCss); let xCenterCss = clamp((SPAWN_X_CENTER_VW / 100) * wCss,0,wCss); if (EMITTER_SWEEP_ENABLED) {const amplPx = (EMITTER_SWEEP_AMPL_VW / 100) * wCss; const sweepOffset = Math.sin(emitterPhase) * amplPx; const prevX = xCenterCss; xCenterCss = clamp(xCenterCss + sweepOffset,0,wCss); emitterSweepDir = (xCenterCss >= prevX) ? 1 : -1;}const offX = Math.min(40,widthCss * 0.1); const xLeftCss = clamp(xCenterCss - widthCss / 2 - offX,-offX,wCss); const xRightCss = clamp(xCenterCss + widthCss / 2 + offX,-offX,wCss); const yTopCss = (SPAWN_Y_VH / 100) * hCss; const yBotCss = yTopCss + (SPAWN_H_VH / 100) * hCss; const bias = 0.3; const u = Math.random(); const biased = bias > 0 ? (emitterSweepDir > 0 ? Math.pow(u,1 - bias) : 1 - Math.pow(1 - u,1 - bias)) : u; const x = (xLeftCss + (xRightCss - xLeftCss) * biased) * DPR; const y = randBetween(yTopCss * DPR,yBotCss * DPR) - (R_MAX + CONSTANTS.BALL_SPAWN_OFFSET + randBetween(0,10 * DPR)); return {x,y };}function emit(dt) {if (currentMode === MODES.WEIGHTLESS) {return;}emitterTimer += dt; while (emitterTimer >= EMIT_INTERVAL) {const jitter = (Math.random() - 0.5) * EMIT_INTERVAL * 0.5; emitterTimer -= (EMIT_INTERVAL + jitter); emitterPhase += (2 * Math.PI) * EMITTER_SWEEP_HZ * (EMIT_INTERVAL + jitter); const p = pickSpawnPoint(); const drops = (Math.random() < 0.35 ? 3 : 1); for (let i=0; i<drops; i++) {if (balls.length < MAX_BALLS) {const xOffset = i * CONSTANTS.BALL_CLUSTER_SPACING * (Math.random() < 0.5 ? 1 : -1); spawnBall(p.x + xOffset,p.y - i * CONSTANTS.BALL_CLUSTER_Y_OFFSET);}}}}const spatialGrid = new Map(); function collectPairsSorted() {const n = balls.length; if (n < 2) return []; const cellSize = Math.max(1,R_MAX * 2); const gridWidth = Math.ceil(canvas.width / cellSize) + 1; spatialGrid.clear(); for (let i = 0; i < n; i++) {const b = balls[i]; const cx = (b.x / cellSize) | 0; const cy = (b.y / cellSize) | 0; const key = cy * gridWidth + cx; let arr = spatialGrid.get(key); if (!arr) {arr = []; spatialGrid.set(key,arr);}arr.push(i);}const pairs = []; for (const [key,arr] of spatialGrid) {const cy = (key / gridWidth) | 0; const cx = key % gridWidth; for (let oy = -1; oy <= 1; oy++) {for (let ox = -1; ox <= 1; ox++) {const neighborKey = (cy + oy) * gridWidth + (cx + ox); const nb = spatialGrid.get(neighborKey); if (!nb) continue; for (let ii = 0; ii < arr.length; ii++) {const i = arr[ii]; for (let jj = 0; jj < nb.length; jj++) {const j = nb[jj]; if (j <= i) continue; const A = balls[i],B = balls[j]; const dx = B.x - A.x,dy = B.y - A.y; const rSum = A.r + B.r; const dist2 = dx*dx + dy*dy; if (dist2 < rSum*rSum) {const dist = Math.sqrt(Math.max(dist2,CONSTANTS.MIN_DISTANCE_EPSILON)); const overlap = rSum - dist; pairs.push({i,j,overlap });}}}}}}pairs.sort((a,b) => b.overlap - a.overlap); return pairs;}function resolveCollisions(iterations = SOLVER_ITERS) {const pairs = collectPairsSorted(); for (let iter = 0; iter < iterations; iter++) {for (let k = 0; k < pairs.length; k++) {const {i,j }= pairs[k]; const A = balls[i]; const B = balls[j]; const dx = B.x - A.x; const dy = B.y - A.y; const rSum = A.r + B.r; const dist2 = dx * dx + dy * dy; if (dist2 === 0 || dist2 > rSum * rSum) continue; const dist = Math.sqrt(dist2); const nx = dx / dist; const ny = dy / dist; const overlap = rSum - dist; const invA = 1 / Math.max(A.m,0.001); const invB = 1 / Math.max(B.m,0.001); const correctionMag = POS_CORRECT_PERCENT * Math.max(overlap - POS_CORRECT_SLOP,0) / (invA + invB); const cx = correctionMag * nx; const cy = correctionMag * ny; A.x -= cx * invA; A.y -= cy * invA; B.x += cx * invB; B.y += cy * invB; const rvx = B.vx - A.vx; const rvy = B.vy - A.vy; const velAlongNormal = rvx * nx + rvy * ny; if (velAlongNormal < 0) {const e = Math.abs(velAlongNormal) < REST_VEL_THRESHOLD ? 0 : REST; const j = -(1 + e) * velAlongNormal / (invA + invB); const ix = j * nx; const iy = j * ny; A.vx -= ix * invA; A.vy -= iy * invA; B.vx += ix * invB; B.vy += iy * invB; const tvx = rvx - velAlongNormal * nx; const tvy = rvy - velAlongNormal * ny; const slipMag = Math.hypot(tvx,tvy); if (slipMag > 1e-3) {const tangentSign = (tvx * -ny + tvy * nx) >= 0 ? 1 : -1; const gain = CONSTANTS.SPIN_GAIN_TANGENT; A.omega -= tangentSign * gain * slipMag / Math.max(A.r,1); B.omega += tangentSign * gain * slipMag / Math.max(B.r,1);}const impact = Math.min(1,Math.abs(velAlongNormal) / ((A.r + B.r) * 50)); const sAmt = Math.min(getSquashMax(),impact * 0.8); A.squashAmount = Math.max(A.squashAmount,sAmt * 0.8); A.squashNormalAngle = Math.atan2(-ny,-nx); B.squashAmount = Math.max(B.squashAmount,sAmt * 0.8); B.squashNormalAngle = Math.atan2(ny,nx);}}}}let last = performance.now() / 1000; let acc = 0; const DT = 1/120; function frame(nowMs) {const now = nowMs / 1000; let dt = Math.min(0.008,now - last); last = now; acc += dt; renderFrameCount++; if ((renderFpsElement || physicsFpsElement) && now - lastFPSTime >= CONSTANTS.FPS_UPDATE_INTERVAL) {if (renderFpsElement && renderFrameCount !== currentRenderFPS) {currentRenderFPS = renderFrameCount; renderFpsElement.textContent = currentRenderFPS.toString();}if (physicsFpsElement && physicsStepCount !== currentPhysicsFPS) {currentPhysicsFPS = physicsStepCount; physicsFpsElement.textContent = currentPhysicsFPS.toString();}renderFrameCount = 0; physicsStepCount = 0; lastFPSTime = now; updateAdaptiveQuality(now);}emit(dt); if (renderFrameCount % 60 === 0) {updateTextColliders();}let physicsSteps = 0; while (acc >= DT && physicsSteps < CONSTANTS.MAX_PHYSICS_STEPS) {for (let i=0; i<balls.length; i++) balls[i].step(DT); if (currentMode !== MODES.FLIES) {resolveCollisions(currentCollisionIters);}const wallRestitution = (currentMode === MODES.WEIGHTLESS) ? weightlessBounce : REST; for (let i=0; i<balls.length; i++) balls[i].walls(canvas.width,canvas.height,DT,wallRestitution); acc -= DT; physicsSteps++; physicsStepCount++;}if (acc > DT * CONSTANTS.ACCUMULATOR_RESET_THRESHOLD) acc = 0; if (useWebGL && pixiApp) {updateAdaptiveQuality(); cleanupRemovedBalls(); renderRoundedBoundaryWebGL(); const margin = 100; for (let i=0; i<balls.length; i++) {const ball = balls[i]; if (ball.x + ball.r < -margin || ball.x - ball.r > canvas.width + margin || ball.y + ball.r < -margin || ball.y - ball.r > canvas.height + margin) {const sprite = ballSprites.get(ball); if (sprite) sprite.visible = false; continue;}renderBallWebGL(ball); const sprite = ballSprites.get(ball); if (sprite) sprite.visible = true;}renderCursorBallWebGL(); renderModeIndicatorWebGL();}else {ctx.clearRect(0,0,canvas.width,canvas.height); if (cornerRadius > 0) {drawRoundedBoundary(ctx,canvas.width,canvas.height);}for (let i=0; i<balls.length; i++) balls[i].draw(ctx); drawCursorBall(ctx);}if (!isTouchDevice) {ctx.save(); ctx.font = '14px system-ui,-apple-system,sans-serif'; ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; const modeName = currentMode.charAt(0).toUpperCase() + currentMode.slice(1); ctx.fillText(modeName + ' Mode',10,canvas.height - 10); ctx.restore();}requestAnimationFrame(frame);}console.log('High refresh mode enabled - using requestAnimationFrame'); requestAnimationFrame(frame); function resetBallSizeToGlobal() {const globalScale = parseFloat(sizeSliderGlobal.value); sizeScale = globalScale; updateEffectiveScaleAndBallSizes(); const baseSize = (R_MIN + R_MAX) / 2; for (let i = 0; i < balls.length; i++) {if (sizeVariation === 0) {balls[i].r = baseSize; balls[i].rBase = baseSize;}else {const maxVariation = baseSize * 0.1; const minR = Math.max(1,baseSize - maxVariation); const maxR = baseSize + maxVariation; balls[i].r = randBetween(minR,maxR); balls[i].rBase = balls[i].r;}}}function resetBallsToSpawn() {if (currentMode === MODES.WEIGHTLESS) {initializeWeightlessScene();}else {for (let i = 0; i < balls.length; i++) {const ball = balls[i]; const p = pickSpawnPoint(); ball.x = p.x; ball.y = p.y; const centerX = canvas.width * 0.5; const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((ball.x < centerX) ? 1 : -1); const sizeInfluence = clamp((ball.r / ((R_MIN + R_MAX) * 0.5)),0.6,1.4); const baseKick = 140 * sizeInfluence; const randKick = 180 * sizeInfluence; const upwardKick = 120; ball.vx = dir * (baseKick + Math.random() * randKick); ball.vy = -Math.random() * upwardKick; ball.age = 0; ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence; ball.driftTime = 0.22 + Math.random() * 0.28;}}}const panelHeader = document.getElementById('panelHeader'); const minimizeBtn = document.getElementById('minimizePanel'); const PANEL_INITIALLY_VISIBLE = true; if (!PANEL_INITIALLY_VISIBLE && panel) {panel.classList.add('hidden');}if (minimizeBtn && panel) {minimizeBtn.addEventListener('click',(e) => {e.stopPropagation(); panel.classList.toggle('hidden');});}if (panelHeader && panel) {let isDragging = false; let currentX; let currentY; let initialX; let initialY; let xOffset = 0; let yOffset = 0; panelHeader.addEventListener('mousedown',dragStart); document.addEventListener('mousemove',drag); document.addEventListener('mouseup',dragEnd); panelHeader.addEventListener('touchstart',dragStart); document.addEventListener('touchmove',drag); document.addEventListener('touchend',dragEnd); function dragStart(e) {if (e.type === 'touchstart') {initialX = e.touches[0].clientX - xOffset; initialY = e.touches[0].clientY - yOffset;}else {initialX = e.clientX - xOffset; initialY = e.clientY - yOffset;}if (e.target === panelHeader || panelHeader.contains(e.target)) {isDragging = true; panel.style.cursor = 'grabbing';}}function drag(e) {if (isDragging) {e.preventDefault(); if (e.type === 'touchmove') {currentX = e.touches[0].clientX - initialX; currentY = e.touches[0].clientY - initialY;}else {currentX = e.clientX - initialX; currentY = e.clientY - initialY;}xOffset = currentX; yOffset = currentY; const rect = panel.getBoundingClientRect(); const computedStyle = window.getComputedStyle(panel); const initialTop = parseFloat(computedStyle.top) || 0; const initialRight = parseFloat(computedStyle.right) || 0; panel.style.top = `${initialTop + yOffset}px`; panel.style.right = `${initialRight - xOffset}px`; panel.style.left = 'auto'; panel.style.bottom = 'auto'; xOffset = 0; yOffset = 0; initialX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX; initialY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;}}function dragEnd(e) {if (isDragging) {isDragging = false; panel.style.cursor = 'move'; initialX = currentX; initialY = currentY;}}}window.addEventListener('keydown',e => {const k = e.key.toLowerCase(); if (k === 'r') {resetBallsToSpawn(); e.preventDefault();}if (k === '/' && panel) {e.preventDefault(); panel.classList.toggle('hidden');}if (k === '1') setMode(MODES.PIT); if (k === '2') setMode(MODES.FLIES); if (k === '3') setMode(MODES.WEIGHTLESS);}); function seedArea(n = 160) {for (let i=0; i<n && balls.length < MAX_BALLS; i++) {const p = pickSpawnPoint(); spawnBall(p.x,p.y);}}seedArea(CONSTANTS.INITIAL_SEED_BALLS); let lastTrailRecordTime = 0; let lastMousePosition = {x: 0,y: 0 }; let mouseStoppedTime = 0; canvas.addEventListener('mousemove',(e) => {const rect = canvas.getBoundingClientRect(); mouseX = (e.clientX - rect.left) * DPR; mouseY = (e.clientY - rect.top) * DPR; if (currentMode === MODES.PIT && repelPower > 0 && repelRadius > 0) {repellerEnabled = true;}}); canvas.addEventListener('mouseleave',() => {mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE;}); function drawCursorBall(ctx) {if (isTouchDevice) return; if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return; const x = mouseX,y = mouseY; const baseSize = (R_MIN + R_MAX) / 2; const r = baseSize; if (glassMorphismEnabled) {const shadow1Radius = r * shadow1SizeMultiplier; for (let i = 0; i < shadow1BlurRadius; i++) {ctx.save(); ctx.globalAlpha = shadow1Opacity * (1 - i / shadow1BlurRadius) * 0.3; ctx.fillStyle = shadow1Color; ctx.beginPath(); ctx.arc(x + shadow1OffsetX,y + shadow1OffsetY,shadow1Radius + i * 0.5,0,Math.PI * 2); ctx.fill(); ctx.restore();}const shadow2Radius = r * shadow2SizeMultiplier; for (let i = 0; i < shadow2BlurRadius; i++) {ctx.save(); ctx.globalAlpha = shadow2Opacity * (1 - i / shadow2BlurRadius) * 0.4; ctx.fillStyle = shadow2Color; ctx.beginPath(); ctx.arc(x + shadow2OffsetX,y + shadow2OffsetY,shadow2Radius + i * 0.3,0,Math.PI * 2); ctx.fill(); ctx.restore();}const shadow3Radius = r * shadow3SizeMultiplier; for (let i = 0; i < shadow3BlurRadius; i++) {ctx.save(); ctx.globalAlpha = shadow3Opacity * (1 - i / shadow3BlurRadius) * 0.6; ctx.fillStyle = shadow3Color; ctx.beginPath(); ctx.arc(x + shadow3OffsetX,y + shadow3OffsetY,shadow3Radius + i * 0.1,0,Math.PI * 2); ctx.fill(); ctx.restore();}}const color = 'rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI * 2); ctx.fillStyle = color; ctx.fill(); ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 2; ctx.stroke();}function applyRepeller(b,dt) {if (!repellerEnabled) return; if (repelPower <= 0 || repelRadius <= 0) return; const rPx = repelRadius * DPR; const dx = b.x - mouseX; const dy = b.y - mouseY; const d2 = dx*dx + dy*dy; const r2 = rPx * rPx; if (d2 > r2) return; const d = Math.max(Math.sqrt(d2),CONSTANTS.MIN_REPEL_DISTANCE); const nx = dx / d; const ny = dy / d; const q = Math.max(0,1 - d / rPx); const strength = (repelPower * REPELLER_GLOBAL_MULTIPLIER) * Math.pow(q,repelSoft); const massScale = Math.max(0.25,b.m / MASS_BASELINE_KG); b.vx += (nx * strength * dt) / massScale; b.vy += (ny * strength * dt) / massScale; const turbulence = 10; b.vx += (Math.random() - 0.5) * turbulence * dt; b.vy += (Math.random() - 0.5) * turbulence * dt;}function applyExternalForces(b,dt) {if (currentMode === MODES.PIT) {applyRepeller(b,dt); return;}if (currentMode === MODES.FLIES) {applyAttractor(b,dt); return;}if (currentMode === MODES.WEIGHTLESS) {applyWeightlessRepeller(b,dt); return;}}function applyWeightlessRepeller(b,dt) {if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return; if (weightlessRepellerPower <= 0 || weightlessRepellerRadius <= 0) return; const rPx = weightlessRepellerRadius * DPR; const dx = b.x - mouseX; const dy = b.y - mouseY; const d2 = dx*dx + dy*dy; const r2 = rPx * rPx; if (d2 > r2) return; const d = Math.max(Math.sqrt(d2),CONSTANTS.MIN_REPEL_DISTANCE); const nx = dx / d; const ny = dy / d; const q = Math.max(0,1 - d / rPx); const strength = weightlessRepellerPower * q; b.vx += nx * strength * dt; b.vy += ny * strength * dt;}function applyAttractor(b,dt) {const swarmCenterX = (mouseX === CONSTANTS.OFFSCREEN_MOUSE) ? canvas.width * 0.5 : mouseX; const swarmCenterY = (mouseY === CONSTANTS.OFFSCREEN_MOUSE) ? canvas.height * 0.5 : mouseY; const dx = swarmCenterX - b.x; const dy = swarmCenterY - b.y; const d2 = dx*dx + dy*dy; const d = Math.sqrt(d2 + 1); const dirX = dx / d; const dirY = dy / d; const attractForce = attractionPower * swarmSpeed * 2.0; b.vx += dirX * attractForce * dt; b.vy += dirY * attractForce * dt; const separationRadius = 120 * DPR; let sepX = 0,sepY = 0; let neighborCount = 0; for (let i = 0; i < balls.length; i++) {const other = balls[i]; if (other === b) continue; const dx2 = b.x - other.x; const dy2 = b.y - other.y; const d2_other = dx2*dx2 + dy2*dy2; if (d2_other < separationRadius * separationRadius && d2_other > 0) {const d_other = Math.sqrt(d2_other); const strength = 1 - (d_other / separationRadius); sepX += (dx2 / d_other) * strength; sepY += (dy2 / d_other) * strength; neighborCount++;}}if (neighborCount > 0) {const separationForce = 15000; b.vx += (sepX / neighborCount) * separationForce * dt; b.vy += (sepY / neighborCount) * separationForce * dt;}const jitterBase = 2500 * swarmSpeed; const burstChance = 0.08; if (Math.random() < burstChance) {const burstAngle = Math.random() * Math.PI * 2; const burstStrength = 1500 * swarmSpeed; b.vx += Math.cos(burstAngle) * burstStrength; b.vy += Math.sin(burstAngle) * burstStrength;}b.vx += (Math.random() - 0.5) * jitterBase * dt; b.vy += (Math.random() - 0.5) * jitterBase * dt; const orbitVariation = 0.3 + Math.random() * 2.0; const orbitStrength = swarmSpeed * 2000 * orbitVariation * dt; b.vx += -dirY * orbitStrength; b.vy += dirX * orbitStrength; const maxSpeed = 2200 * swarmSpeed; const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy); if (speed > maxSpeed) {b.vx = (b.vx / speed) * maxSpeed; b.vy = (b.vy / speed) * maxSpeed;}b.vx *= 0.995; b.vy *= 0.995;}const restitutionSlider = document.getElementById('restitutionSlider'); const frictionSlider = document.getElementById('frictionSlider'); const emitterSlider = document.getElementById('emitterSlider'); const sizeSliderGlobal = document.getElementById('sizeSliderGlobal'); const sizeVariationSliderGlobal = document.getElementById('sizeVariationSliderGlobal'); const weightSliderGlobal = document.getElementById('weightSliderGlobal'); const ballSoftnessSliderGlobal = document.getElementById('ballSoftnessSliderGlobal'); const sizeValGlobal = document.getElementById('sizeValGlobal'); const sizeVariationValGlobal = document.getElementById('sizeVariationValGlobal'); const weightValGlobal = document.getElementById('weightValGlobal'); const ballSoftnessValGlobal = document.getElementById('ballSoftnessValGlobal'); const sizeSliderPit = document.getElementById('sizeSliderPit'); const sizeVariationSliderPit = document.getElementById('sizeVariationSliderPit'); const weightSliderPit = document.getElementById('weightSliderPit'); const ballSoftnessSliderPit = document.getElementById('ballSoftnessSliderPit'); const sizeValPit = document.getElementById('sizeValPit'); const sizeVariationValPit = document.getElementById('sizeVariationValPit'); const weightValPit = document.getElementById('weightValPit'); const ballSoftnessValPit = document.getElementById('ballSoftnessValPit'); const sizeSliderFlies = document.getElementById('sizeSliderFlies'); const sizeVariationSliderFlies = document.getElementById('sizeVariationSliderFlies'); const weightSliderFlies = document.getElementById('weightSliderFlies'); const ballSoftnessSliderFlies = document.getElementById('ballSoftnessSliderFlies'); const sizeValFlies = document.getElementById('sizeValFlies'); const sizeVariationValFlies = document.getElementById('sizeVariationValFlies'); const weightValFlies = document.getElementById('weightValFlies'); const ballSoftnessValFlies = document.getElementById('ballSoftnessValFlies'); const sizeSliderZeroG = document.getElementById('sizeSliderZeroG'); const sizeVariationSliderZeroG = document.getElementById('sizeVariationSliderZeroG'); const weightSliderZeroG = document.getElementById('weightSliderZeroG'); const ballSoftnessSliderZeroG = document.getElementById('ballSoftnessSliderZeroG'); const sizeValZeroG = document.getElementById('sizeValZeroG'); const sizeVariationValZeroG = document.getElementById('sizeVariationValZeroG'); const weightValZeroG = document.getElementById('weightValZeroG'); const ballSoftnessValZeroG = document.getElementById('ballSoftnessValZeroG'); const maxBallsSlider = document.getElementById('maxBallsSlider'); const spawnYSlider = document.getElementById('spawnYSlider'); const spawnWidthSlider = document.getElementById('spawnWidthSlider'); const spawnCenterSlider = document.getElementById('spawnCenterSlider'); const spawnHeightSlider = document.getElementById('spawnHeightSlider'); const repelSizeSlider = document.getElementById('repelSizeSlider'); const repelPowerSlider = document.getElementById('repelPowerSlider'); const repelSoftSlider = document.getElementById('repelSoftSlider'); const colorSelect = document.getElementById('colorSelect'); const color1 = document.getElementById('color1'); const color2 = document.getElementById('color2'); const color3 = document.getElementById('color3'); const color4 = document.getElementById('color4'); const color5 = document.getElementById('color5'); const color6 = document.getElementById('color6'); const color7 = document.getElementById('color7'); const color8 = document.getElementById('color8'); const cursorColorSelect = document.getElementById('cursorColorSelect'); const color1Val = document.getElementById('color1Val'); const color2Val = document.getElementById('color2Val'); const color3Val = document.getElementById('color3Val'); const color4Val = document.getElementById('color4Val'); const color5Val = document.getElementById('color5Val'); const color6Val = document.getElementById('color6Val'); const color7Val = document.getElementById('color7Val'); const color8Val = document.getElementById('color8Val'); [color1Val,color2Val,color3Val,color4Val,color5Val,color6Val,color7Val,color8Val].forEach(el => {if (el) el.setAttribute('title','Click to copy');}); const cornerRadiusSlider = document.getElementById('cornerRadiusSlider'); const cornerRadiusVal = document.getElementById('cornerRadiusVal'); const motionBlurFadeSlider = document.getElementById('trailFadeSlider'); const motionBlurFadeVal = document.getElementById('trailFadeVal'); const trailSubtletySlider = document.getElementById('trailSubtletySlider'); const trailSubtletyVal = document.getElementById('trailSubtletyVal'); const restitutionVal = document.getElementById('restitutionVal'); const frictionVal = document.getElementById('frictionVal'); const emitterVal = document.getElementById('emitterVal'); const maxBallsVal = document.getElementById('maxBallsVal'); const spawnYVal = document.getElementById('spawnYVal'); const spawnWidthVal = document.getElementById('spawnWidthVal'); const spawnCenterVal = document.getElementById('spawnCenterVal'); const spawnHeightVal = document.getElementById('spawnHeightVal'); const repelSizeVal = document.getElementById('repelSizeVal'); const repelPowerVal = document.getElementById('repelPowerVal'); const repelSoftVal = document.getElementById('repelSoftVal'); function captureCurrentConfig() {return {gravityMultiplier,restitution: REST,friction: FRICTION,ballMass: ballMassKg,emitRate: EMIT_INTERVAL,maxBalls: MAX_BALLS,ballScale: sizeScale,ballVariation: sizeVariation,spawnX: SPAWN_X_CENTER_VW,spawnY: SPAWN_Y_VH,spawnWidth: SPAWN_W_VW,spawnHeight: SPAWN_H_VH,sweepEnabled: EMITTER_SWEEP_ENABLED,repelRadius,repelPower,repelSoftness: repelSoft,trailFade: motionBlurFade,trailSubtlety,colors: currentColors.slice(),colorWeights: COLOR_WEIGHTS.slice(),currentTemplate,cursorColorIndex: cursorBallIndex,glassMorphismEnabled,currentIlluminationTemplate,shadow1OffsetX,shadow1OffsetY,shadow1Opacity,shadow1Color,shadow1SizeMultiplier,shadow1BlurRadius,shadow2OffsetX,shadow2OffsetY,shadow2Opacity,shadow2Color,shadow2SizeMultiplier,shadow2BlurRadius,shadow3OffsetX,shadow3OffsetY,shadow3Opacity,shadow3Color,shadow3SizeMultiplier,shadow3BlurRadius,enableLOD,enableShadowCulling,minShadowRadius,enableSpritePooling,maxPoolSize };}function generateConfigCode(config) {return ` }const saveConfigBtn = document.getElementById('saveConfigBtn'); const buildBtn = document.getElementById('buildBtn'); const configOutput = document.getElementById('configOutput'); if (saveConfigBtn && buildBtn && configOutput) {saveConfigBtn.addEventListener('click',() => {const config = captureCurrentConfig(); const code = generateConfigCode(config); configOutput.style.display = 'block'; configOutput.textContent = code; navigator.clipboard.writeText(code).then(() => {const old = saveConfigBtn.textContent; saveConfigBtn.textContent = 'âœ… Copied!'; setTimeout(() => {saveConfigBtn.textContent = old;},1200);}).catch(() => {console.warn('Clipboard copy failed'); const old = saveConfigBtn.textContent; saveConfigBtn.textContent = 'âš ï¸ Copy failed'; setTimeout(() => {saveConfigBtn.textContent = old;},1200);});}); buildBtn.addEventListener('click',() => {const config = captureCurrentConfig(); configOutput.style.display = 'block'; configOutput.innerHTML = ` <strong>ðŸš€ Build Instructions:</strong><br> 1. Run: <code>npm run build</code><br> 2. Your current config will be baked into <code>public/js/bouncy-balls-embed.js</code>`; const blob = new Blob([JSON.stringify(config,null,2)],{type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'current-config.json'; a.click(); URL.revokeObjectURL(url);});}function bindCopyOnClick(el,getText) {if (!el) return; el.addEventListener('click',async () => {const text = typeof getText === 'function' ? getText() : String(getText || '').trim(); try {await navigator.clipboard.writeText(text); const old = el.textContent; el.textContent = 'COPIED'; el.style.color = '#3ddc84'; setTimeout(() => {el.textContent = old; el.style.color = '#888';},900);}catch (e) {console.warn('Clipboard unavailable');}});}restitutionSlider && restitutionSlider.addEventListener('input',() => {REST = parseFloat(restitutionSlider.value); restitutionVal && (restitutionVal.textContent = REST.toFixed(2)); autoSaveSettings();}); frictionSlider && frictionSlider.addEventListener('input',() => {FRICTION = parseFloat(frictionSlider.value); frictionVal && (frictionVal.textContent = FRICTION.toFixed(4)); autoSaveSettings();}); emitterSlider && emitterSlider.addEventListener('input',() => {EMIT_INTERVAL = parseFloat(emitterSlider.value); emitterVal && (emitterVal.textContent = EMIT_INTERVAL.toFixed(3)); autoSaveSettings();}); function bindBallProps(sliders) {if (!sliders) return; const {size,sizeVal,sizeVar,sizeVarVal,soft,softVal }= sliders; size && size.addEventListener('input',() => {const newScale = parseFloat(size.value); sizeVal && (sizeVal.textContent = newScale.toFixed(1)); sizeScale = newScale; updateEffectiveScaleAndBallSizes(); for (let i=0; i<balls.length; i++) {balls[i].m = ballMassKg;}autoSaveSettings();}); sizeVar && sizeVar.addEventListener('input',() => {const v = parseFloat(sizeVar.value); sizeVarVal && (sizeVarVal.textContent = v.toFixed(1)); sizeVariation = v; autoSaveSettings();}); soft && soft.addEventListener('input',() => {const s = parseInt(soft.value,10); softVal && (softVal.textContent = String(s)); ballSoftness = s; autoSaveSettings();});}bindBallProps({size: sizeSliderGlobal,sizeVal: sizeValGlobal,sizeVar: sizeVariationSliderGlobal,sizeVarVal: sizeVariationValGlobal,soft: ballSoftnessSliderGlobal,softVal: ballSoftnessValGlobal }); maxBallsSlider && maxBallsSlider.addEventListener('input',() => {MAX_BALLS = parseInt(maxBallsSlider.value,10); maxBallsVal && (maxBallsVal.textContent = MAX_BALLS.toString()); if (balls.length > MAX_BALLS) {balls.length = MAX_BALLS;}}); sizeVariationSliderGlobal && sizeVariationSliderGlobal.addEventListener('input',() => {sizeVariation = parseFloat(sizeVariationSliderGlobal.value); sizeVariationValGlobal && (sizeVariationValGlobal.textContent = sizeVariation.toFixed(1)); updateExistingBallSizes();}); const weightPitSlider = document.getElementById('weightPitSlider'); const weightPitVal = document.getElementById('weightPitVal'); const weightWeightlessSlider = document.getElementById('weightWeightlessSlider'); const weightWeightlessVal = document.getElementById('weightWeightlessVal'); function updateExistingBallSizes() {const baseSize = (R_MIN + R_MAX) / 2; for (let i = 0; i < balls.length; i++) {const ball = balls[i]; if (sizeVariation === 0) {ball.r = baseSize;}else {const maxVariation = baseSize * 0.1; const minR = Math.max(1,baseSize - maxVariation); const maxR = baseSize + maxVariation; ball.r = randBetween(minR,maxR);}ball.m = ballMassKg;}}spawnYSlider && spawnYSlider.addEventListener('input',() => {SPAWN_Y_VH = parseFloat(spawnYSlider.value); spawnYVal && (spawnYVal.textContent = SPAWN_Y_VH.toFixed(0)); setCSSSize(); resize();}); spawnWidthSlider && spawnWidthSlider.addEventListener('input',() => {SPAWN_W_VW = parseFloat(spawnWidthSlider.value); spawnWidthVal && (spawnWidthVal.textContent = SPAWN_W_VW.toFixed(0));}); spawnCenterSlider && spawnCenterSlider.addEventListener('input',() => {SPAWN_X_CENTER_VW = parseFloat(spawnCenterSlider.value); spawnCenterVal && (spawnCenterVal.textContent = SPAWN_X_CENTER_VW.toFixed(0));}); spawnHeightSlider && spawnHeightSlider.addEventListener('input',() => {SPAWN_H_VH = parseFloat(spawnHeightSlider.value); spawnHeightVal && (spawnHeightVal.textContent = SPAWN_H_VH.toFixed(0));}); repelSizeSlider && repelSizeSlider.addEventListener('input',() => {repelRadius = parseFloat(repelSizeSlider.value); repelSizeVal && (repelSizeVal.textContent = repelRadius.toFixed(0)); repellerEnabled = repellerEnabled || (repelPower > 0 && repelRadius > 0);}); repelPowerSlider && repelPowerSlider.addEventListener('input',() => {repelPower = repelSliderToPower(repelPowerSlider.value); if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString(); if (repellerSelect && repellerSelect.value !== 'off') {repellerEnabled = repelPower > 0 && repelRadius > 0;}}); repelSoftSlider && repelSoftSlider.addEventListener('input',() => {repelSoft = parseFloat(repelSoftSlider.value); repelSoftVal && (repelSoftVal.textContent = repelSoft.toFixed(1));}); const useWebGLToggleEl = document.getElementById('useWebGLToggle'); const rendererStatus = document.getElementById('rendererStatus'); if (useWebGLToggleEl) {useWebGLToggleEl.addEventListener('change',() => {toggleRenderer(); if (rendererStatus) {if (useWebGL && pixiApp) {const type = pixiApp.renderer.type === PIXI.RENDERER_TYPE.WEBGL ? 'WebGL' : 'Canvas2D Fallback'; rendererStatus.textContent = `Status: ${type}Active âœ…`; rendererStatus.style.background = 'rgba(0,255,0,0.2)';}else {rendererStatus.textContent = 'Status: Canvas2D Active'; rendererStatus.style.background = 'rgba(0,0,0,0.2)';}}console.log('ðŸ”„ Renderer toggled:',useWebGL ? 'WebGL' : 'Canvas2D');});}const glassMorphismEnabledEl = document.getElementById('glassMorphismEnabled'); const illuminationSelectEl = document.getElementById('illuminationSelect'); const shadow1OffsetXEl = document.getElementById('shadow1OffsetX'); const shadow1OffsetXVal = document.getElementById('shadow1OffsetXVal'); const shadow1OffsetYEl = document.getElementById('shadow1OffsetY'); const shadow1OffsetYVal = document.getElementById('shadow1OffsetYVal'); const shadow1OpacityEl = document.getElementById('shadow1Opacity'); const shadow1OpacityVal = document.getElementById('shadow1OpacityVal'); const shadow1ColorEl = document.getElementById('shadow1Color'); const shadow1ColorVal = document.getElementById('shadow1ColorVal'); const shadow1SizeMultiplierEl = document.getElementById('shadow1SizeMultiplier'); const shadow1SizeMultiplierVal = document.getElementById('shadow1SizeMultiplierVal'); const shadow2OffsetXEl = document.getElementById('shadow2OffsetX'); const shadow2OffsetXVal = document.getElementById('shadow2OffsetXVal'); const shadow2OffsetYEl = document.getElementById('shadow2OffsetY'); const shadow2OffsetYVal = document.getElementById('shadow2OffsetYVal'); const shadow2OpacityEl = document.getElementById('shadow2Opacity'); const shadow2OpacityVal = document.getElementById('shadow2OpacityVal'); const shadow2ColorEl = document.getElementById('shadow2Color'); const shadow2ColorVal = document.getElementById('shadow2ColorVal'); const shadow2SizeMultiplierEl = document.getElementById('shadow2SizeMultiplier'); const shadow2SizeMultiplierVal = document.getElementById('shadow2SizeMultiplierVal'); const shadow3OffsetXEl = document.getElementById('shadow3OffsetX'); const shadow3OffsetXVal = document.getElementById('shadow3OffsetXVal'); const shadow3OffsetYEl = document.getElementById('shadow3OffsetY'); const shadow3OffsetYVal = document.getElementById('shadow3OffsetYVal'); const shadow3OpacityEl = document.getElementById('shadow3Opacity'); const shadow3OpacityVal = document.getElementById('shadow3OpacityVal'); const shadow3ColorEl = document.getElementById('shadow3Color'); const shadow3ColorVal = document.getElementById('shadow3ColorVal'); const shadow3SizeMultiplierEl = document.getElementById('shadow3SizeMultiplier'); const shadow3SizeMultiplierVal = document.getElementById('shadow3SizeMultiplierVal'); glassMorphismEnabledEl && glassMorphismEnabledEl.addEventListener('change',() => {glassMorphismEnabled = glassMorphismEnabledEl.checked; console.log('ðŸ”® Glass morphism enabled:',glassMorphismEnabled);}); illuminationSelectEl && illuminationSelectEl.addEventListener('change',() => {applyIlluminationTemplate(illuminationSelectEl.value);}); shadow1OffsetXEl && shadow1OffsetXEl.addEventListener('input',() => {shadow1OffsetX = parseInt(shadow1OffsetXEl.value,10); if (shadow1OffsetXVal) shadow1OffsetXVal.textContent = shadow1OffsetX + 'px';}); shadow1OffsetYEl && shadow1OffsetYEl.addEventListener('input',() => {shadow1OffsetY = parseInt(shadow1OffsetYEl.value,10); if (shadow1OffsetYVal) shadow1OffsetYVal.textContent = shadow1OffsetY + 'px';}); shadow1OpacityEl && shadow1OpacityEl.addEventListener('input',() => {shadow1Opacity = parseFloat(shadow1OpacityEl.value); if (shadow1OpacityVal) shadow1OpacityVal.textContent = shadow1Opacity.toFixed(2);}); shadow1ColorEl && shadow1ColorEl.addEventListener('input',() => {shadow1Color = shadow1ColorEl.value; if (shadow1ColorVal) shadow1ColorVal.textContent = shadow1Color.toUpperCase();}); shadow1SizeMultiplierEl && shadow1SizeMultiplierEl.addEventListener('input',() => {shadow1SizeMultiplier = parseFloat(shadow1SizeMultiplierEl.value); if (shadow1SizeMultiplierVal) shadow1SizeMultiplierVal.textContent = shadow1SizeMultiplier.toFixed(2) + 'Ã—';}); shadow2OffsetXEl && shadow2OffsetXEl.addEventListener('input',() => {shadow2OffsetX = parseInt(shadow2OffsetXEl.value,10); if (shadow2OffsetXVal) shadow2OffsetXVal.textContent = shadow2OffsetX + 'px';}); shadow2OffsetYEl && shadow2OffsetYEl.addEventListener('input',() => {shadow2OffsetY = parseInt(shadow2OffsetYEl.value,10); if (shadow2OffsetYVal) shadow2OffsetYVal.textContent = shadow2OffsetY + 'px';}); shadow2OpacityEl && shadow2OpacityEl.addEventListener('input',() => {shadow2Opacity = parseFloat(shadow2OpacityEl.value); if (shadow2OpacityVal) shadow2OpacityVal.textContent = shadow2Opacity.toFixed(2);}); shadow2ColorEl && shadow2ColorEl.addEventListener('input',() => {shadow2Color = shadow2ColorEl.value; if (shadow2ColorVal) shadow2ColorVal.textContent = shadow2Color.toUpperCase();}); shadow2SizeMultiplierEl && shadow2SizeMultiplierEl.addEventListener('input',() => {shadow2SizeMultiplier = parseFloat(shadow2SizeMultiplierEl.value); if (shadow2SizeMultiplierVal) shadow2SizeMultiplierVal.textContent = shadow2SizeMultiplier.toFixed(2) + 'Ã—';}); shadow3OffsetXEl && shadow3OffsetXEl.addEventListener('input',() => {shadow3OffsetX = parseInt(shadow3OffsetXEl.value,10); if (shadow3OffsetXVal) shadow3OffsetXVal.textContent = shadow3OffsetX + 'px';}); shadow3OffsetYEl && shadow3OffsetYEl.addEventListener('input',() => {shadow3OffsetY = parseInt(shadow3OffsetYEl.value,10); if (shadow3OffsetYVal) shadow3OffsetYVal.textContent = shadow3OffsetY + 'px';}); shadow3OpacityEl && shadow3OpacityEl.addEventListener('input',() => {shadow3Opacity = parseFloat(shadow3OpacityEl.value); if (shadow3OpacityVal) shadow3OpacityVal.textContent = shadow3Opacity.toFixed(2);}); shadow3ColorEl && shadow3ColorEl.addEventListener('input',() => {shadow3Color = shadow3ColorEl.value; if (shadow3ColorVal) shadow3ColorVal.textContent = shadow3Color.toUpperCase();}); shadow3SizeMultiplierEl && shadow3SizeMultiplierEl.addEventListener('input',() => {shadow3SizeMultiplier = parseFloat(shadow3SizeMultiplierEl.value); if (shadow3SizeMultiplierVal) shadow3SizeMultiplierVal.textContent = shadow3SizeMultiplier.toFixed(2) + 'Ã—';}); canvas.addEventListener('mousemove',(e) => {const rect = canvas.getBoundingClientRect(); mouseX = (e.clientX - rect.left) * DPR; mouseY = (e.clientY - rect.top) * DPR;}); canvas.addEventListener('mouseleave',() => {mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE;}); colorSelect && colorSelect.addEventListener('change',() => {const template = COLOR_TEMPLATES[colorSelect.value]; if (!template) return; currentTemplate = colorSelect.value; currentColors = template.colors.slice(); cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor; if (color1 && color1Val) {color1.value = currentColors[0]; color1Val.textContent = currentColors[0].toUpperCase();}if (color2 && color2Val) {color2.value = currentColors[1]; color2Val.textContent = currentColors[1].toUpperCase();}if (color3 && color3Val) {color3.value = currentColors[2]; color3Val.textContent = currentColors[2].toUpperCase();}if (color4 && color4Val) {color4.value = currentColors[3]; color4Val.textContent = currentColors[3].toUpperCase();}if (color5 && color5Val) {color5.value = currentColors[4]; color5Val.textContent = currentColors[4].toUpperCase();}if (color6 && color6Val) {color6.value = currentColors[5]; color6Val.textContent = currentColors[5].toUpperCase();}if (color7 && color7Val) {color7.value = currentColors[6]; color7Val.textContent = currentColors[6].toUpperCase();}if (color8 && color8Val) {color8.value = currentColors[7]; color8Val.textContent = currentColors[7].toUpperCase();}updateExistingBallColors(); syncPaletteVars();}); const modeButtons = Array.from(document.querySelectorAll('.mode-button')); const pitControls = document.getElementById('pitControls'); const fliesControls = document.getElementById('fliesControls'); const weightlessControls = document.getElementById('weightlessControls'); const gravityPitSlider = document.getElementById('gravityPitSlider'); const gravityPitVal = document.getElementById('gravityPitVal'); const repellerEnabledPitEl = document.getElementById('repellerEnabledPit'); const attractPowerSlider = document.getElementById('attractPowerSlider'); const attractPowerVal = document.getElementById('attractPowerVal'); const orbitRadiusSlider = document.getElementById('orbitRadiusSlider'); const orbitRadiusVal = document.getElementById('orbitRadiusVal'); const swarmSpeedSlider = document.getElementById('swarmSpeedSlider'); const swarmSpeedVal = document.getElementById('swarmSpeedVal'); const weightlessCountSlider = document.getElementById('weightlessCountSlider'); const weightlessCountVal = document.getElementById('weightlessCountVal'); const weightlessSpeedSlider = document.getElementById('weightlessSpeedSlider'); const weightlessSpeedVal = document.getElementById('weightlessSpeedVal'); const weightlessBounceSlider = document.getElementById('weightlessBounceSlider'); const weightlessBounceVal = document.getElementById('weightlessBounceVal'); const weightlessRepelSlider = document.getElementById('weightlessRepelSlider'); const weightlessRepelVal = document.getElementById('weightlessRepelVal'); const weightlessRepelRadiusSlider = document.getElementById('weightlessRepelRadiusSlider'); const weightlessRepelRadiusVal = document.getElementById('weightlessRepelRadiusVal'); function initializeFliesScene() {balls.length = 0; const targetBalls = 60; const w = canvas.width; const h = canvas.height; const centerX = w * 0.5; const centerY = h * 0.5; const swarmRadius = 150 * DPR; for (let i = 0; i < targetBalls; i++) {const angle = Math.random() * Math.PI * 2; const distance = Math.random() * swarmRadius; const x = centerX + Math.cos(angle) * distance; const y = centerY + Math.sin(angle) * distance; const ball = spawnBall(x,y); const speedVariation = 0.5 + Math.random() * 0.5; const vAngle = Math.random() * Math.PI * 2; const speed = 300 * speedVariation; ball.vx = Math.cos(vAngle) * speed; ball.vy = Math.sin(vAngle) * speed; ball.driftAx = 0; ball.driftTime = 0;}}function initializeWeightlessScene() {balls.length = 0; const targetBalls = weightlessCount; const w = canvas.width; const h = canvas.height; const aspectRatio = w / h; const cols = Math.ceil(Math.sqrt(targetBalls * aspectRatio)); const rows = Math.ceil(targetBalls / cols); const marginX = 40; const marginY = 40; const spacingX = (w - 2 * marginX) / Math.max(1,cols - 1); const spacingY = (h - 2 * marginY) / Math.max(1,rows - 1); const positions = []; for (let row = 0; row < rows; row++) {for (let col = 0; col < cols; col++) {if (positions.length >= targetBalls) break; const x = marginX + col * spacingX; const y = marginY + row * spacingY; const jitterX = (Math.random() - 0.5) * spacingX * 0.25; const jitterY = (Math.random() - 0.5) * spacingY * 0.25; positions.push({x: Math.max(20,Math.min(w - 20,x + jitterX)),y: Math.max(20,Math.min(h - 20,y + jitterY)) });}}for (const pos of positions) {const ball = spawnBall(pos.x,pos.y); const angle = Math.random() * Math.PI * 2; const speed = weightlessInitialSpeed * (0.7 + Math.random() * 0.3); ball.vx = Math.cos(angle) * speed; ball.vy = Math.sin(angle) * speed; ball.driftAx = 0; ball.driftTime = 0;}}function updateModeControlsUI() {if (pitControls) pitControls.classList.toggle('active',currentMode === MODES.PIT); if (fliesControls) fliesControls.classList.toggle('active',currentMode === MODES.FLIES); if (weightlessControls) weightlessControls.classList.toggle('active',currentMode === MODES.WEIGHTLESS); modeButtons.forEach(btn => btn.classList.toggle('active',btn.getAttribute('data-mode') === currentMode));}function setMode(mode) {currentMode = mode; container.className = ''; if (currentMode === MODES.PIT) {container.classList.add('mode-pit');}resize(); if (currentMode === MODES.PIT) {gravityMultiplier = gravityMultiplierPit; G = GE * gravityMultiplier; repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0); EMITTER_SWEEP_ENABLED = true; balls.length = 0; emitterTimer = 0; resetBallSizeToGlobal();}else if (currentMode === MODES.FLIES) {gravityMultiplier = 0.0; G = GE * gravityMultiplier; repellerEnabled = false; EMITTER_SWEEP_ENABLED = false; initializeFliesScene(); resetBallSizeToGlobal();}else if (currentMode === MODES.WEIGHTLESS) {gravityMultiplier = 0.0; G = GE * gravityMultiplier; repellerEnabled = false; EMITTER_SWEEP_ENABLED = false; initializeWeightlessScene(); resetBallSizeToGlobal();}updateModeControlsUI();}modeButtons.forEach(btn => btn.addEventListener('click',() => {setMode(btn.getAttribute('data-mode')); autoSaveSettings();})); gravityPitSlider && gravityPitSlider.addEventListener('input',() => {gravityMultiplierPit = parseFloat(gravityPitSlider.value); gravityPitVal && (gravityPitVal.textContent = gravityMultiplierPit.toFixed(1)); autoSaveSettings(); if (currentMode === MODES.PIT) {gravityMultiplier = gravityMultiplierPit; G = GE * gravityMultiplier;}}); weightPitSlider && weightPitSlider.addEventListener('input',() => {ballMassKg = parseFloat(weightPitSlider.value); weightPitVal && (weightPitVal.textContent = ballMassKg.toFixed(2)); for (let i=0; i<balls.length; i++) {balls[i].m = ballMassKg;}recomputeMassDerivedScales(); autoSaveSettings();}); repellerEnabledPitEl && repellerEnabledPitEl.addEventListener('change',() => {repellerEnabledPit = !!repellerEnabledPitEl.checked; if (currentMode === MODES.PIT) repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0);}); attractPowerSlider && attractPowerSlider.addEventListener('input',() => {attractionPower = parseFloat(attractPowerSlider.value); attractPowerVal && (attractPowerVal.textContent = Math.round(attractionPower).toString());}); orbitRadiusSlider && orbitRadiusSlider.addEventListener('input',() => {orbitRadius = parseFloat(orbitRadiusSlider.value); orbitRadiusVal && (orbitRadiusVal.textContent = Math.round(orbitRadius).toString());}); swarmSpeedSlider && swarmSpeedSlider.addEventListener('input',() => {swarmSpeed = parseFloat(swarmSpeedSlider.value); swarmSpeedVal && (swarmSpeedVal.textContent = swarmSpeed.toFixed(1));}); weightlessCountSlider && weightlessCountSlider.addEventListener('input',() => {weightlessCount = parseInt(weightlessCountSlider.value,10); weightlessCountVal && (weightlessCountVal.textContent = weightlessCount.toString()); if (currentMode === MODES.WEIGHTLESS) initializeWeightlessScene();}); weightlessSpeedSlider && weightlessSpeedSlider.addEventListener('input',() => {weightlessInitialSpeed = parseFloat(weightlessSpeedSlider.value); weightlessSpeedVal && (weightlessSpeedVal.textContent = Math.round(weightlessInitialSpeed).toString());}); weightlessBounceSlider && weightlessBounceSlider.addEventListener('input',() => {weightlessBounce = parseFloat(weightlessBounceSlider.value); weightlessBounceVal && (weightlessBounceVal.textContent = weightlessBounce.toFixed(2));}); weightlessRepelSlider && weightlessRepelSlider.addEventListener('input',() => {weightlessRepellerPower = parseFloat(weightlessRepelSlider.value); weightlessRepelVal && (weightlessRepelVal.textContent = Math.round(weightlessRepellerPower).toString()); autoSaveSettings();}); weightlessRepelRadiusSlider && weightlessRepelRadiusSlider.addEventListener('input',() => {weightlessRepellerRadius = parseFloat(weightlessRepelRadiusSlider.value); weightlessRepelRadiusVal && (weightlessRepelRadiusVal.textContent = Math.round(weightlessRepellerRadius).toString()); autoSaveSettings();}); function updateExistingBallColors() {for (let i = 0; i < balls.length; i++) {balls[i].color = pickRandomColor();}}color1 && color1.addEventListener('input',() => {currentColors[0] = color1.value; color1Val && (color1Val.textContent = color1.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color2 && color2.addEventListener('input',() => {currentColors[1] = color2.value; color2Val && (color2Val.textContent = color2.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color3 && color3.addEventListener('input',() => {currentColors[2] = color3.value; color3Val && (color3Val.textContent = color3.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color4 && color4.addEventListener('input',() => {currentColors[3] = color4.value; color4Val && (color4Val.textContent = color4.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color5 && color5.addEventListener('input',() => {currentColors[4] = color5.value; color5Val && (color5Val.textContent = color5.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color6 && color6.addEventListener('input',() => {currentColors[5] = color6.value; color6Val && (color6Val.textContent = color6.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color7 && color7.addEventListener('input',() => {currentColors[6] = color7.value; color7Val && (color7Val.textContent = color7.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color8 && color8.addEventListener('input',() => {currentColors[7] = color8.value; color8Val && (color8Val.textContent = color8.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); cursorColorSelect && cursorColorSelect.addEventListener('change',() => {const idx = Math.max(1,Math.min(8,parseInt(cursorColorSelect.value,10))) - 1; cursorBallIndex = idx; cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor;}); bindCopyOnClick(color1Val,() => color1.value.toUpperCase()); bindCopyOnClick(color2Val,() => color2.value.toUpperCase()); bindCopyOnClick(color3Val,() => color3.value.toUpperCase()); bindCopyOnClick(color4Val,() => color4.value.toUpperCase()); bindCopyOnClick(color5Val,() => color5.value.toUpperCase()); bindCopyOnClick(color6Val,() => color6.value.toUpperCase()); bindCopyOnClick(color7Val,() => color7.value.toUpperCase()); bindCopyOnClick(color8Val,() => color8.value.toUpperCase()); cornerRadiusSlider && cornerRadiusSlider.addEventListener('input',() => {cornerRadius = parseFloat(cornerRadiusSlider.value); cornerRadiusVal && (cornerRadiusVal.textContent = cornerRadius.toFixed(0));}); motionBlurFadeSlider && motionBlurFadeSlider.addEventListener('input',() => {motionBlurFade = parseFloat(motionBlurFadeSlider.value); motionBlurFadeVal && (motionBlurFadeVal.textContent = motionBlurFade.toFixed(3));}); trailSubtletySlider && trailSubtletySlider.addEventListener('input',() => {trailSubtlety = parseFloat(trailSubtletySlider.value); trailSubtletyVal && (trailSubtletyVal.textContent = trailSubtlety.toFixed(2) + 'Ã—');}); const PHYSICS_PRESETS = {rubberPlayground: {label: 'Rubber â€“ Playground',G: 1960,REST: 0.90,FRICTION: 0.0025,sizeScale: 1.8,maxBalls: 450,sizeVariation: 0.20 },rubberRacquet: {label: 'Rubber â€“ Racquetball',G: 3320,REST: 0.97,FRICTION: 0.0035,sizeScale: 0.7,maxBalls: 350,sizeVariation: 0.30 },rubberSuperball: {label: 'Rubber â€“ Superball',G: 1960,REST: 0.95,FRICTION: 0.0015,sizeScale: 1.2,maxBalls: 450,sizeVariation: 0.05 },rubberSoft: {label: 'Rubber â€“ Soft',G: 1960,REST: 0.86,FRICTION: 0.0035,sizeScale: 2.2,maxBalls: 350,sizeVariation: 0.25 },rubberHeavy: {label: 'Rubber â€“ Heavy',G: 1960,REST: 0.88,FRICTION: 0.0030,sizeScale: 2.0,maxBalls: 400,sizeVariation: 0.15 }}; const SPAWN_PRESETS = {fullRain: {label: 'Full Rain (top-half)',EMIT_INTERVAL: 0.030,xCenter: 50,y: -50,w: 100,h: 50 },narrowStrip: {label: 'Narrow Strip Top',EMIT_INTERVAL: 0.050,xCenter: 50,y: -40,w: 20,h: 10 },leftGutter: {label: 'Left Gutter',EMIT_INTERVAL: 0.045,xCenter: 10,y: -60,w: 18,h: 20 },rightGutter: {label: 'Right Gutter',EMIT_INTERVAL: 0.045,xCenter: 90,y: -60,w: 18,h: 20 },centerFountain: {label: 'Center Fountain',EMIT_INTERVAL: 0.020,xCenter: 50,y: -30,w: 30,h: 20 },stormBurst: {label: 'Storm Burst',EMIT_INTERVAL: 0.005,xCenter: 50,y: -80,w: 100,h: 30 },slowSnow: {label: 'Slow Snow',EMIT_INTERVAL: 0.200,xCenter: 50,y: -30,w: 100,h: 20 },edgeDrizzle: {label: 'Edge Drizzle',EMIT_INTERVAL: 0.080,xCenter: 15,y: -40,w: 30,h: 15 },twinColumns: {label: 'Twin Columns',EMIT_INTERVAL: 0.030,xCenter: 30,y: -50,w: 10,h: 40 },focusedBeam: {label: 'Focused Beam',EMIT_INTERVAL: 0.015,xCenter: 50,y: -70,w: 6,h: 12 }}; const REPELLER_PRESETS = {off: {label: 'Off',r: 710,p: 27400 * 10,s: 4.4 },gentle: {label: 'Gentle Breeze',r: 120,p: 2500,s: 2.5 },pushField: {label: 'Push Field',r: 240,p: 8000 * 10,s: 2.0 },tractor: {label: 'Tractor Push',r: 320,p: 14000 * 10,s: 1.6 },magnet: {label: 'Magnet Repel',r: 200,p: 18000 * 10,s: 3.0 },pulse: {label: 'Pulse Strong',r: 280,p: 22000 * 10,s: 1.2 },wideSoft: {label: 'Wide Soft',r: 500,p: 8000 * 10,s: 4.5 },needle: {label: 'Needle Point',r: 80,p: 26000 * 10,s: 0.8 },wall: {label: 'Invisible Wall',r: 700,p: 16000 * 10,s: 5.0 },singularity: {label: 'Singularity',r: 600,p: 30000 * 10,s: 0.5 }}; function fillSelect(select,dict,selectedKey) {select.innerHTML = ''; for (const [key,val] of Object.entries(dict)) {const opt = document.createElement('option'); opt.value = key; opt.textContent = val.label || key; if (key === selectedKey) opt.selected = true; select.appendChild(opt);}}const physicsSelect = document.getElementById('physicsSelect'); const spawnSelect = document.getElementById('spawnSelect'); const repellerSelect = document.getElementById('repellerSelect'); if (physicsSelect) fillSelect(physicsSelect,PHYSICS_PRESETS,'rubberRacquet'); if (spawnSelect) fillSelect(spawnSelect,SPAWN_PRESETS,'fullRain'); if (repellerSelect) fillSelect(repellerSelect,REPELLER_PRESETS,'off'); if (colorSelect) fillSelect(colorSelect,COLOR_TEMPLATES,'industrialTeal'); function updateSliderAndValue(slider,valueElement,value,decimals = 0) {if (slider) slider.value = String(value); if (valueElement) valueElement.textContent = decimals > 0 ? value.toFixed(decimals) : value.toString();}function applyPhysicsPreset(key) {const p = PHYSICS_PRESETS[key]; if (!p) return; REST = p.REST; FRICTION = p.FRICTION; MAX_BALLS = p.maxBalls; sizeVariation = p.sizeVariation; const newScale = p.sizeScale; sizeScale = newScale; updateEffectiveScaleAndBallSizes(); for (let i=0; i<balls.length; i++) {if (currentMode === MODES.BOULDERS) {balls[i].m = ballMassKg * 5;}else {balls[i].m = ballMassKg;}}if (balls.length > MAX_BALLS) {balls.length = MAX_BALLS;}updateSliderAndValue(restitutionSlider,restitutionVal,REST,2); updateSliderAndValue(frictionSlider,frictionVal,FRICTION,4); updateSliderAndValue(sizeSliderGlobal,sizeValGlobal,sizeScale,1); updateSliderAndValue(maxBallsSlider,maxBallsVal,MAX_BALLS,0); updateSliderAndValue(sizeVariationSliderGlobal,sizeVariationValGlobal,sizeVariation,1); updateExistingBallSizes();}function applySpawnPreset(key) {const s = SPAWN_PRESETS[key]; if (!s) return; EMIT_INTERVAL = s.EMIT_INTERVAL; SPAWN_X_CENTER_VW = s.xCenter; SPAWN_Y_VH = s.y; SPAWN_W_VW = s.w; SPAWN_H_VH = s.h; updateSliderAndValue(emitterSlider,emitterVal,EMIT_INTERVAL,3); updateSliderAndValue(spawnCenterSlider,spawnCenterVal,SPAWN_X_CENTER_VW,0); updateSliderAndValue(spawnYSlider,spawnYVal,SPAWN_Y_VH,0); updateSliderAndValue(spawnWidthSlider,spawnWidthVal,SPAWN_W_VW,0); updateSliderAndValue(spawnHeightSlider,spawnHeightVal,SPAWN_H_VH,0);}function applyRepellerPreset(key) {const r = REPELLER_PRESETS[key]; if (!r) return; repelRadius = r.r; repelPower = r.p * (REPELLER_GLOBAL_MULTIPLIER / 20.0); repellerEnabled = (key !== 'off'); updateSliderAndValue(repelSizeSlider,repelSizeVal,repelRadius,0); const sliderPos = powerToRepelSlider(repelPower); if (repelPowerSlider) repelPowerSlider.value = String(sliderPos); if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString(); updateSliderAndValue(repelSoftSlider,repelSoftVal,repelSoft,1);}applyPhysicsPreset('rubberRacquet'); applySpawnPreset('fullRain'); applyRepellerPreset('off'); const defaultTemplate = COLOR_TEMPLATES[currentTemplate]; if (color1 && color1Val) {color1.value = defaultTemplate.colors[0]; color1Val.textContent = defaultTemplate.colors[0].toUpperCase();}if (color2 && color2Val) {color2.value = defaultTemplate.colors[1]; color2Val.textContent = defaultTemplate.colors[1].toUpperCase();}if (color3 && color3Val) {color3.value = defaultTemplate.colors[2]; color3Val.textContent = defaultTemplate.colors[2].toUpperCase();}if (color4 && color4Val) {color4.value = defaultTemplate.colors[3]; color4Val.textContent = defaultTemplate.colors[3].toUpperCase();}if (color5 && color5Val) {color5.value = defaultTemplate.colors[4]; color5Val.textContent = defaultTemplate.colors[4].toUpperCase();}if (color6 && color6Val) {color6.value = defaultTemplate.colors[5]; color6Val.textContent = defaultTemplate.colors[5].toUpperCase();}if (color7 && color7Val) {color7.value = defaultTemplate.colors[6]; color7Val.textContent = defaultTemplate.colors[6].toUpperCase();}if (color8 && color8Val) {color8.value = defaultTemplate.colors[7]; color8Val.textContent = defaultTemplate.colors[7].toUpperCase();}syncPaletteVars(defaultTemplate.colors); physicsSelect && physicsSelect.addEventListener('change',() => applyPhysicsPreset(physicsSelect.value)); spawnSelect && spawnSelect.addEventListener('change',() => applySpawnPreset(spawnSelect.value)); repellerSelect && repellerSelect.addEventListener('change',() => applyRepellerPreset(repellerSelect.value)); updateEffectiveScaleAndBallSizes(); updateTextColliders(); const settingsLoaded = loadSettings(); applyDeviceSpecificModeVisibility(); setMode(currentMode); window.addEventListener('beforeunload',saveSettings);})();