(() => {const MODES = {PIT: 'pit',FLIES: 'flies',WEIGHTLESS: 'weightless',PULSE_GRID: 'pulse-grid' }; const MODE_AVAILABILITY = {[MODES.PIT]: {desktop: true,mobile: true },[MODES.FLIES]: {desktop: true,mobile: true },[MODES.WEIGHTLESS]: {desktop: true,mobile: true },[MODES.PULSE_GRID]: {desktop: true,mobile: true }}; let currentMode = MODES.PIT; let ballSoftness = 40; let gravityMultiplierPit = 1.15; let repellerEnabledPit = true; let attractionPower = 5000; let orbitRadius = 180; let swarmSpeed = 3.5; let weightlessCount = 80; let weightlessInitialSpeed = 250; let weightlessBounce = 0.97; let weightlessRepellerPower = 300; let weightlessRepellerRadius = 150; let gridColumns = 40; let gridCellAspect = 1.0; let pulseInterval = 0.8; let pulseSpeed = 0.25; let pulseSynchronicity = 0.3; let pulseRandomness = 0.4; let pulseMinSteps = 1; let pulseMaxSteps = 3; let gridBallCount = 120; let pulseBounceIntensity = 0.15; let pulseEasingStyle = 'snap'; let pulseOvershoot = 1.08; let cursorBallVisible = true; let canvasShadowEnabled = false; let shadowOffsetX = 0; let shadowOffsetY = 4; let shadowBlur = 12; let shadowOpacity = 0.15; let shadowColor = '#000000'; let shadow2Enabled = false; let shadow2Blur = 4; let shadow2Opacity = 0.10; const MASS_BASELINE_KG = 1.0; const CONFIG_SCHEMA = {gridColumns: {min: 20,max: 80,type: 'integer',default: 40 },gridBallCount: {min: 40,max: 200,type: 'integer',default: 120 },pulseInterval: {min: 0.2,max: 2.0,type: 'number',default: 0.8 },pulseSpeed: {min: 0.1,max: 1.0,type: 'number',default: 0.25 },pulseSynchronicity: {min: 0,max: 1,type: 'number',default: 0.3 },pulseRandomness: {min: 0,max: 1,type: 'number',default: 0.4 },pulseMinSteps: {min: 1,max: 3,type: 'integer',default: 1 },pulseMaxSteps: {min: 1,max: 5,type: 'integer',default: 3 },pulseOvershoot: {min: 1.0,max: 1.3,type: 'number',default: 1.08 },pulseBounceIntensity: {min: 0,max: 0.5,type: 'number',default: 0.15 },shadowOffsetX: {min: -20,max: 20,type: 'integer',default: 0 },shadowOffsetY: {min: -20,max: 20,type: 'integer',default: 4 },shadowBlur: {min: 0,max: 30,type: 'integer',default: 12 },shadowOpacity: {min: 0,max: 1,type: 'number',default: 0.15 },shadow2Blur: {min: 0,max: 20,type: 'integer',default: 4 },shadow2Opacity: {min: 0,max: 1,type: 'number',default: 0.10 }}; function validateConfigValue(key,value) {const schema = CONFIG_SCHEMA[key]; if (!schema) return value; let validated = value; if (schema.type === 'integer') {validated = Math.round(Number(validated)); if (!Number.isFinite(validated)) {console.warn(`${key}must be a number,using default ${schema.default}`); return schema.default;}}else if (schema.type === 'number') {validated = Number(validated); if (!Number.isFinite(validated)) {console.warn(`${key}must be a number,using default ${schema.default}`); return schema.default;}}if (schema.min !== undefined && validated < schema.min) {console.warn(`${key}(${validated}) below minimum (${schema.min}),clamping`); validated = schema.min;}if (schema.max !== undefined && validated > schema.max) {console.warn(`${key}(${validated}) above maximum (${schema.max}),clamping`); validated = schema.max;}return validated;}const CONSTANTS = {CANVAS_HEIGHT_VH_PIT: 1.5,CANVAS_HEIGHT_VH_DEFAULT: 1.0,OFFSCREEN_MOUSE: -1e9,MIN_DISTANCE_EPSILON: 1e-6,MIN_REPEL_DISTANCE: 1e-4,ACCUMULATOR_RESET_THRESHOLD: 3,INITIAL_SEED_BALLS: 200,BALL_SPAWN_OFFSET: 2,BALL_CLUSTER_SPACING: 8,BALL_CLUSTER_Y_OFFSET: 12,MAX_PHYSICS_STEPS: 2,FPS_UPDATE_INTERVAL: 1.0,SPIN_DAMP_PER_S: 2.0,SPIN_GAIN: 0.25,SPIN_GAIN_TANGENT: 0.18,ROLL_FRICTION_PER_S: 1.5,SQUASH_MAX_BASE: 0.20,SQUASH_DECAY_PER_S: 18.0,WALL_REST_VEL_THRESHOLD: 70,GROUND_COUPLING_PER_S: 8.0 }; function getSquashMax() {if (ballSoftness === 0) return 0; return CONSTANTS.SQUASH_MAX_BASE * (ballSoftness / 40.0);}const canvas = document.getElementById('c'); const container = document.getElementById('bravia-balls'); let ctx; try {ctx = canvas.getContext('2d',{alpha: true }); if (!ctx) {throw new Error('Canvas 2D context not available');}}catch (error) {console.error('‚ùå Failed to initialize canvas:',error); container.innerHTML = ` <div style="display: flex; align-items: center; justify-content: center; height: 100%; background: #1a1a1a; color: white; font-family: system-ui,-apple-system,sans-serif;"> <div style="text-align: center; padding: 40px; background: rgba(255,50,50,0.1); border: 2px solid rgba(255,50,50,0.3); border-radius: 12px; max-width: 480px;"> <div style="font-size: 72px; margin-bottom: 20px; filter: drop-shadow(0 4px 8px rgba(0,0,0,0.3));">‚ö†Ô∏è</div> <h2 style="margin: 0 0 16px 0; font-size: 24px; font-weight: 600;">Canvas Not Supported</h2> <p style="margin: 0 0 12px 0; opacity: 0.9; line-height: 1.6; font-size: 15px;">Your browser doesn't support the HTML5 Canvas 2D features required for this interactive simulation.</p> <p style="margin: 0; opacity: 0.7; font-size: 13px;">Please try a modern browser like Chrome,Firefox,Safari,or Edge.</p> </div> </div> `; throw error;}const panel = document.getElementById('controlPanel'); const DPR = Math.max(1,Math.min(2,window.devicePixelRatio || 1)); function updateCanvasShadow() {if (!canvasShadowEnabled) {canvas.style.filter = 'none'; return;}const hexToRgba = (hex,opacity) => {const r = parseInt(hex.slice(1,3),16); const g = parseInt(hex.slice(3,5),16); const b = parseInt(hex.slice(5,7),16); return `rgba(${r},${g},${b},${opacity})`;}; const shadow1 = `drop-shadow(${shadowOffsetX}px ${shadowOffsetY}px ${shadowBlur}px ${hexToRgba(shadowColor,shadowOpacity)})`; const shadow2 = shadow2Enabled ? ` drop-shadow(${shadowOffsetX}px ${Math.round(shadowOffsetY * 0.5)}px ${shadow2Blur}px ${hexToRgba(shadowColor,shadow2Opacity)})` : ''; canvas.style.filter = shadow1 + shadow2;}let frameCount = 0; let lastFPSCheck = 0; let currentFPS = 60; let performanceMode = false; let targetFPS = 60; let fpsCheckInterval = 0.5; let autoDarkModeEnabled = true; let isDarkMode = false; const SUNSET_HOUR = 18; const SUNRISE_HOUR = 6; function isNightTime() {const now = new Date(); const hour = now.getHours(); return hour >= SUNSET_HOUR || hour < SUNRISE_HOUR;}function applyDarkMode(enabled) {isDarkMode = enabled; if (enabled) {container.classList.add('dark-mode');}else {container.classList.remove('dark-mode');}applyColorTemplate(currentTemplate); updateDarkModeUI();}function checkAndApplyDarkMode() {if (autoDarkModeEnabled) {applyDarkMode(isNightTime());}}function updateDarkModeUI() {const toggle = document.getElementById('darkModeToggle'); const status = document.getElementById('darkModeStatus'); if (toggle) toggle.checked = autoDarkModeEnabled; if (status) {const now = new Date(); const hour = now.getHours(); const timeStr = `${hour.toString().padStart(2,'0')}:${now.getMinutes().toString().padStart(2,'0')}`; if (isDarkMode) {status.textContent = `üåô Night Mode (${timeStr})`; status.style.background = 'rgba(100,100,255,0.3)';}else {status.textContent = `‚òÄÔ∏è Day Mode (${timeStr})`; status.style.background = 'rgba(255,200,0,0.3)';}}}function toggleAutoDarkMode() {autoDarkModeEnabled = !autoDarkModeEnabled; if (autoDarkModeEnabled) {checkAndApplyDarkMode(); console.log('üåô Auto Dark Mode: ENABLED');}else {applyDarkMode(false); console.log('‚òÄÔ∏è Auto Dark Mode: DISABLED');}}const PERFORMANCE_SETTINGS = {normal: {maxBalls: 350,collisionIters: 2,adaptiveQualityMin: 0.5 },performance: {maxBalls: 200,collisionIters: 1,adaptiveQualityMin: 0.3 }}; let enableLOD = true; function updateAdaptiveQuality() {frameCount++; const now = performance.now(); const checkInterval = performanceMode ? (fpsCheckInterval * 1000) : 1000; if (now - lastFPSCheck >= checkInterval) {currentFPS = frameCount * (1000 / checkInterval); frameCount = 0; lastFPSCheck = now; if (performanceMode) {if (currentFPS < targetFPS) {adaptiveQuality = Math.max(PERFORMANCE_SETTINGS.performance.adaptiveQualityMin,adaptiveQuality - 0.2); if (currentFPS < targetFPS * 0.8 && balls.length > 100) {const reduceBy = Math.min(20,balls.length - 100); balls.length -= reduceBy; console.log(`‚ö° Performance mode: Reduced balls by ${reduceBy}(now ${balls.length})`);}}else if (currentFPS > targetFPS * 1.1) {adaptiveQuality = Math.min(1.0,adaptiveQuality + 0.1);}}else {if (currentFPS < 45) {adaptiveQuality = Math.max(0.3,adaptiveQuality - 0.1);}else if (currentFPS > 55) {adaptiveQuality = Math.min(1.0,adaptiveQuality + 0.05);}}const mode = performanceMode ? 'PERF' : 'NORM'; console.log(`üéÆ ${mode}FPS: ${currentFPS}/${targetFPS},Balls: ${balls.length}`);}}function togglePerformanceMode() {performanceMode = !performanceMode; targetFPS = performanceMode ? 120 : 60; const settings = performanceMode ? PERFORMANCE_SETTINGS.performance : PERFORMANCE_SETTINGS.normal; if (performanceMode) {console.log('‚ö° PERFORMANCE MODE: Optimizing for 120 FPS...'); if (balls.length > settings.maxBalls) {balls.length = settings.maxBalls; console.log(`‚ö° Reduced balls to ${settings.maxBalls}for 120 FPS`);}MAX_BALLS = settings.maxBalls; currentCollisionIters = settings.collisionIters;}else {console.log('üé® NORMAL MODE: Restoring visual quality...'); MAX_BALLS = settings.maxBalls; currentCollisionIters = settings.collisionIters;}updatePerformanceModeUI(); console.log(`üéØ Target FPS: ${targetFPS},Mode: ${performanceMode ? 'PERFORMANCE' : 'NORMAL'}`);}function updatePerformanceModeUI() {const toggle = document.getElementById('performanceModeToggle'); const status = document.getElementById('performanceModeStatus'); const maxBallsSlider = document.getElementById('maxBallsSlider'); const maxBallsVal = document.getElementById('maxBallsVal'); if (toggle) toggle.checked = performanceMode; if (status) {if (performanceMode) {status.textContent = `‚ö° 120 FPS Mode Active (${balls.length}balls)`; status.style.background = 'rgba(255,165,0,0.3)';}else {status.textContent = `üé® Normal Mode (${balls.length}balls)`; status.style.background = 'rgba(0,0,0,0.2)';}}if (maxBallsSlider && maxBallsVal) {maxBallsSlider.value = MAX_BALLS; maxBallsVal.textContent = MAX_BALLS.toString();}}let SPAWN_X_CENTER_VW = 50; let SPAWN_Y_VH = -50; let SPAWN_W_VW = 100; let SPAWN_H_VH = 50; function resize() {const heightMultiplier = (currentMode === MODES.PIT) ? CONSTANTS.CANVAS_HEIGHT_VH_PIT : CONSTANTS.CANVAS_HEIGHT_VH_DEFAULT; const simHeight = window.innerHeight * heightMultiplier; canvas.width = Math.floor(window.innerWidth * DPR); canvas.height = Math.floor(simHeight * DPR); if (currentMode === MODES.PULSE_GRID) {calculateGridDimensions(); for (let i = 0; i < balls.length; i++) {const ball = balls[i]; ball.gridX = Math.max(0,Math.min(gridCols - 1,ball.gridX)); ball.gridY = Math.max(0,Math.min(gridRows - 1,ball.gridY)); const pos = gridCellToPixel(ball.gridX,ball.gridY); ball.x = pos.x; ball.y = pos.y; ball.targetX = pos.x; ball.targetY = pos.y;}}}const setCSSSize = () => {}; let resizeTimeout; function handleResize() {clearTimeout(resizeTimeout); resizeTimeout = setTimeout(() => {setCSSSize(); resize(); updateEffectiveScaleAndBallSizes(); updateTextColliders();},150);}setCSSSize(); resize(); window.addEventListener('resize',handleResize); const GE = 1960; let gravityMultiplier = 0; let G = GE * gravityMultiplier; let REST = 0.88; let FRICTION = 0.003; let EMIT_INTERVAL = 0.03; let MAX_BALLS = 350; const SOLVER_ITERS = 6; const POS_CORRECT_PERCENT = 0.8; const POS_CORRECT_SLOP = 0.5 * DPR; const REST_VEL_THRESHOLD = 30; const R_MIN_BASE = 6; const R_MAX_BASE = 24; let sizeScale = 0.7; let sizeVariation = 0.15; let responsiveScale = 1.0; let lastEffectiveScale = null; let ballMassKg = 19.8; const MASS_GRAVITY_EXP = 0.35; const MASS_REST_EXP = 0.15; let gravityScale = 1.0; function recomputeMassDerivedScales() {gravityScale = Math.max(0.5,Math.min(3.0,Math.pow(ballMassKg / MASS_BASELINE_KG,MASS_GRAVITY_EXP)));}recomputeMassDerivedScales(); let R_MIN = R_MIN_BASE * sizeScale; let R_MAX = R_MAX_BASE * sizeScale; function computeResponsiveScale() {const containerWidth = canvas.clientWidth || window.innerWidth; return (containerWidth <= 768) ? 0.4 : 1.0;}function updateEffectiveScaleAndBallSizes() {responsiveScale = computeResponsiveScale(); const effectiveScale = sizeScale * responsiveScale; if (lastEffectiveScale === null) {lastEffectiveScale = effectiveScale; R_MIN = R_MIN_BASE * effectiveScale; R_MAX = R_MAX_BASE * effectiveScale; return;}const ratio = effectiveScale / lastEffectiveScale; if (ratio !== 1) {for (let i = 0; i < balls.length; i++) {balls[i].r *= ratio;}lastEffectiveScale = effectiveScale;}R_MIN = R_MIN_BASE * effectiveScale; R_MAX = R_MAX_BASE * effectiveScale;}function updateTextColliders() {textColliders = []; const textElement = document.querySelector(TEXT_SELECTOR); if (!textElement) return; const textRect = textElement.getBoundingClientRect(); const canvasRect = canvas.getBoundingClientRect(); const capHeight = calculateCapHeight(textElement); const heightDifference = textRect.height - capHeight; const verticalOffset = heightDifference * 0.5; const collider = {x: (textRect.left - canvasRect.left) * DPR,y: (textRect.top - canvasRect.top + verticalOffset) * DPR,width: textRect.width * DPR,height: capHeight * DPR }; if (collider.width > 0 && collider.height > 0 && collider.x < canvas.width && collider.y < canvas.height && collider.x + collider.width > 0 && collider.y + collider.height > 0) {textColliders.push(collider);}}function calculateCapHeight(element) {const tempElement = document.createElement('span'); tempElement.style.cssText = window.getComputedStyle(element).cssText; tempElement.style.position = 'absolute'; tempElement.style.visibility = 'hidden'; tempElement.style.whiteSpace = 'nowrap'; tempElement.textContent = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'; document.body.appendChild(tempElement); const capHeight = tempElement.getBoundingClientRect().height; document.body.removeChild(tempElement); return capHeight;}let EMITTER_SWEEP_ENABLED = false; let emitterPhase = 0; const EMITTER_SWEEP_HZ = 0.12; const EMITTER_SWEEP_AMPL_VW = 20; let emitterSweepDir = 1; const COLOR_TEMPLATES = {industrialTeal: {label: 'Industrial Teal',light: ['#b7bcb7','#e4e9e4','#ffffff','#00695c','#000000','#ff4013','#0d5cb6','#ffa000'],dark: ['#2a2a2a','#1a1a1a','#404040','#00a88f','#e0e0e0','#ff6b47','#3b7de0','#ffc04d'] },sunsetCoral: {label: 'Sunset Coral',light: ['#bdbbb8','#e8e6e3','#ffffff','#ff3b3b','#000000','#00f5d4','#1e40af','#fb923c'],dark: ['#2b2a28','#1c1b1a','#3d3d3d','#ff5c5c','#dddddd','#00ffe7','#4169e1','#ffa866'] },violetPunch: {label: 'Violet Punch',light: ['#b8b7c2','#e6e5ed','#ffffff','#9333ea','#000000','#dc2626','#0ea5e9','#facc15'],dark: ['#2a2832','#1a1921','#3e3d47','#b24dff','#e0e0e0','#ff4444','#00d4ff','#ffe34d'] },citrusBlast: {label: 'Citrus Blast',light: ['#bfbdb5','#eae8df','#ffffff','#ea580c','#000000','#e11d48','#2563eb','#059669'],dark: ['#2c2b27','#1d1c19','#3f3e3a','#ff7733','#dddddd','#ff4466','#4d8aff','#00bf7f'] },cobaltSpark: {label: 'Cobalt Spark',light: ['#b5b8be','#e3e6eb','#ffffff','#1d4ed8','#000000','#ea580c','#db2777','#d97706'],dark: ['#282b30','#191c20','#3d4147','#4d7aff','#dedede','#ff7f3d','#ff4d9e','#ffad33'] }}; let currentTemplate = 'industrialTeal'; let currentColors = COLOR_TEMPLATES.industrialTeal.light.slice(); let cursorBallIndex = 4; let cursorBallColor = currentColors[cursorBallIndex] || '#000000'; function getCurrentPalette(templateName) {const template = COLOR_TEMPLATES[templateName]; if (!template) return COLOR_TEMPLATES.industrialTeal.light; return isDarkMode ? template.dark : template.light;}function applyColorTemplate(templateName) {currentTemplate = templateName; currentColors = getCurrentPalette(templateName); cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor; updateExistingBallColors(); syncPaletteVars(); updateColorPickersUI();}function syncPaletteVars(colors = currentColors) {try {const root = document.documentElement; const list = (colors && colors.length ? colors : currentColors).slice(0,8); for (let i = 0; i < 8; i++) {const hex = list[i] || '#ffffff'; root.style.setProperty(`--ball-${i+1}`,hex);}}catch (_) {}}const COLOR_WEIGHTS = [0.50,0.25,0.12,0.06,0.03,0.02,0.01,0.01]; function pickRandomColor() {try {if (!currentColors || currentColors.length === 0) {console.warn('No colors available,using fallback'); return '#ffffff';}const random = Math.random(); let cumulativeWeight = 0; for (let i = 0; i < Math.min(currentColors.length,COLOR_WEIGHTS.length); i++) {cumulativeWeight += COLOR_WEIGHTS[i]; if (random <= cumulativeWeight) {return currentColors[i];}}return currentColors[Math.min(currentColors.length - 1,7)];}catch (error) {console.error('Error picking random color:',error); return '#ffffff';}}let repelRadius = 135; let repelPower = 1536000; let repelSoft = 3.4; let mouseX = CONSTANTS.OFFSCREEN_MOUSE,mouseY = CONSTANTS.OFFSCREEN_MOUSE; let repellerEnabled = false; const REPELLER_GLOBAL_MULTIPLIER = 20.0; let isTouchDevice = false; if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {isTouchDevice = true;}function applyDeviceSpecificModeVisibility() {}const STORAGE_KEY = 'bouncyBallsSettings'; function saveSettings() {const settings = {currentMode,gravityMultiplierPit,repellerEnabledPit,attractionPower,orbitRadius,swarmSpeed,weightlessInitialSpeed,weightlessBounce,weightlessCount,weightlessRepellerPower,weightlessRepellerRadius,restitution: REST,friction: FRICTION,sizeScale,sizeVariation,ballMassKg,ballSoftness,repelPower,repelRadius,repelSoft,cornerRadius,motionBlur: trailFade,trailSubtlety,currentTemplate,cursorBallColor,gridColumns,gridBallCount,pulseInterval,pulseSpeed,pulseSynchronicity,pulseRandomness,pulseMinSteps,pulseMaxSteps,pulseEasingStyle,pulseOvershoot,pulseBounceIntensity,canvasShadowEnabled,shadowOffsetX,shadowOffsetY,shadowBlur,shadowOpacity,shadowColor,shadow2Enabled,shadow2Blur,shadow2Opacity,autoDarkModeEnabled }; try {localStorage.setItem(STORAGE_KEY,JSON.stringify(settings)); console.log('‚úì Settings saved');}catch (e) {console.warn('Could not save settings:',e);}}function loadSettings() {try {const saved = localStorage.getItem(STORAGE_KEY); if (saved) {const settings = JSON.parse(saved); if (settings.currentMode) currentMode = settings.currentMode; if (settings.gravityMultiplierPit !== undefined) gravityMultiplierPit = settings.gravityMultiplierPit; if (settings.repellerEnabledPit !== undefined) repellerEnabledPit = settings.repellerEnabledPit; if (settings.attractionPower) attractionPower = settings.attractionPower; if (settings.orbitRadius) orbitRadius = settings.orbitRadius; if (settings.swarmSpeed) swarmSpeed = settings.swarmSpeed; if (settings.weightlessInitialSpeed) weightlessInitialSpeed = settings.weightlessInitialSpeed; if (settings.weightlessBounce) weightlessBounce = settings.weightlessBounce; if (settings.weightlessCount) weightlessCount = settings.weightlessCount; if (settings.weightlessRepellerPower !== undefined) weightlessRepellerPower = settings.weightlessRepellerPower; if (settings.weightlessRepellerRadius !== undefined) weightlessRepellerRadius = settings.weightlessRepellerRadius; if (settings.restitution) REST = settings.restitution; if (settings.friction !== undefined) FRICTION = settings.friction; if (settings.sizeScale) sizeScale = settings.sizeScale; if (settings.sizeVariation !== undefined) sizeVariation = settings.sizeVariation; if (settings.ballMassKg) ballMassKg = settings.ballMassKg; if (settings.repelPower) repelPower = settings.repelPower; if (settings.repelRadius) repelRadius = settings.repelRadius; if (settings.repelSoft) repelSoft = settings.repelSoft; if (settings.cornerRadius !== undefined) cornerRadius = settings.cornerRadius; if (settings.motionBlur !== undefined) trailFade = settings.motionBlur; if (settings.trailSubtlety) trailSubtlety = settings.trailSubtlety; if (settings.currentTemplate) currentTemplate = settings.currentTemplate; if (settings.cursorBallColor) cursorBallColor = settings.cursorBallColor; if (settings.gridColumns !== undefined) gridColumns = settings.gridColumns; if (settings.gridBallCount !== undefined) gridBallCount = settings.gridBallCount; if (settings.pulseInterval !== undefined) pulseInterval = settings.pulseInterval; if (settings.pulseSpeed !== undefined) pulseSpeed = settings.pulseSpeed; if (settings.pulseSynchronicity !== undefined) pulseSynchronicity = settings.pulseSynchronicity; if (settings.pulseRandomness !== undefined) pulseRandomness = settings.pulseRandomness; if (settings.pulseMinSteps !== undefined) pulseMinSteps = settings.pulseMinSteps; if (settings.pulseMaxSteps !== undefined) pulseMaxSteps = settings.pulseMaxSteps; if (settings.pulseEasingStyle) pulseEasingStyle = settings.pulseEasingStyle; if (settings.pulseOvershoot !== undefined) pulseOvershoot = settings.pulseOvershoot; if (settings.pulseBounceIntensity !== undefined) pulseBounceIntensity = settings.pulseBounceIntensity; if (settings.canvasShadowEnabled !== undefined) canvasShadowEnabled = settings.canvasShadowEnabled; if (settings.shadowOffsetX !== undefined) shadowOffsetX = settings.shadowOffsetX; if (settings.shadowOffsetY !== undefined) shadowOffsetY = settings.shadowOffsetY; if (settings.shadowBlur !== undefined) shadowBlur = settings.shadowBlur; if (settings.shadowOpacity !== undefined) shadowOpacity = settings.shadowOpacity; if (settings.shadowColor) shadowColor = settings.shadowColor; if (settings.shadow2Enabled !== undefined) shadow2Enabled = settings.shadow2Enabled; if (settings.shadow2Blur !== undefined) shadow2Blur = settings.shadow2Blur; if (settings.shadow2Opacity !== undefined) shadow2Opacity = settings.shadow2Opacity; if (settings.autoDarkModeEnabled !== undefined) autoDarkModeEnabled = settings.autoDarkModeEnabled; console.log('‚úì Settings loaded'); return true;}}catch (e) {console.warn('Could not load settings:',e);}return false;}function autoSaveSettings() {clearTimeout(window.settingsSaveTimeout); window.settingsSaveTimeout = setTimeout(saveSettings,500);}const REPEL_BASE_POWER = 12000; const REPEL_SLIDER_MAX = 10000; const REPEL_CENTER_MULTIPLIER = 2.0; const REPEL_N_OCTAVES = 12; function repelSliderToPower(sliderValue) {const s = Math.max(0,Math.min(REPEL_SLIDER_MAX,Number(sliderValue))) / REPEL_SLIDER_MAX; const mult = REPEL_CENTER_MULTIPLIER * Math.pow(2,(s - 0.5) * REPEL_N_OCTAVES); return REPEL_BASE_POWER * mult;}function powerToRepelSlider(power) {const safe = Math.max(1,Number(power)); const x = safe / (REPEL_BASE_POWER * REPEL_CENTER_MULTIPLIER); const s = 0.5 + (Math.log2(x) / REPEL_N_OCTAVES); return Math.round(Math.max(0,Math.min(1,s)) * REPEL_SLIDER_MAX);}let highRefreshMode = true; let cornerRadius = 0; const TEXT_SELECTOR = '#hero-text'; let textColliders = []; let motionBlurFade = 0.025; let trailSubtlety = 1.80; let renderFrameCount = 0; let physicsStepCount = 0; let lastFPSTime = 0; let currentRenderFPS = 0; let currentPhysicsFPS = 0; const renderFpsElement = document.getElementById('render-fps'); const physicsFpsElement = document.getElementById('physics-fps'); let adaptiveQualityEnabled = true; let currentCollisionIters = 2; let lastQualityCheck = 0; const QUALITY_CHECK_INTERVAL = 2.0; function updateAdaptiveQuality(now) {if (!adaptiveQualityEnabled) return; if (now - lastQualityCheck < QUALITY_CHECK_INTERVAL) return; lastQualityCheck = now; if (currentRenderFPS < 50) {currentCollisionIters = 1; console.log('‚ö° Adaptive Quality: LOW (1 collision iter) - FPS:',currentRenderFPS);}else if (currentRenderFPS < 70) {currentCollisionIters = 2; console.log('‚ö° Adaptive Quality: MEDIUM (2 collision iters) - FPS:',currentRenderFPS);}else {currentCollisionIters = 3; console.log('‚ö° Adaptive Quality: HIGH (3 collision iters) - FPS:',currentRenderFPS);}}class Ball {constructor(x,y,r,color) {this.x = x; this.y = y; this.vx = (Math.random()*2 - 1) * 200; this.vy = -Math.random()*200; this.r = r; this.rBase = r; this.m = ballMassKg; this.color = color; this.t = 0; this.age = 0; this.driftAx = 0; this.driftTime = 0; this.omega = 0; this.squash = 1.0; this.squashDirX = 1; this.squashDirY = 0; this.theta = 0; this.squashAmount = 0.0; this.squashNormalAngle = 0.0; this.alpha = 1.0;}step(dt) {this.t += dt; this.age += dt; if (currentMode !== MODES.WEIGHTLESS) {this.vy += (G * gravityScale) * dt;}const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); const dragAmount = (currentMode === MODES.WEIGHTLESS) ? 0.0001 : FRICTION; const drag = Math.max(0,1 - (dragAmount / massScale)); this.vx *= drag; this.vy *= drag; if (this.driftAx !== 0 && this.age < this.driftTime) {this.vx += (this.driftAx * dt) / massScale;}else if (this.driftAx !== 0) {this.driftAx = 0;}applyExternalForces(this,dt); this.x += this.vx * dt; this.y += this.vy * dt; const spinDamp = Math.max(0,1 - CONSTANTS.SPIN_DAMP_PER_S * dt); this.omega *= spinDamp; this.theta += this.omega * dt; if (this.theta > Math.PI) this.theta -= Math.PI * 2; else if (this.theta < -Math.PI) this.theta += Math.PI * 2; const decay = Math.min(1,CONSTANTS.SQUASH_DECAY_PER_S * dt); this.squashAmount += (0 - this.squashAmount) * decay; this.squash = 1 - this.squashAmount;}walls(w,h,dt,customRest = REST) {const rest = customRest; if (cornerRadius === 0) {if (this.y + this.r > h) {this.y = h - this.r; const preVy = this.vy; const slip = this.vx - this.omega * this.r; const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); this.omega += (slip / this.r) * CONSTANTS.SPIN_GAIN / massScale; const rollDamp = Math.max(0,1 - CONSTANTS.ROLL_FRICTION_PER_S * dt / massScale); this.vx *= rollDamp; const wallRest = Math.abs(preVy) < CONSTANTS.WALL_REST_VEL_THRESHOLD ? 0 : rest; this.vy = -this.vy * (wallRest * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP)); const impact = Math.min(1,Math.abs(preVy) / (this.r * 90)); this.squashAmount = Math.min(getSquashMax(),impact * 0.8); this.squash = 1 - this.squashAmount; this.squashNormalAngle = -Math.PI / 2; const rollTarget = this.vx / this.r; this.omega += (rollTarget - this.omega) * Math.min(1,CONSTANTS.GROUND_COUPLING_PER_S * dt);}const viewportTop = (currentMode === MODES.PIT) ? (h / 3) : 0; if (this.y - this.r < viewportTop) {this.y = viewportTop + this.r; const preVy = this.vy; this.vy = -this.vy * rest; const impact = Math.min(1,Math.abs(preVy) / (this.r * 90)); this.squashAmount = Math.min(getSquashMax(),impact * 0.8); this.squash = 1 - this.squashAmount; this.squashNormalAngle = Math.PI / 2;}if (this.x + this.r > w) {this.x = w - this.r; {const slip = this.vy - this.omega * this.r; const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;}this.vx = -this.vx * rest; const impact = Math.min(1,Math.abs(this.vx) / (this.r * 90)); this.squashAmount = Math.min(getSquashMax(),impact * 0.8); this.squash = 1 - this.squashAmount; this.squashNormalAngle = Math.PI;}if (this.x - this.r < 0) {this.x = this.r; {const slip = this.vy - this.omega * this.r; const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;}this.vx = -this.vx * rest; const impact = Math.min(1,Math.abs(this.vx) / (this.r * 90)); this.squashAmount = Math.min(getSquashMax(),impact * 0.8); this.squash = 1 - this.squashAmount; this.squashNormalAngle = 0;}}else {this.handleRoundedWallCollision(w,h);}this.checkTextCollisions(dt);}checkTextCollisions(dt) {for (let i = 0; i < textColliders.length; i++) {const rect = textColliders[i]; const closestX = Math.max(rect.x,Math.min(this.x,rect.x + rect.width)); const closestY = Math.max(rect.y,Math.min(this.y,rect.y + rect.height)); const dx = this.x - closestX; const dy = this.y - closestY; const distance = Math.sqrt(dx * dx + dy * dy); if (distance < this.r) {if (distance === 0) {const distToLeft = this.x - rect.x; const distToRight = (rect.x + rect.width) - this.x; const distToTop = this.y - rect.y; const distToBottom = (rect.y + rect.height) - this.y; const minDist = Math.min(distToLeft,distToRight,distToTop,distToBottom); if (minDist === distToLeft) {this.x = rect.x - this.r; this.vx = -Math.abs(this.vx) * REST;}else if (minDist === distToRight) {this.x = rect.x + rect.width + this.r; this.vx = Math.abs(this.vx) * REST;}else if (minDist === distToTop) {this.y = rect.y - this.r; this.vy = -Math.abs(this.vy) * REST;}else {this.y = rect.y + rect.height + this.r; this.vy = Math.abs(this.vy) * REST;}}else {const overlap = this.r - distance; const nx = dx / distance; const ny = dy / distance; this.x += nx * overlap; this.y += ny * overlap; const dotProduct = this.vx * nx + this.vy * ny; if (dotProduct < 0) {this.vx -= 2 * dotProduct * nx * REST; this.vy -= 2 * dotProduct * ny * REST; const impact = Math.min(1,Math.abs(dotProduct) / (this.r * 70)); this.squash = 1 - getSquashMax() * impact; this.squashDirX = Math.abs(nx) > Math.abs(ny) ? 1 : 0; this.squashDirY = Math.abs(ny) > Math.abs(nx) ? 1 : 0;}}}}}handleRoundedWallCollision(w,h) {const r = cornerRadius; const corners = [ {x: r,y: r },{x: w - r,y: r },{x: w - r,y: h - r },{x: r,y: h - r }]; for (let i = 0; i < corners.length; i++) {const corner = corners[i]; const dx = this.x - corner.x; const dy = this.y - corner.y; const dist = Math.sqrt(dx * dx + dy * dy); const inCornerRegion = this.isInCornerRegion(corner,w,h,r); if (inCornerRegion && dist + this.r > r) {const overlap = r - (dist - this.r); if (overlap > 0 && dist > 0) {const nx = dx / dist; const ny = dy / dist; this.x += nx * overlap; this.y += ny * overlap; const dot = this.vx * nx + this.vy * ny; this.vx -= 2 * dot * nx * REST; this.vy -= 2 * dot * ny * REST; const impact = Math.min(1,Math.abs(dot) / (this.r * 90)); this.squashAmount = Math.min(getSquashMax(),impact * 0.8); this.squash = 1 - this.squashAmount; this.squashNormalAngle = Math.atan2(ny,nx);}}}if (this.y + this.r > h && (this.x < r || this.x > w - r)) {this.y = h - this.r; this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP));}if (this.y - this.r < 0 && (this.x < r || this.x > w - r)) {this.y = this.r; this.vy = -this.vy * REST;}if (this.x + this.r > w && (this.y < r || this.y > h - r)) {this.x = w - this.r; {const slip = this.vy - this.omega * this.r; const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;}this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP)); const impact = Math.min(1,Math.abs(this.vx)/(this.r*70)); this.squashAmount = Math.min(getSquashMax(),impact); this.squash = 1 - this.squashAmount; this.squashNormalAngle = Math.PI;}if (this.x - this.r < 0 && (this.y < r || this.y > h - r)) {this.x = this.r; {const slip = this.vy - this.omega * this.r; const massScale = Math.max(0.25,this.m / MASS_BASELINE_KG); this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;}this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP)); const impact = Math.min(1,Math.abs(this.vx)/(this.r*70)); this.squashAmount = Math.min(getSquashMax(),impact); this.squash = 1 - this.squashAmount; this.squashNormalAngle = 0;}if (this.y + this.r > h && this.x >= r && this.x <= w - r) {this.y = h - this.r; this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP));}if (this.y - this.r < 0 && this.x >= r && this.x <= w - r) {this.y = this.r; this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP));}if (this.x + this.r > w && this.y >= r && this.y <= h - r) {this.x = w - this.r; this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP));}if (this.x - this.r < 0 && this.y >= r && this.y <= h - r) {this.x = this.r; this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m,MASS_REST_EXP));}}isInCornerRegion(corner,w,h,r) {if (corner.x === r && corner.y === r) {return this.x <= r && this.y <= r;}if (corner.x === w - r && corner.y === r) {return this.x >= w - r && this.y <= r;}if (corner.x === w - r && corner.y === h - r) {return this.x >= w - r && this.y >= h - r;}if (corner.x === r && corner.y === h - r) {return this.x <= r && this.y >= h - r;}return false;}draw(ctx) {ctx.save(); ctx.translate(this.x,this.y); const amt = Math.min(getSquashMax(),Math.max(0,this.squashAmount)); if (this.r > 15 && amt > 0.001) {const s = 1 + amt; const inv = 1 / s; ctx.rotate(this.squashNormalAngle); ctx.scale(s,inv); ctx.rotate(-this.squashNormalAngle);}ctx.beginPath(); ctx.arc(0,0,this.r,0,Math.PI*2); ctx.fillStyle = this.color; ctx.fill(); ctx.restore();}}const balls = []; function clamp(v,lo,hi) {return Math.max(lo,Math.min(hi,v));}function randBetween(a,b) {return a + Math.random() * (b - a);}function drawRoundedBoundary(ctx,w,h) {const r = cornerRadius; ctx.strokeStyle = 'rgba(255,255,255,0.1)'; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(r,0); ctx.lineTo(w - r,0); ctx.arcTo(w,0,w,r,r); ctx.lineTo(w,h - r); ctx.arcTo(w,h,w - r,h,r); ctx.lineTo(r,h); ctx.arcTo(0,h,0,h - r,r); ctx.lineTo(0,r); ctx.arcTo(0,0,r,0,r); ctx.closePath(); ctx.stroke();}function spawnBall(x,y,color = pickRandomColor()) {const baseSize = (R_MIN + R_MAX) / 2; let r; if (sizeVariation === 0) {r = baseSize;}else {const maxVariation = baseSize * 0.1; const minR = Math.max(1,baseSize - maxVariation); const maxR = baseSize + maxVariation; r = randBetween(minR,maxR);}const ball = new Ball(x,y,r,color); const centerX = canvas.width * 0.5; const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((x < centerX) ? 1 : -1); const sizeInfluence = clamp((r / ((R_MIN + R_MAX) * 0.5)),0.6,1.4); const baseKick = 140 * sizeInfluence; const randKick = 180 * sizeInfluence; const upwardKick = 120; ball.vx = dir * (baseKick + Math.random() * randKick); ball.vy = -Math.random() * upwardKick; ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence; ball.driftTime = 0.22 + Math.random() * 0.28; balls.push(ball); return ball;}let emitterTimer = 0; function pickSpawnPoint() {const wCss = canvas.clientWidth; const hCss = canvas.clientHeight; const widthCss = clamp((SPAWN_W_VW / 100) * wCss,0,wCss); let xCenterCss = clamp((SPAWN_X_CENTER_VW / 100) * wCss,0,wCss); if (EMITTER_SWEEP_ENABLED) {const amplPx = (EMITTER_SWEEP_AMPL_VW / 100) * wCss; const sweepOffset = Math.sin(emitterPhase) * amplPx; const prevX = xCenterCss; xCenterCss = clamp(xCenterCss + sweepOffset,0,wCss); emitterSweepDir = (xCenterCss >= prevX) ? 1 : -1;}const offX = Math.min(40,widthCss * 0.1); const xLeftCss = clamp(xCenterCss - widthCss / 2 - offX,-offX,wCss); const xRightCss = clamp(xCenterCss + widthCss / 2 + offX,-offX,wCss); const yTopCss = (SPAWN_Y_VH / 100) * hCss; const yBotCss = yTopCss + (SPAWN_H_VH / 100) * hCss; const bias = 0.3; const u = Math.random(); const biased = bias > 0 ? (emitterSweepDir > 0 ? Math.pow(u,1 - bias) : 1 - Math.pow(1 - u,1 - bias)) : u; const x = (xLeftCss + (xRightCss - xLeftCss) * biased) * DPR; const y = randBetween(yTopCss * DPR,yBotCss * DPR) - (R_MAX + CONSTANTS.BALL_SPAWN_OFFSET + randBetween(0,10 * DPR)); return {x,y };}function emit(dt) {if (currentMode === MODES.WEIGHTLESS || currentMode === MODES.PULSE_GRID) {return;}emitterTimer += dt; while (emitterTimer >= EMIT_INTERVAL) {const jitter = (Math.random() - 0.5) * EMIT_INTERVAL * 0.5; emitterTimer -= (EMIT_INTERVAL + jitter); emitterPhase += (2 * Math.PI) * EMITTER_SWEEP_HZ * (EMIT_INTERVAL + jitter); const p = pickSpawnPoint(); const drops = (Math.random() < 0.35 ? 3 : 1); for (let i=0; i<drops; i++) {if (balls.length < MAX_BALLS) {const xOffset = i * CONSTANTS.BALL_CLUSTER_SPACING * (Math.random() < 0.5 ? 1 : -1); spawnBall(p.x + xOffset,p.y - i * CONSTANTS.BALL_CLUSTER_Y_OFFSET);}}}}const spatialGrid = new Map(); function collectPairsSorted() {const n = balls.length; if (n < 2) return []; const cellSize = Math.max(1,R_MAX * 2); const gridWidth = Math.ceil(canvas.width / cellSize) + 1; spatialGrid.clear(); for (let i = 0; i < n; i++) {const b = balls[i]; const cx = (b.x / cellSize) | 0; const cy = (b.y / cellSize) | 0; const key = cy * gridWidth + cx; let arr = spatialGrid.get(key); if (!arr) {arr = []; spatialGrid.set(key,arr);}arr.push(i);}const pairs = []; for (const [key,arr] of spatialGrid) {const cy = (key / gridWidth) | 0; const cx = key % gridWidth; for (let oy = -1; oy <= 1; oy++) {for (let ox = -1; ox <= 1; ox++) {const neighborKey = (cy + oy) * gridWidth + (cx + ox); const nb = spatialGrid.get(neighborKey); if (!nb) continue; for (let ii = 0; ii < arr.length; ii++) {const i = arr[ii]; for (let jj = 0; jj < nb.length; jj++) {const j = nb[jj]; if (j <= i) continue; const A = balls[i],B = balls[j]; const dx = B.x - A.x,dy = B.y - A.y; const rSum = A.r + B.r; const dist2 = dx*dx + dy*dy; if (dist2 < rSum*rSum) {const dist = Math.sqrt(Math.max(dist2,CONSTANTS.MIN_DISTANCE_EPSILON)); const overlap = rSum - dist; pairs.push({i,j,overlap });}}}}}}pairs.sort((a,b) => b.overlap - a.overlap); return pairs;}function resolveCollisions(iterations = SOLVER_ITERS) {const pairs = collectPairsSorted(); for (let iter = 0; iter < iterations; iter++) {for (let k = 0; k < pairs.length; k++) {const {i,j }= pairs[k]; const A = balls[i]; const B = balls[j]; const dx = B.x - A.x; const dy = B.y - A.y; const rSum = A.r + B.r; const dist2 = dx * dx + dy * dy; if (dist2 === 0 || dist2 > rSum * rSum) continue; const dist = Math.sqrt(dist2); const nx = dx / dist; const ny = dy / dist; const overlap = rSum - dist; const invA = 1 / Math.max(A.m,0.001); const invB = 1 / Math.max(B.m,0.001); const correctionMag = POS_CORRECT_PERCENT * Math.max(overlap - POS_CORRECT_SLOP,0) / (invA + invB); const cx = correctionMag * nx; const cy = correctionMag * ny; A.x -= cx * invA; A.y -= cy * invA; B.x += cx * invB; B.y += cy * invB; const rvx = B.vx - A.vx; const rvy = B.vy - A.vy; const velAlongNormal = rvx * nx + rvy * ny; if (velAlongNormal < 0) {const e = Math.abs(velAlongNormal) < REST_VEL_THRESHOLD ? 0 : REST; const j = -(1 + e) * velAlongNormal / (invA + invB); const ix = j * nx; const iy = j * ny; A.vx -= ix * invA; A.vy -= iy * invA; B.vx += ix * invB; B.vy += iy * invB; const tvx = rvx - velAlongNormal * nx; const tvy = rvy - velAlongNormal * ny; const slipMag = Math.hypot(tvx,tvy); if (slipMag > 1e-3) {const tangentSign = (tvx * -ny + tvy * nx) >= 0 ? 1 : -1; const gain = CONSTANTS.SPIN_GAIN_TANGENT; A.omega -= tangentSign * gain * slipMag / Math.max(A.r,1); B.omega += tangentSign * gain * slipMag / Math.max(B.r,1);}const impact = Math.min(1,Math.abs(velAlongNormal) / ((A.r + B.r) * 50)); const sAmt = Math.min(getSquashMax(),impact * 0.8); A.squashAmount = Math.max(A.squashAmount,sAmt * 0.8); A.squashNormalAngle = Math.atan2(-ny,-nx); B.squashAmount = Math.max(B.squashAmount,sAmt * 0.8); B.squashNormalAngle = Math.atan2(ny,nx);}}}}let last = performance.now() / 1000; let acc = 0; const DT = 1/120; function frame(nowMs) {const now = nowMs / 1000; let dt = Math.min(0.008,now - last); last = now; acc += dt; renderFrameCount++; if ((renderFpsElement || physicsFpsElement) && now - lastFPSTime >= CONSTANTS.FPS_UPDATE_INTERVAL) {if (renderFpsElement && renderFrameCount !== currentRenderFPS) {currentRenderFPS = renderFrameCount; renderFpsElement.textContent = currentRenderFPS.toString();}if (physicsFpsElement && physicsStepCount !== currentPhysicsFPS) {currentPhysicsFPS = physicsStepCount; physicsFpsElement.textContent = currentPhysicsFPS.toString();}renderFrameCount = 0; physicsStepCount = 0; lastFPSTime = now; updateAdaptiveQuality(now);}emit(dt); if (currentMode === MODES.PULSE_GRID) {updatePulseGrid(dt);}if (renderFrameCount % 60 === 0) {updateTextColliders();}let physicsSteps = 0; while (acc >= DT && physicsSteps < CONSTANTS.MAX_PHYSICS_STEPS) {if (currentMode !== MODES.PULSE_GRID) {for (let i=0; i<balls.length; i++) balls[i].step(DT);}if (currentMode !== MODES.FLIES && currentMode !== MODES.PULSE_GRID) {resolveCollisions(currentCollisionIters);}if (currentMode !== MODES.PULSE_GRID) {const wallRestitution = (currentMode === MODES.WEIGHTLESS) ? weightlessBounce : REST; for (let i=0; i<balls.length; i++) balls[i].walls(canvas.width,canvas.height,DT,wallRestitution);}acc -= DT; physicsSteps++; physicsStepCount++;}if (acc > DT * CONSTANTS.ACCUMULATOR_RESET_THRESHOLD) acc = 0; ctx.clearRect(0,0,canvas.width,canvas.height); if (cornerRadius > 0) {drawRoundedBoundary(ctx,canvas.width,canvas.height);}for (let i=0; i<balls.length; i++) balls[i].draw(ctx); drawCursorBall(ctx); if (!isTouchDevice) {ctx.save(); ctx.font = '14px system-ui,-apple-system,sans-serif'; ctx.fillStyle = 'rgba(255,255,255,0.3)'; ctx.textAlign = 'left'; ctx.textBaseline = 'bottom'; const modeName = currentMode.charAt(0).toUpperCase() + currentMode.slice(1); ctx.fillText(modeName + ' Mode',10,canvas.height - 10); ctx.restore();}requestAnimationFrame(frame);}console.log('High refresh mode enabled - using requestAnimationFrame'); requestAnimationFrame(frame); function resetBallSizeToGlobal() {const globalScale = parseFloat(sizeSliderGlobal.value); sizeScale = globalScale; updateEffectiveScaleAndBallSizes(); const baseSize = (R_MIN + R_MAX) / 2; for (let i = 0; i < balls.length; i++) {if (sizeVariation === 0) {balls[i].r = baseSize; balls[i].rBase = baseSize;}else {const maxVariation = baseSize * 0.1; const minR = Math.max(1,baseSize - maxVariation); const maxR = baseSize + maxVariation; balls[i].r = randBetween(minR,maxR); balls[i].rBase = balls[i].r;}}}function resetBallsToSpawn() {if (currentMode === MODES.WEIGHTLESS) {initializeWeightlessScene();}else {for (let i = 0; i < balls.length; i++) {const ball = balls[i]; const p = pickSpawnPoint(); ball.x = p.x; ball.y = p.y; const centerX = canvas.width * 0.5; const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((ball.x < centerX) ? 1 : -1); const sizeInfluence = clamp((ball.r / ((R_MIN + R_MAX) * 0.5)),0.6,1.4); const baseKick = 140 * sizeInfluence; const randKick = 180 * sizeInfluence; const upwardKick = 120; ball.vx = dir * (baseKick + Math.random() * randKick); ball.vy = -Math.random() * upwardKick; ball.age = 0; ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence; ball.driftTime = 0.22 + Math.random() * 0.28;}}}const panelHeader = document.getElementById('panelHeader'); const minimizeBtn = document.getElementById('minimizePanel'); const PANEL_INITIALLY_VISIBLE = true; if (!PANEL_INITIALLY_VISIBLE && panel) {panel.classList.add('hidden');}if (minimizeBtn && panel) {minimizeBtn.addEventListener('click',(e) => {e.stopPropagation(); panel.classList.toggle('hidden');});}if (panelHeader && panel) {let isDragging = false; let currentX; let currentY; let initialX; let initialY; let xOffset = 0; let yOffset = 0; panelHeader.addEventListener('mousedown',dragStart); document.addEventListener('mousemove',drag); document.addEventListener('mouseup',dragEnd); panelHeader.addEventListener('touchstart',dragStart); document.addEventListener('touchmove',drag); document.addEventListener('touchend',dragEnd); function dragStart(e) {if (e.type === 'touchstart') {initialX = e.touches[0].clientX - xOffset; initialY = e.touches[0].clientY - yOffset;}else {initialX = e.clientX - xOffset; initialY = e.clientY - yOffset;}if (e.target === panelHeader || panelHeader.contains(e.target)) {isDragging = true; panel.style.cursor = 'grabbing';}}function drag(e) {if (isDragging) {e.preventDefault(); if (e.type === 'touchmove') {currentX = e.touches[0].clientX - initialX; currentY = e.touches[0].clientY - initialY;}else {currentX = e.clientX - initialX; currentY = e.clientY - initialY;}xOffset = currentX; yOffset = currentY; const rect = panel.getBoundingClientRect(); const computedStyle = window.getComputedStyle(panel); const initialTop = parseFloat(computedStyle.top) || 0; const initialRight = parseFloat(computedStyle.right) || 0; panel.style.top = `${initialTop + yOffset}px`; panel.style.right = `${initialRight - xOffset}px`; panel.style.left = 'auto'; panel.style.bottom = 'auto'; xOffset = 0; yOffset = 0; initialX = e.type === 'touchmove' ? e.touches[0].clientX : e.clientX; initialY = e.type === 'touchmove' ? e.touches[0].clientY : e.clientY;}}function dragEnd(e) {if (isDragging) {isDragging = false; panel.style.cursor = 'move'; initialX = currentX; initialY = currentY;}}}window.addEventListener('keydown',e => {const k = e.key.toLowerCase(); if (k === 'r') {resetBallsToSpawn(); e.preventDefault();}if (k === '/' && panel) {e.preventDefault(); panel.classList.toggle('hidden');}if (k === '1') setMode(MODES.PIT); if (k === '2') setMode(MODES.FLIES); if (k === '3') setMode(MODES.WEIGHTLESS); if (k === '4') setMode(MODES.PULSE_GRID);}); function seedArea(n = 160) {for (let i=0; i<n && balls.length < MAX_BALLS; i++) {const p = pickSpawnPoint(); spawnBall(p.x,p.y);}}seedArea(CONSTANTS.INITIAL_SEED_BALLS); let lastTrailRecordTime = 0; let lastMousePosition = {x: 0,y: 0 }; let mouseStoppedTime = 0; canvas.addEventListener('mousemove',(e) => {const rect = canvas.getBoundingClientRect(); mouseX = (e.clientX - rect.left) * DPR; mouseY = (e.clientY - rect.top) * DPR; if (currentMode === MODES.PIT && repelPower > 0 && repelRadius > 0) {repellerEnabled = true;}}); canvas.addEventListener('mouseleave',() => {mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE;}); function drawCursorBall(ctx) {if (isTouchDevice) return; if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return; const x = mouseX,y = mouseY; const baseSize = (R_MIN + R_MAX) / 2; const r = baseSize; const color = 'rgba(255,255,255,0.9)'; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI * 2); ctx.fillStyle = color; ctx.fill(); ctx.strokeStyle = 'rgba(255,255,255,0.6)'; ctx.lineWidth = 2; ctx.stroke();}function applyRepeller(b,dt) {if (!repellerEnabled) return; if (repelPower <= 0 || repelRadius <= 0) return; const rPx = repelRadius * DPR; const dx = b.x - mouseX; const dy = b.y - mouseY; const d2 = dx*dx + dy*dy; const r2 = rPx * rPx; if (d2 > r2) return; const d = Math.max(Math.sqrt(d2),CONSTANTS.MIN_REPEL_DISTANCE); const nx = dx / d; const ny = dy / d; const q = Math.max(0,1 - d / rPx); const strength = (repelPower * REPELLER_GLOBAL_MULTIPLIER) * Math.pow(q,repelSoft); const massScale = Math.max(0.25,b.m / MASS_BASELINE_KG); b.vx += (nx * strength * dt) / massScale; b.vy += (ny * strength * dt) / massScale; const turbulence = 10; b.vx += (Math.random() - 0.5) * turbulence * dt; b.vy += (Math.random() - 0.5) * turbulence * dt;}function applyExternalForces(b,dt) {if (currentMode === MODES.PIT) {applyRepeller(b,dt); return;}if (currentMode === MODES.FLIES) {applyAttractor(b,dt); return;}if (currentMode === MODES.WEIGHTLESS) {applyWeightlessRepeller(b,dt); return;}if (currentMode === MODES.PULSE_GRID) {return;}}function applyWeightlessRepeller(b,dt) {if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return; if (weightlessRepellerPower <= 0 || weightlessRepellerRadius <= 0) return; const rPx = weightlessRepellerRadius * DPR; const dx = b.x - mouseX; const dy = b.y - mouseY; const d2 = dx*dx + dy*dy; const r2 = rPx * rPx; if (d2 > r2) return; const d = Math.max(Math.sqrt(d2),CONSTANTS.MIN_REPEL_DISTANCE); const nx = dx / d; const ny = dy / d; const q = Math.max(0,1 - d / rPx); const strength = weightlessRepellerPower * q; b.vx += nx * strength * dt; b.vy += ny * strength * dt;}function applyAttractor(b,dt) {const swarmCenterX = (mouseX === CONSTANTS.OFFSCREEN_MOUSE) ? canvas.width * 0.5 : mouseX; const swarmCenterY = (mouseY === CONSTANTS.OFFSCREEN_MOUSE) ? canvas.height * 0.5 : mouseY; const dx = swarmCenterX - b.x; const dy = swarmCenterY - b.y; const d2 = dx*dx + dy*dy; const d = Math.sqrt(d2 + 1); const dirX = dx / d; const dirY = dy / d; const attractForce = attractionPower * swarmSpeed * 2.0; b.vx += dirX * attractForce * dt; b.vy += dirY * attractForce * dt; const separationRadius = 120 * DPR; let sepX = 0,sepY = 0; let neighborCount = 0; for (let i = 0; i < balls.length; i++) {const other = balls[i]; if (other === b) continue; const dx2 = b.x - other.x; const dy2 = b.y - other.y; const d2_other = dx2*dx2 + dy2*dy2; if (d2_other < separationRadius * separationRadius && d2_other > 0) {const d_other = Math.sqrt(d2_other); const strength = 1 - (d_other / separationRadius); sepX += (dx2 / d_other) * strength; sepY += (dy2 / d_other) * strength; neighborCount++;}}if (neighborCount > 0) {const separationForce = 15000; b.vx += (sepX / neighborCount) * separationForce * dt; b.vy += (sepY / neighborCount) * separationForce * dt;}const jitterBase = 2500 * swarmSpeed; const burstChance = 0.08; if (Math.random() < burstChance) {const burstAngle = Math.random() * Math.PI * 2; const burstStrength = 1500 * swarmSpeed; b.vx += Math.cos(burstAngle) * burstStrength; b.vy += Math.sin(burstAngle) * burstStrength;}b.vx += (Math.random() - 0.5) * jitterBase * dt; b.vy += (Math.random() - 0.5) * jitterBase * dt; const orbitVariation = 0.3 + Math.random() * 2.0; const orbitStrength = swarmSpeed * 2000 * orbitVariation * dt; b.vx += -dirY * orbitStrength; b.vy += dirX * orbitStrength; const maxSpeed = 2200 * swarmSpeed; const speed = Math.sqrt(b.vx*b.vx + b.vy*b.vy); if (speed > maxSpeed) {b.vx = (b.vx / speed) * maxSpeed; b.vy = (b.vy / speed) * maxSpeed;}b.vx *= 0.995; b.vy *= 0.995;}const restitutionSlider = document.getElementById('restitutionSlider'); const frictionSlider = document.getElementById('frictionSlider'); const emitterSlider = document.getElementById('emitterSlider'); const sizeSliderGlobal = document.getElementById('sizeSliderGlobal'); const sizeVariationSliderGlobal = document.getElementById('sizeVariationSliderGlobal'); const weightSliderGlobal = document.getElementById('weightSliderGlobal'); const ballSoftnessSliderGlobal = document.getElementById('ballSoftnessSliderGlobal'); const sizeValGlobal = document.getElementById('sizeValGlobal'); const sizeVariationValGlobal = document.getElementById('sizeVariationValGlobal'); const weightValGlobal = document.getElementById('weightValGlobal'); const ballSoftnessValGlobal = document.getElementById('ballSoftnessValGlobal'); const sizeSliderPit = document.getElementById('sizeSliderPit'); const sizeVariationSliderPit = document.getElementById('sizeVariationSliderPit'); const weightSliderPit = document.getElementById('weightSliderPit'); const ballSoftnessSliderPit = document.getElementById('ballSoftnessSliderPit'); const sizeValPit = document.getElementById('sizeValPit'); const sizeVariationValPit = document.getElementById('sizeVariationValPit'); const weightValPit = document.getElementById('weightValPit'); const ballSoftnessValPit = document.getElementById('ballSoftnessValPit'); const sizeSliderFlies = document.getElementById('sizeSliderFlies'); const sizeVariationSliderFlies = document.getElementById('sizeVariationSliderFlies'); const weightSliderFlies = document.getElementById('weightSliderFlies'); const ballSoftnessSliderFlies = document.getElementById('ballSoftnessSliderFlies'); const sizeValFlies = document.getElementById('sizeValFlies'); const sizeVariationValFlies = document.getElementById('sizeVariationValFlies'); const weightValFlies = document.getElementById('weightValFlies'); const ballSoftnessValFlies = document.getElementById('ballSoftnessValFlies'); const sizeSliderZeroG = document.getElementById('sizeSliderZeroG'); const sizeVariationSliderZeroG = document.getElementById('sizeVariationSliderZeroG'); const weightSliderZeroG = document.getElementById('weightSliderZeroG'); const ballSoftnessSliderZeroG = document.getElementById('ballSoftnessSliderZeroG'); const sizeValZeroG = document.getElementById('sizeValZeroG'); const sizeVariationValZeroG = document.getElementById('sizeVariationValZeroG'); const weightValZeroG = document.getElementById('weightValZeroG'); const ballSoftnessValZeroG = document.getElementById('ballSoftnessValZeroG'); const maxBallsSlider = document.getElementById('maxBallsSlider'); const spawnYSlider = document.getElementById('spawnYSlider'); const spawnWidthSlider = document.getElementById('spawnWidthSlider'); const spawnCenterSlider = document.getElementById('spawnCenterSlider'); const spawnHeightSlider = document.getElementById('spawnHeightSlider'); const repelSizeSlider = document.getElementById('repelSizeSlider'); const repelPowerSlider = document.getElementById('repelPowerSlider'); const repelSoftSlider = document.getElementById('repelSoftSlider'); const colorSelect = document.getElementById('colorSelect'); const color1 = document.getElementById('color1'); const color2 = document.getElementById('color2'); const color3 = document.getElementById('color3'); const color4 = document.getElementById('color4'); const color5 = document.getElementById('color5'); const color6 = document.getElementById('color6'); const color7 = document.getElementById('color7'); const color8 = document.getElementById('color8'); const cursorColorSelect = document.getElementById('cursorColorSelect'); const color1Val = document.getElementById('color1Val'); const color2Val = document.getElementById('color2Val'); const color3Val = document.getElementById('color3Val'); const color4Val = document.getElementById('color4Val'); const color5Val = document.getElementById('color5Val'); const color6Val = document.getElementById('color6Val'); const color7Val = document.getElementById('color7Val'); const color8Val = document.getElementById('color8Val'); [color1Val,color2Val,color3Val,color4Val,color5Val,color6Val,color7Val,color8Val].forEach(el => {if (el) el.setAttribute('title','Click to copy');}); const cornerRadiusSlider = document.getElementById('cornerRadiusSlider'); const cornerRadiusVal = document.getElementById('cornerRadiusVal'); const motionBlurFadeSlider = document.getElementById('trailFadeSlider'); const motionBlurFadeVal = document.getElementById('trailFadeVal'); const trailSubtletySlider = document.getElementById('trailSubtletySlider'); const trailSubtletyVal = document.getElementById('trailSubtletyVal'); const restitutionVal = document.getElementById('restitutionVal'); const frictionVal = document.getElementById('frictionVal'); const emitterVal = document.getElementById('emitterVal'); const maxBallsVal = document.getElementById('maxBallsVal'); const spawnYVal = document.getElementById('spawnYVal'); const spawnWidthVal = document.getElementById('spawnWidthVal'); const spawnCenterVal = document.getElementById('spawnCenterVal'); const spawnHeightVal = document.getElementById('spawnHeightVal'); const repelSizeVal = document.getElementById('repelSizeVal'); const repelPowerVal = document.getElementById('repelPowerVal'); const repelSoftVal = document.getElementById('repelSoftVal'); function captureCurrentConfig() {return {gravityMultiplier,restitution: REST,friction: FRICTION,ballMass: ballMassKg,emitRate: EMIT_INTERVAL,maxBalls: MAX_BALLS,ballScale: sizeScale,ballVariation: sizeVariation,spawnX: SPAWN_X_CENTER_VW,spawnY: SPAWN_Y_VH,spawnWidth: SPAWN_W_VW,spawnHeight: SPAWN_H_VH,sweepEnabled: EMITTER_SWEEP_ENABLED,repelRadius,repelPower,repelSoftness: repelSoft,trailFade: motionBlurFade,trailSubtlety,colors: currentColors.slice(),colorWeights: COLOR_WEIGHTS.slice(),currentTemplate,cursorColorIndex: cursorBallIndex,performanceMode,targetFPS,enableLOD };}function generateConfigCode(config) {return ` }const saveConfigBtn = document.getElementById('saveConfigBtn'); const buildBtn = document.getElementById('buildBtn'); const configOutput = document.getElementById('configOutput'); if (saveConfigBtn && buildBtn && configOutput) {saveConfigBtn.addEventListener('click',() => {const config = captureCurrentConfig(); const code = generateConfigCode(config); configOutput.style.display = 'block'; configOutput.textContent = code; navigator.clipboard.writeText(code).then(() => {const old = saveConfigBtn.textContent; saveConfigBtn.textContent = '‚úÖ Copied!'; setTimeout(() => {saveConfigBtn.textContent = old;},1200);}).catch(() => {console.warn('Clipboard copy failed'); const old = saveConfigBtn.textContent; saveConfigBtn.textContent = '‚ö†Ô∏è Copy failed'; setTimeout(() => {saveConfigBtn.textContent = old;},1200);});}); buildBtn.addEventListener('click',() => {const config = captureCurrentConfig(); configOutput.style.display = 'block'; configOutput.innerHTML = ` <strong>üöÄ Build Instructions:</strong><br> 1. Run: <code>npm run build</code><br> 2. Your current config will be baked into <code>public/js/bouncy-balls-embed.js</code>`; const blob = new Blob([JSON.stringify(config,null,2)],{type: 'application/json' }); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'current-config.json'; a.click(); URL.revokeObjectURL(url);});}function bindCopyOnClick(el,getText) {if (!el) return; el.addEventListener('click',async () => {const text = typeof getText === 'function' ? getText() : String(getText || '').trim(); try {await navigator.clipboard.writeText(text); const old = el.textContent; el.textContent = 'COPIED'; el.style.color = '#3ddc84'; setTimeout(() => {el.textContent = old; el.style.color = '#888';},900);}catch (e) {console.warn('Clipboard unavailable');}});}restitutionSlider && restitutionSlider.addEventListener('input',() => {REST = parseFloat(restitutionSlider.value); restitutionVal && (restitutionVal.textContent = REST.toFixed(2)); autoSaveSettings();}); frictionSlider && frictionSlider.addEventListener('input',() => {FRICTION = parseFloat(frictionSlider.value); frictionVal && (frictionVal.textContent = FRICTION.toFixed(4)); autoSaveSettings();}); emitterSlider && emitterSlider.addEventListener('input',() => {EMIT_INTERVAL = parseFloat(emitterSlider.value); emitterVal && (emitterVal.textContent = EMIT_INTERVAL.toFixed(3)); autoSaveSettings();}); function bindBallProps(sliders) {if (!sliders) return; const {size,sizeVal,sizeVar,sizeVarVal,soft,softVal }= sliders; size && size.addEventListener('input',() => {const newScale = parseFloat(size.value); sizeVal && (sizeVal.textContent = newScale.toFixed(1)); sizeScale = newScale; updateEffectiveScaleAndBallSizes(); for (let i=0; i<balls.length; i++) {balls[i].m = ballMassKg;}autoSaveSettings();}); sizeVar && sizeVar.addEventListener('input',() => {const v = parseFloat(sizeVar.value); sizeVarVal && (sizeVarVal.textContent = v.toFixed(1)); sizeVariation = v; autoSaveSettings();}); soft && soft.addEventListener('input',() => {const s = parseInt(soft.value,10); softVal && (softVal.textContent = String(s)); ballSoftness = s; autoSaveSettings();});}bindBallProps({size: sizeSliderGlobal,sizeVal: sizeValGlobal,sizeVar: sizeVariationSliderGlobal,sizeVarVal: sizeVariationValGlobal,soft: ballSoftnessSliderGlobal,softVal: ballSoftnessValGlobal }); maxBallsSlider && maxBallsSlider.addEventListener('input',() => {MAX_BALLS = parseInt(maxBallsSlider.value,10); maxBallsVal && (maxBallsVal.textContent = MAX_BALLS.toString()); if (balls.length > MAX_BALLS) {balls.length = MAX_BALLS;}}); sizeVariationSliderGlobal && sizeVariationSliderGlobal.addEventListener('input',() => {sizeVariation = parseFloat(sizeVariationSliderGlobal.value); sizeVariationValGlobal && (sizeVariationValGlobal.textContent = sizeVariation.toFixed(1)); updateExistingBallSizes();}); const weightPitSlider = document.getElementById('weightPitSlider'); const weightPitVal = document.getElementById('weightPitVal'); const weightWeightlessSlider = document.getElementById('weightWeightlessSlider'); const weightWeightlessVal = document.getElementById('weightWeightlessVal'); function updateExistingBallSizes() {const baseSize = (R_MIN + R_MAX) / 2; for (let i = 0; i < balls.length; i++) {const ball = balls[i]; if (sizeVariation === 0) {ball.r = baseSize;}else {const maxVariation = baseSize * 0.1; const minR = Math.max(1,baseSize - maxVariation); const maxR = baseSize + maxVariation; ball.r = randBetween(minR,maxR);}ball.m = ballMassKg;}}spawnYSlider && spawnYSlider.addEventListener('input',() => {SPAWN_Y_VH = parseFloat(spawnYSlider.value); spawnYVal && (spawnYVal.textContent = SPAWN_Y_VH.toFixed(0)); setCSSSize(); resize();}); spawnWidthSlider && spawnWidthSlider.addEventListener('input',() => {SPAWN_W_VW = parseFloat(spawnWidthSlider.value); spawnWidthVal && (spawnWidthVal.textContent = SPAWN_W_VW.toFixed(0));}); spawnCenterSlider && spawnCenterSlider.addEventListener('input',() => {SPAWN_X_CENTER_VW = parseFloat(spawnCenterSlider.value); spawnCenterVal && (spawnCenterVal.textContent = SPAWN_X_CENTER_VW.toFixed(0));}); spawnHeightSlider && spawnHeightSlider.addEventListener('input',() => {SPAWN_H_VH = parseFloat(spawnHeightSlider.value); spawnHeightVal && (spawnHeightVal.textContent = SPAWN_H_VH.toFixed(0));}); repelSizeSlider && repelSizeSlider.addEventListener('input',() => {repelRadius = parseFloat(repelSizeSlider.value); repelSizeVal && (repelSizeVal.textContent = repelRadius.toFixed(0)); repellerEnabled = repellerEnabled || (repelPower > 0 && repelRadius > 0);}); repelPowerSlider && repelPowerSlider.addEventListener('input',() => {repelPower = repelSliderToPower(repelPowerSlider.value); if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString(); if (repellerSelect && repellerSelect.value !== 'off') {repellerEnabled = repelPower > 0 && repelRadius > 0;}}); repelSoftSlider && repelSoftSlider.addEventListener('input',() => {repelSoft = parseFloat(repelSoftSlider.value); repelSoftVal && (repelSoftVal.textContent = repelSoft.toFixed(1));}); const performanceModeToggleEl = document.getElementById('performanceModeToggle'); const performanceModeStatusEl = document.getElementById('performanceModeStatus'); performanceModeToggleEl && performanceModeToggleEl.addEventListener('change',() => {togglePerformanceMode();}); const darkModeToggleEl = document.getElementById('darkModeToggle'); const darkModeStatusEl = document.getElementById('darkModeStatus'); darkModeToggleEl && darkModeToggleEl.addEventListener('change',() => {toggleAutoDarkMode(); autoSaveSettings();}); const canvasShadowEnabledEl = document.getElementById('canvasShadowEnabled'); const shadowOffsetXEl = document.getElementById('shadowOffsetX'); const shadowOffsetXVal = document.getElementById('shadowOffsetXVal'); const shadowOffsetYEl = document.getElementById('shadowOffsetY'); const shadowOffsetYVal = document.getElementById('shadowOffsetYVal'); const shadowBlurEl = document.getElementById('shadowBlur'); const shadowBlurVal = document.getElementById('shadowBlurVal'); const shadowOpacityEl = document.getElementById('shadowOpacity'); const shadowOpacityVal = document.getElementById('shadowOpacityVal'); const shadowColorEl = document.getElementById('shadowColor'); const shadowColorVal = document.getElementById('shadowColorVal'); const shadow2EnabledEl = document.getElementById('shadow2Enabled'); const shadow2BlurEl = document.getElementById('shadow2Blur'); const shadow2BlurVal = document.getElementById('shadow2BlurVal'); const shadow2OpacityEl = document.getElementById('shadow2Opacity'); const shadow2OpacityVal = document.getElementById('shadow2OpacityVal'); canvasShadowEnabledEl && canvasShadowEnabledEl.addEventListener('change',() => {canvasShadowEnabled = canvasShadowEnabledEl.checked; updateCanvasShadow(); autoSaveSettings();}); shadowOffsetXEl && shadowOffsetXEl.addEventListener('input',() => {shadowOffsetX = parseInt(shadowOffsetXEl.value,10); shadowOffsetXVal && (shadowOffsetXVal.textContent = shadowOffsetX.toString()); updateCanvasShadow(); autoSaveSettings();}); shadowOffsetYEl && shadowOffsetYEl.addEventListener('input',() => {shadowOffsetY = parseInt(shadowOffsetYEl.value,10); shadowOffsetYVal && (shadowOffsetYVal.textContent = shadowOffsetY.toString()); updateCanvasShadow(); autoSaveSettings();}); shadowBlurEl && shadowBlurEl.addEventListener('input',() => {shadowBlur = parseInt(shadowBlurEl.value,10); shadowBlurVal && (shadowBlurVal.textContent = shadowBlur.toString()); updateCanvasShadow(); autoSaveSettings();}); shadowOpacityEl && shadowOpacityEl.addEventListener('input',() => {shadowOpacity = parseFloat(shadowOpacityEl.value); shadowOpacityVal && (shadowOpacityVal.textContent = shadowOpacity.toFixed(2)); updateCanvasShadow(); autoSaveSettings();}); shadowColorEl && shadowColorEl.addEventListener('input',() => {shadowColor = shadowColorEl.value; shadowColorVal && (shadowColorVal.textContent = shadowColor.toUpperCase()); updateCanvasShadow(); autoSaveSettings();}); shadow2EnabledEl && shadow2EnabledEl.addEventListener('change',() => {shadow2Enabled = shadow2EnabledEl.checked; updateCanvasShadow(); autoSaveSettings();}); shadow2BlurEl && shadow2BlurEl.addEventListener('input',() => {shadow2Blur = parseInt(shadow2BlurEl.value,10); shadow2BlurVal && (shadow2BlurVal.textContent = shadow2Blur.toString()); updateCanvasShadow(); autoSaveSettings();}); shadow2OpacityEl && shadow2OpacityEl.addEventListener('input',() => {shadow2Opacity = parseFloat(shadow2OpacityEl.value); shadow2OpacityVal && (shadow2OpacityVal.textContent = shadow2Opacity.toFixed(2)); updateCanvasShadow(); autoSaveSettings();}); canvas.addEventListener('mousemove',(e) => {const rect = canvas.getBoundingClientRect(); mouseX = (e.clientX - rect.left) * DPR; mouseY = (e.clientY - rect.top) * DPR;}); canvas.addEventListener('mouseleave',() => {mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE;}); colorSelect && colorSelect.addEventListener('change',() => {applyColorTemplate(colorSelect.value);}); const modeButtons = Array.from(document.querySelectorAll('.mode-button')); const pitControls = document.getElementById('pitControls'); const fliesControls = document.getElementById('fliesControls'); const weightlessControls = document.getElementById('weightlessControls'); const gravityPitSlider = document.getElementById('gravityPitSlider'); const gravityPitVal = document.getElementById('gravityPitVal'); const repellerEnabledPitEl = document.getElementById('repellerEnabledPit'); const attractPowerSlider = document.getElementById('attractPowerSlider'); const attractPowerVal = document.getElementById('attractPowerVal'); const orbitRadiusSlider = document.getElementById('orbitRadiusSlider'); const orbitRadiusVal = document.getElementById('orbitRadiusVal'); const swarmSpeedSlider = document.getElementById('swarmSpeedSlider'); const swarmSpeedVal = document.getElementById('swarmSpeedVal'); const weightlessCountSlider = document.getElementById('weightlessCountSlider'); const weightlessCountVal = document.getElementById('weightlessCountVal'); const weightlessSpeedSlider = document.getElementById('weightlessSpeedSlider'); const weightlessSpeedVal = document.getElementById('weightlessSpeedVal'); const weightlessBounceSlider = document.getElementById('weightlessBounceSlider'); const weightlessBounceVal = document.getElementById('weightlessBounceVal'); const weightlessRepelSlider = document.getElementById('weightlessRepelSlider'); const weightlessRepelVal = document.getElementById('weightlessRepelVal'); const weightlessRepelRadiusSlider = document.getElementById('weightlessRepelRadiusSlider'); const weightlessRepelRadiusVal = document.getElementById('weightlessRepelRadiusVal'); function initializeFliesScene() {balls.length = 0; const targetBalls = 60; const w = canvas.width; const h = canvas.height; const centerX = w * 0.5; const centerY = h * 0.5; const swarmRadius = 150 * DPR; for (let i = 0; i < targetBalls; i++) {const angle = Math.random() * Math.PI * 2; const distance = Math.random() * swarmRadius; const x = centerX + Math.cos(angle) * distance; const y = centerY + Math.sin(angle) * distance; const ball = spawnBall(x,y); const speedVariation = 0.5 + Math.random() * 0.5; const vAngle = Math.random() * Math.PI * 2; const speed = 300 * speedVariation; ball.vx = Math.cos(vAngle) * speed; ball.vy = Math.sin(vAngle) * speed; ball.driftAx = 0; ball.driftTime = 0;}}function initializeWeightlessScene() {balls.length = 0; const targetBalls = weightlessCount; const w = canvas.width; const h = canvas.height; const margin = 40 * DPR; for (let i = 0; i < targetBalls; i++) {const x = margin + Math.random() * (w - 2 * margin); const y = margin + Math.random() * (h - 2 * margin); const ball = spawnBall(x,y); const angle = Math.random() * Math.PI * 2; const speed = weightlessInitialSpeed * (0.7 + Math.random() * 0.3); ball.vx = Math.cos(angle) * speed; ball.vy = Math.sin(angle) * speed; ball.driftAx = 0; ball.driftTime = 0;}}let gridCellSize = 0; let gridRows = 0; let gridCols = 0; let gridOffsetX = 0; let gridOffsetY = 0; function calculateGridDimensions() {const w = canvas.width; const h = canvas.height; gridCols = gridColumns; gridCellSize = w / gridCols; gridRows = Math.floor(h / gridCellSize); gridOffsetX = (w - (gridCols * gridCellSize)) / 2; gridOffsetY = (h - (gridRows * gridCellSize)) / 2;}function gridCellToPixel(gridX,gridY) {return {x: gridOffsetX + (gridX + 0.5) * gridCellSize,y: gridOffsetY + (gridY + 0.5) * gridCellSize };}function initializePulseGridScene() {balls.length = 0; calculateGridDimensions(); const maxCells = gridCols * gridRows; const targetBalls = Math.min(gridBallCount,maxCells); const allCells = []; for (let row = 0; row < gridRows; row++) {for (let col = 0; col < gridCols; col++) {allCells.push({gridX: col,gridY: row });}}for (let i = allCells.length - 1; i > 0; i--) {const j = Math.floor(Math.random() * (i + 1)); [allCells[i],allCells[j]] = [allCells[j],allCells[i]];}for (let i = 0; i < targetBalls; i++) {const cell = allCells[i]; const pos = gridCellToPixel(cell.gridX,cell.gridY); const ball = spawnBall(pos.x,pos.y); ball.gridX = cell.gridX; ball.gridY = cell.gridY; ball.targetX = pos.x; ball.targetY = pos.y; ball.jumpProgress = 1.0; ball.vx = 0; ball.vy = 0; ball.driftAx = 0; ball.driftTime = 0; const baseDelay = pulseInterval; const phaseOffset = pulseSynchronicity * Math.random() * baseDelay; ball.nextJumpTime = baseDelay + phaseOffset;}}function updatePulseGrid(dt) {for (let i = 0; i < balls.length; i++) {const ball = balls[i]; ball.nextJumpTime -= dt; if (ball.nextJumpTime <= 0 && ball.jumpProgress >= 1.0) {const directions = [ {dx: 0,dy: -1 },{dx: 0,dy: 1 },{dx: -1,dy: 0 },{dx: 1,dy: 0 }]; const dir = directions[Math.floor(Math.random() * directions.length)]; const stepRange = pulseMaxSteps - pulseMinSteps + 1; const steps = pulseMinSteps + Math.floor(Math.random() * stepRange); const randomizedSteps = Math.max(1,Math.round(steps * (1 - pulseRandomness * 0.5 + pulseRandomness * Math.random()))); let newGridX = ball.gridX + dir.dx * randomizedSteps; let newGridY = ball.gridY + dir.dy * randomizedSteps; newGridX = Math.max(0,Math.min(gridCols - 1,newGridX)); newGridY = Math.max(0,Math.min(gridRows - 1,newGridY)); ball.gridX = newGridX; ball.gridY = newGridY; const newPos = gridCellToPixel(newGridX,newGridY); ball.targetX = newPos.x; ball.targetY = newPos.y; ball.jumpProgress = 0.0; ball.jumpStartX = ball.x; ball.jumpStartY = ball.y; const intervalJitter = pulseRandomness * pulseInterval * (Math.random() - 0.5); const syncJitter = pulseSynchronicity * pulseInterval * Math.random(); ball.nextJumpTime = pulseInterval + intervalJitter + syncJitter;}if (ball.jumpProgress < 1.0) {ball.jumpProgress += dt / pulseSpeed; if (ball.jumpProgress >= 1.0) {ball.jumpProgress = 1.0; ball.x = ball.targetX; ball.y = ball.targetY; ball.vx = 0; ball.vy = 0;}else {const t = ball.jumpProgress; let eased = t; if (pulseEasingStyle === 'linear') {eased = t;}else if (pulseEasingStyle === 'snap') {if (t < 0.6) {const t1 = t / 0.6; eased = t1 * t1 * pulseOvershoot;}else {const t2 = (t - 0.6) / 0.4; const bounceAmount = (pulseOvershoot - 1.0) * (1 - t2); eased = 1.0 + bounceAmount - pulseBounceIntensity * Math.sin(t2 * Math.PI);}}else if (pulseEasingStyle === 'bounce') {if (t < 0.7) {eased = (t / 0.7) * (t / 0.7);}else {const t2 = (t - 0.7) / 0.3; eased = 1.0 - pulseBounceIntensity * 0.5 * Math.sin(t2 * Math.PI * 2);}}else if (pulseEasingStyle === 'smooth') {eased = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2,2) / 2;}ball.x = ball.jumpStartX + (ball.targetX - ball.jumpStartX) * eased; ball.y = ball.jumpStartY + (ball.targetY - ball.jumpStartY) * eased; ball.vx = 0; ball.vy = 0;}}}}function updateModeControlsUI() {const pulseGridControls = document.getElementById('pulseGridControls'); if (pitControls) pitControls.classList.toggle('active',currentMode === MODES.PIT); if (fliesControls) fliesControls.classList.toggle('active',currentMode === MODES.FLIES); if (weightlessControls) weightlessControls.classList.toggle('active',currentMode === MODES.WEIGHTLESS); if (pulseGridControls) pulseGridControls.classList.toggle('active',currentMode === MODES.PULSE_GRID); modeButtons.forEach(btn => {const isActive = btn.getAttribute('data-mode') === currentMode; btn.classList.toggle('active',isActive); btn.setAttribute('aria-pressed',isActive ? 'true' : 'false');});}function announceToScreenReader(message) {const announcer = document.getElementById('announcer'); if (announcer) {announcer.textContent = ''; setTimeout(() => announcer.textContent = message,100);}}function setMode(mode) {currentMode = mode; const modeNames = {[MODES.PIT]: 'Ball Pit',[MODES.FLIES]: 'Flies to Light',[MODES.WEIGHTLESS]: 'Zero Gravity',[MODES.PULSE_GRID]: 'Pulse Grid' }; announceToScreenReader(`Switched to ${modeNames[mode]}mode`); container.className = ''; if (currentMode === MODES.PIT) {container.classList.add('mode-pit');}resize(); if (currentMode === MODES.PIT) {gravityMultiplier = gravityMultiplierPit; G = GE * gravityMultiplier; repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0); EMITTER_SWEEP_ENABLED = true; balls.length = 0; emitterTimer = 0; resetBallSizeToGlobal();}else if (currentMode === MODES.FLIES) {gravityMultiplier = 0.0; G = GE * gravityMultiplier; repellerEnabled = false; EMITTER_SWEEP_ENABLED = false; initializeFliesScene(); resetBallSizeToGlobal();}else if (currentMode === MODES.WEIGHTLESS) {gravityMultiplier = 0.0; G = GE * gravityMultiplier; repellerEnabled = false; EMITTER_SWEEP_ENABLED = false; initializeWeightlessScene(); resetBallSizeToGlobal();}else if (currentMode === MODES.PULSE_GRID) {gravityMultiplier = 0.0; G = GE * gravityMultiplier; repellerEnabled = false; EMITTER_SWEEP_ENABLED = false; initializePulseGridScene(); resetBallSizeToGlobal();}updateModeControlsUI();}modeButtons.forEach(btn => btn.addEventListener('click',() => {setMode(btn.getAttribute('data-mode')); autoSaveSettings();})); gravityPitSlider && gravityPitSlider.addEventListener('input',() => {gravityMultiplierPit = parseFloat(gravityPitSlider.value); gravityPitVal && (gravityPitVal.textContent = gravityMultiplierPit.toFixed(1)); autoSaveSettings(); if (currentMode === MODES.PIT) {gravityMultiplier = gravityMultiplierPit; G = GE * gravityMultiplier;}}); weightPitSlider && weightPitSlider.addEventListener('input',() => {ballMassKg = parseFloat(weightPitSlider.value); weightPitVal && (weightPitVal.textContent = ballMassKg.toFixed(2)); for (let i=0; i<balls.length; i++) {balls[i].m = ballMassKg;}recomputeMassDerivedScales(); autoSaveSettings();}); repellerEnabledPitEl && repellerEnabledPitEl.addEventListener('change',() => {repellerEnabledPit = !!repellerEnabledPitEl.checked; if (currentMode === MODES.PIT) repellerEnabled = repellerEnabledPit && (repelPower > 0 && repelRadius > 0);}); attractPowerSlider && attractPowerSlider.addEventListener('input',() => {attractionPower = parseFloat(attractPowerSlider.value); attractPowerVal && (attractPowerVal.textContent = Math.round(attractionPower).toString());}); orbitRadiusSlider && orbitRadiusSlider.addEventListener('input',() => {orbitRadius = parseFloat(orbitRadiusSlider.value); orbitRadiusVal && (orbitRadiusVal.textContent = Math.round(orbitRadius).toString());}); swarmSpeedSlider && swarmSpeedSlider.addEventListener('input',() => {swarmSpeed = parseFloat(swarmSpeedSlider.value); swarmSpeedVal && (swarmSpeedVal.textContent = swarmSpeed.toFixed(1));}); weightlessCountSlider && weightlessCountSlider.addEventListener('input',() => {weightlessCount = parseInt(weightlessCountSlider.value,10); weightlessCountVal && (weightlessCountVal.textContent = weightlessCount.toString()); if (currentMode === MODES.WEIGHTLESS) initializeWeightlessScene();}); weightlessSpeedSlider && weightlessSpeedSlider.addEventListener('input',() => {weightlessInitialSpeed = parseFloat(weightlessSpeedSlider.value); weightlessSpeedVal && (weightlessSpeedVal.textContent = Math.round(weightlessInitialSpeed).toString());}); weightlessBounceSlider && weightlessBounceSlider.addEventListener('input',() => {weightlessBounce = parseFloat(weightlessBounceSlider.value); weightlessBounceVal && (weightlessBounceVal.textContent = weightlessBounce.toFixed(2));}); weightlessRepelSlider && weightlessRepelSlider.addEventListener('input',() => {weightlessRepellerPower = parseFloat(weightlessRepelSlider.value); weightlessRepelVal && (weightlessRepelVal.textContent = Math.round(weightlessRepellerPower).toString()); autoSaveSettings();}); weightlessRepelRadiusSlider && weightlessRepelRadiusSlider.addEventListener('input',() => {weightlessRepellerRadius = parseFloat(weightlessRepelRadiusSlider.value); weightlessRepelRadiusVal && (weightlessRepelRadiusVal.textContent = Math.round(weightlessRepellerRadius).toString()); autoSaveSettings();}); const gridPresetSelect = document.getElementById('gridPresetSelect'); const gridBallCountSlider = document.getElementById('gridBallCountSlider'); const gridBallCountVal = document.getElementById('gridBallCountVal'); const gridColumnsSlider = document.getElementById('gridColumnsSlider'); const gridColumnsVal = document.getElementById('gridColumnsVal'); const pulseIntervalSlider = document.getElementById('pulseIntervalSlider'); const pulseIntervalVal = document.getElementById('pulseIntervalVal'); const pulseSpeedSlider = document.getElementById('pulseSpeedSlider'); const pulseSpeedVal = document.getElementById('pulseSpeedVal'); const pulseMinStepsSlider = document.getElementById('pulseMinStepsSlider'); const pulseMinStepsVal = document.getElementById('pulseMinStepsVal'); const pulseMaxStepsSlider = document.getElementById('pulseMaxStepsSlider'); const pulseMaxStepsVal = document.getElementById('pulseMaxStepsVal'); const pulseSynchronicitySlider = document.getElementById('pulseSynchronicitySlider'); const pulseSynchronicityVal = document.getElementById('pulseSynchronicityVal'); const pulseRandomnessSlider = document.getElementById('pulseRandomnessSlider'); const pulseRandomnessVal = document.getElementById('pulseRandomnessVal'); const gridPresets = {synchronized: {interval: 0.6,speed: 0.2,minSteps: 1,maxSteps: 2,synchronicity: 0.1,randomness: 0.2,easingStyle: 'snap',overshoot: 1.12,bounce: 0.18 },organic: {interval: 0.8,speed: 0.25,minSteps: 1,maxSteps: 3,synchronicity: 0.3,randomness: 0.4,easingStyle: 'smooth',overshoot: 1.05,bounce: 0.1 },chaotic: {interval: 0.4,speed: 0.15,minSteps: 2,maxSteps: 4,synchronicity: 0.7,randomness: 0.8,easingStyle: 'bounce',overshoot: 1.15,bounce: 0.25 }}; function applyGridPreset(presetName) {const preset = gridPresets[presetName]; if (!preset) return; pulseInterval = preset.interval; pulseSpeed = preset.speed; pulseMinSteps = preset.minSteps; pulseMaxSteps = preset.maxSteps; pulseSynchronicity = preset.synchronicity; pulseRandomness = preset.randomness; pulseEasingStyle = preset.easingStyle; pulseOvershoot = preset.overshoot; pulseBounceIntensity = preset.bounce; if (pulseIntervalSlider) pulseIntervalSlider.value = preset.interval; if (pulseIntervalVal) pulseIntervalVal.textContent = preset.interval.toFixed(1); if (pulseSpeedSlider) pulseSpeedSlider.value = preset.speed; if (pulseSpeedVal) pulseSpeedVal.textContent = preset.speed.toFixed(2); if (pulseMinStepsSlider) pulseMinStepsSlider.value = preset.minSteps; if (pulseMinStepsVal) pulseMinStepsVal.textContent = preset.minSteps.toString(); if (pulseMaxStepsSlider) pulseMaxStepsSlider.value = preset.maxSteps; if (pulseMaxStepsVal) pulseMaxStepsVal.textContent = preset.maxSteps.toString(); if (pulseSynchronicitySlider) pulseSynchronicitySlider.value = preset.synchronicity; if (pulseSynchronicityVal) pulseSynchronicityVal.textContent = preset.synchronicity.toFixed(2); if (pulseRandomnessSlider) pulseRandomnessSlider.value = preset.randomness; if (pulseRandomnessVal) pulseRandomnessVal.textContent = preset.randomness.toFixed(2); const pulseEasingSelect = document.getElementById('pulseEasingSelect'); const pulseOvershootSlider = document.getElementById('pulseOvershootSlider'); const pulseOvershootVal = document.getElementById('pulseOvershootVal'); const pulseBounceSlider = document.getElementById('pulseBounceSlider'); const pulseBounceVal = document.getElementById('pulseBounceVal'); if (pulseEasingSelect) pulseEasingSelect.value = preset.easingStyle; if (pulseOvershootSlider) pulseOvershootSlider.value = preset.overshoot; if (pulseOvershootVal) pulseOvershootVal.textContent = preset.overshoot.toFixed(2); if (pulseBounceSlider) pulseBounceSlider.value = preset.bounce; if (pulseBounceVal) pulseBounceVal.textContent = preset.bounce.toFixed(2); if (currentMode === MODES.PULSE_GRID) {initializePulseGridScene();}}gridPresetSelect && gridPresetSelect.addEventListener('change',() => {applyGridPreset(gridPresetSelect.value); autoSaveSettings();}); gridBallCountSlider && gridBallCountSlider.addEventListener('input',() => {gridBallCount = parseInt(gridBallCountSlider.value,10); gridBallCountVal && (gridBallCountVal.textContent = gridBallCount.toString()); if (currentMode === MODES.PULSE_GRID) initializePulseGridScene(); autoSaveSettings();}); gridColumnsSlider && gridColumnsSlider.addEventListener('input',() => {gridColumns = parseInt(gridColumnsSlider.value,10); gridColumnsVal && (gridColumnsVal.textContent = gridColumns.toString()); if (currentMode === MODES.PULSE_GRID) {calculateGridDimensions(); initializePulseGridScene();}autoSaveSettings();}); pulseIntervalSlider && pulseIntervalSlider.addEventListener('input',() => {pulseInterval = parseFloat(pulseIntervalSlider.value); pulseIntervalVal && (pulseIntervalVal.textContent = pulseInterval.toFixed(1)); autoSaveSettings();}); pulseSpeedSlider && pulseSpeedSlider.addEventListener('input',() => {pulseSpeed = parseFloat(pulseSpeedSlider.value); pulseSpeedVal && (pulseSpeedVal.textContent = pulseSpeed.toFixed(2)); autoSaveSettings();}); pulseMinStepsSlider && pulseMinStepsSlider.addEventListener('input',() => {pulseMinSteps = parseInt(pulseMinStepsSlider.value,10); pulseMinStepsVal && (pulseMinStepsVal.textContent = pulseMinSteps.toString()); if (pulseMinSteps > pulseMaxSteps) {pulseMaxSteps = pulseMinSteps; if (pulseMaxStepsSlider) pulseMaxStepsSlider.value = pulseMinSteps; if (pulseMaxStepsVal) pulseMaxStepsVal.textContent = pulseMinSteps.toString();}autoSaveSettings();}); pulseMaxStepsSlider && pulseMaxStepsSlider.addEventListener('input',() => {pulseMaxSteps = parseInt(pulseMaxStepsSlider.value,10); pulseMaxStepsVal && (pulseMaxStepsVal.textContent = pulseMaxSteps.toString()); if (pulseMaxSteps < pulseMinSteps) {pulseMinSteps = pulseMaxSteps; if (pulseMinStepsSlider) pulseMinStepsSlider.value = pulseMaxSteps; if (pulseMinStepsVal) pulseMinStepsVal.textContent = pulseMaxSteps.toString();}autoSaveSettings();}); pulseSynchronicitySlider && pulseSynchronicitySlider.addEventListener('input',() => {pulseSynchronicity = parseFloat(pulseSynchronicitySlider.value); pulseSynchronicityVal && (pulseSynchronicityVal.textContent = pulseSynchronicity.toFixed(2)); autoSaveSettings();}); pulseRandomnessSlider && pulseRandomnessSlider.addEventListener('input',() => {pulseRandomness = parseFloat(pulseRandomnessSlider.value); pulseRandomnessVal && (pulseRandomnessVal.textContent = pulseRandomness.toFixed(2)); autoSaveSettings();}); const pulseEasingSelect = document.getElementById('pulseEasingSelect'); const pulseOvershootSlider = document.getElementById('pulseOvershootSlider'); const pulseOvershootVal = document.getElementById('pulseOvershootVal'); const pulseBounceSlider = document.getElementById('pulseBounceSlider'); const pulseBounceVal = document.getElementById('pulseBounceVal'); pulseEasingSelect && pulseEasingSelect.addEventListener('change',() => {pulseEasingStyle = pulseEasingSelect.value; autoSaveSettings();}); pulseOvershootSlider && pulseOvershootSlider.addEventListener('input',() => {pulseOvershoot = parseFloat(pulseOvershootSlider.value); pulseOvershootVal && (pulseOvershootVal.textContent = pulseOvershoot.toFixed(2)); autoSaveSettings();}); pulseBounceSlider && pulseBounceSlider.addEventListener('input',() => {pulseBounceIntensity = parseFloat(pulseBounceSlider.value); pulseBounceVal && (pulseBounceVal.textContent = pulseBounceIntensity.toFixed(2)); autoSaveSettings();}); function updateExistingBallColors() {for (let i = 0; i < balls.length; i++) {balls[i].color = pickRandomColor();}}function updateColorPickersUI() {const color1 = document.getElementById('color1'); const color2 = document.getElementById('color2'); const color3 = document.getElementById('color3'); const color4 = document.getElementById('color4'); const color5 = document.getElementById('color5'); const color6 = document.getElementById('color6'); const color7 = document.getElementById('color7'); const color8 = document.getElementById('color8'); const color1Val = document.getElementById('color1Val'); const color2Val = document.getElementById('color2Val'); const color3Val = document.getElementById('color3Val'); const color4Val = document.getElementById('color4Val'); const color5Val = document.getElementById('color5Val'); const color6Val = document.getElementById('color6Val'); const color7Val = document.getElementById('color7Val'); const color8Val = document.getElementById('color8Val'); if (color1 && color1Val) {color1.value = currentColors[0]; color1Val.textContent = currentColors[0].toUpperCase();}if (color2 && color2Val) {color2.value = currentColors[1]; color2Val.textContent = currentColors[1].toUpperCase();}if (color3 && color3Val) {color3.value = currentColors[2]; color3Val.textContent = currentColors[2].toUpperCase();}if (color4 && color4Val) {color4.value = currentColors[3]; color4Val.textContent = currentColors[3].toUpperCase();}if (color5 && color5Val) {color5.value = currentColors[4]; color5Val.textContent = currentColors[4].toUpperCase();}if (color6 && color6Val) {color6.value = currentColors[5]; color6Val.textContent = currentColors[5].toUpperCase();}if (color7 && color7Val) {color7.value = currentColors[6]; color7Val.textContent = currentColors[6].toUpperCase();}if (color8 && color8Val) {color8.value = currentColors[7]; color8Val.textContent = currentColors[7].toUpperCase();}}color1 && color1.addEventListener('input',() => {currentColors[0] = color1.value; color1Val && (color1Val.textContent = color1.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color2 && color2.addEventListener('input',() => {currentColors[1] = color2.value; color2Val && (color2Val.textContent = color2.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color3 && color3.addEventListener('input',() => {currentColors[2] = color3.value; color3Val && (color3Val.textContent = color3.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color4 && color4.addEventListener('input',() => {currentColors[3] = color4.value; color4Val && (color4Val.textContent = color4.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color5 && color5.addEventListener('input',() => {currentColors[4] = color5.value; color5Val && (color5Val.textContent = color5.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color6 && color6.addEventListener('input',() => {currentColors[5] = color6.value; color6Val && (color6Val.textContent = color6.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color7 && color7.addEventListener('input',() => {currentColors[6] = color7.value; color7Val && (color7Val.textContent = color7.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); color8 && color8.addEventListener('input',() => {currentColors[7] = color8.value; color8Val && (color8Val.textContent = color8.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars();}); cursorColorSelect && cursorColorSelect.addEventListener('change',() => {const idx = Math.max(1,Math.min(8,parseInt(cursorColorSelect.value,10))) - 1; cursorBallIndex = idx; cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor; autoSaveSettings();}); bindCopyOnClick(color1Val,() => color1.value.toUpperCase()); bindCopyOnClick(color2Val,() => color2.value.toUpperCase()); bindCopyOnClick(color3Val,() => color3.value.toUpperCase()); bindCopyOnClick(color4Val,() => color4.value.toUpperCase()); bindCopyOnClick(color5Val,() => color5.value.toUpperCase()); bindCopyOnClick(color6Val,() => color6.value.toUpperCase()); bindCopyOnClick(color7Val,() => color7.value.toUpperCase()); bindCopyOnClick(color8Val,() => color8.value.toUpperCase()); cornerRadiusSlider && cornerRadiusSlider.addEventListener('input',() => {cornerRadius = parseFloat(cornerRadiusSlider.value); cornerRadiusVal && (cornerRadiusVal.textContent = cornerRadius.toFixed(0));}); motionBlurFadeSlider && motionBlurFadeSlider.addEventListener('input',() => {motionBlurFade = parseFloat(motionBlurFadeSlider.value); motionBlurFadeVal && (motionBlurFadeVal.textContent = motionBlurFade.toFixed(3));}); trailSubtletySlider && trailSubtletySlider.addEventListener('input',() => {trailSubtlety = parseFloat(trailSubtletySlider.value); trailSubtletyVal && (trailSubtletyVal.textContent = trailSubtlety.toFixed(2) + '√ó');}); const PHYSICS_PRESETS = {rubberPlayground: {label: 'Rubber ‚Äì Playground',G: 1960,REST: 0.90,FRICTION: 0.0025,sizeScale: 1.8,maxBalls: 450,sizeVariation: 0.20 },rubberRacquet: {label: 'Rubber ‚Äì Racquetball',G: 3320,REST: 0.97,FRICTION: 0.0035,sizeScale: 0.7,maxBalls: 350,sizeVariation: 0.30 },rubberSuperball: {label: 'Rubber ‚Äì Superball',G: 1960,REST: 0.95,FRICTION: 0.0015,sizeScale: 1.2,maxBalls: 450,sizeVariation: 0.05 },rubberSoft: {label: 'Rubber ‚Äì Soft',G: 1960,REST: 0.86,FRICTION: 0.0035,sizeScale: 2.2,maxBalls: 350,sizeVariation: 0.25 },rubberHeavy: {label: 'Rubber ‚Äì Heavy',G: 1960,REST: 0.88,FRICTION: 0.0030,sizeScale: 2.0,maxBalls: 400,sizeVariation: 0.15 }}; const SPAWN_PRESETS = {fullRain: {label: 'Full Rain (top-half)',EMIT_INTERVAL: 0.030,xCenter: 50,y: -50,w: 100,h: 50 },narrowStrip: {label: 'Narrow Strip Top',EMIT_INTERVAL: 0.050,xCenter: 50,y: -40,w: 20,h: 10 },leftGutter: {label: 'Left Gutter',EMIT_INTERVAL: 0.045,xCenter: 10,y: -60,w: 18,h: 20 },rightGutter: {label: 'Right Gutter',EMIT_INTERVAL: 0.045,xCenter: 90,y: -60,w: 18,h: 20 },centerFountain: {label: 'Center Fountain',EMIT_INTERVAL: 0.020,xCenter: 50,y: -30,w: 30,h: 20 },stormBurst: {label: 'Storm Burst',EMIT_INTERVAL: 0.005,xCenter: 50,y: -80,w: 100,h: 30 },slowSnow: {label: 'Slow Snow',EMIT_INTERVAL: 0.200,xCenter: 50,y: -30,w: 100,h: 20 },edgeDrizzle: {label: 'Edge Drizzle',EMIT_INTERVAL: 0.080,xCenter: 15,y: -40,w: 30,h: 15 },twinColumns: {label: 'Twin Columns',EMIT_INTERVAL: 0.030,xCenter: 30,y: -50,w: 10,h: 40 },focusedBeam: {label: 'Focused Beam',EMIT_INTERVAL: 0.015,xCenter: 50,y: -70,w: 6,h: 12 }}; const REPELLER_PRESETS = {off: {label: 'Off',r: 710,p: 27400 * 10,s: 4.4 },gentle: {label: 'Gentle Breeze',r: 120,p: 2500,s: 2.5 },pushField: {label: 'Push Field',r: 240,p: 8000 * 10,s: 2.0 },tractor: {label: 'Tractor Push',r: 320,p: 14000 * 10,s: 1.6 },magnet: {label: 'Magnet Repel',r: 200,p: 18000 * 10,s: 3.0 },pulse: {label: 'Pulse Strong',r: 280,p: 22000 * 10,s: 1.2 },wideSoft: {label: 'Wide Soft',r: 500,p: 8000 * 10,s: 4.5 },needle: {label: 'Needle Point',r: 80,p: 26000 * 10,s: 0.8 },wall: {label: 'Invisible Wall',r: 700,p: 16000 * 10,s: 5.0 },singularity: {label: 'Singularity',r: 600,p: 30000 * 10,s: 0.5 }}; function fillSelect(select,dict,selectedKey) {select.innerHTML = ''; for (const [key,val] of Object.entries(dict)) {const opt = document.createElement('option'); opt.value = key; opt.textContent = val.label || key; if (key === selectedKey) opt.selected = true; select.appendChild(opt);}}const physicsSelect = document.getElementById('physicsSelect'); const spawnSelect = document.getElementById('spawnSelect'); const repellerSelect = document.getElementById('repellerSelect'); if (physicsSelect) fillSelect(physicsSelect,PHYSICS_PRESETS,'rubberRacquet'); if (spawnSelect) fillSelect(spawnSelect,SPAWN_PRESETS,'fullRain'); if (repellerSelect) fillSelect(repellerSelect,REPELLER_PRESETS,'off'); if (colorSelect) fillSelect(colorSelect,COLOR_TEMPLATES,'industrialTeal'); function updateSliderAndValue(slider,valueElement,value,decimals = 0) {if (slider) slider.value = String(value); if (valueElement) valueElement.textContent = decimals > 0 ? value.toFixed(decimals) : value.toString();}function applyPhysicsPreset(key) {const p = PHYSICS_PRESETS[key]; if (!p) return; REST = p.REST; FRICTION = p.FRICTION; MAX_BALLS = p.maxBalls; sizeVariation = p.sizeVariation; const newScale = p.sizeScale; sizeScale = newScale; updateEffectiveScaleAndBallSizes(); for (let i=0; i<balls.length; i++) {balls[i].m = ballMassKg;}if (balls.length > MAX_BALLS) {balls.length = MAX_BALLS;}updateSliderAndValue(restitutionSlider,restitutionVal,REST,2); updateSliderAndValue(frictionSlider,frictionVal,FRICTION,4); updateSliderAndValue(sizeSliderGlobal,sizeValGlobal,sizeScale,1); updateSliderAndValue(maxBallsSlider,maxBallsVal,MAX_BALLS,0); updateSliderAndValue(sizeVariationSliderGlobal,sizeVariationValGlobal,sizeVariation,1); updateExistingBallSizes();}function applySpawnPreset(key) {const s = SPAWN_PRESETS[key]; if (!s) return; EMIT_INTERVAL = s.EMIT_INTERVAL; SPAWN_X_CENTER_VW = s.xCenter; SPAWN_Y_VH = s.y; SPAWN_W_VW = s.w; SPAWN_H_VH = s.h; updateSliderAndValue(emitterSlider,emitterVal,EMIT_INTERVAL,3); updateSliderAndValue(spawnCenterSlider,spawnCenterVal,SPAWN_X_CENTER_VW,0); updateSliderAndValue(spawnYSlider,spawnYVal,SPAWN_Y_VH,0); updateSliderAndValue(spawnWidthSlider,spawnWidthVal,SPAWN_W_VW,0); updateSliderAndValue(spawnHeightSlider,spawnHeightVal,SPAWN_H_VH,0);}function applyRepellerPreset(key) {const r = REPELLER_PRESETS[key]; if (!r) return; repelRadius = r.r; repelPower = r.p * (REPELLER_GLOBAL_MULTIPLIER / 20.0); repellerEnabled = (key !== 'off'); updateSliderAndValue(repelSizeSlider,repelSizeVal,repelRadius,0); const sliderPos = powerToRepelSlider(repelPower); if (repelPowerSlider) repelPowerSlider.value = String(sliderPos); if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString(); updateSliderAndValue(repelSoftSlider,repelSoftVal,repelSoft,1);}applyPhysicsPreset('rubberRacquet'); applySpawnPreset('fullRain'); applyRepellerPreset('off'); updateColorPickersUI(); syncPaletteVars(); physicsSelect && physicsSelect.addEventListener('change',() => applyPhysicsPreset(physicsSelect.value)); spawnSelect && spawnSelect.addEventListener('change',() => applySpawnPreset(spawnSelect.value)); repellerSelect && repellerSelect.addEventListener('change',() => applyRepellerPreset(repellerSelect.value)); updateEffectiveScaleAndBallSizes(); updateTextColliders(); const settingsLoaded = loadSettings(); updateCanvasShadow(); checkAndApplyDarkMode(); setInterval(checkAndApplyDarkMode,60000); applyDeviceSpecificModeVisibility(); setMode(currentMode); window.addEventListener('beforeunload',saveSettings);})();