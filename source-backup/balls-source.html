<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Refined Bravia Balls ‚Äì Canvas Physics</title>
<style>
  html, body { height: 100%; margin: 0; background: #cecece; overflow:hidden; }
  /* Scoped wrapper for embed friendliness and interaction hygiene */
  #ball-simulation {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 150vh;
    overscroll-behavior: contain;
    -webkit-tap-highlight-color: transparent;
    user-select: none; -webkit-user-select: none; -webkit-touch-callout: none;
  }
  #ball-simulation canvas { 
    display: block; 
    width: 100%; 
    height: 150vh;
    position: absolute;
    bottom: 0;
    left: 0;
    -webkit-user-drag: none;
    user-select: none; 
    -webkit-user-select: none;
    touch-action: none;
    cursor: none;
  }
  @media (prefers-reduced-motion: reduce) { 
    #ball-simulation canvas { filter: none; } 
  }
  #ball-simulation .panel {
    position: fixed;
    top: 5vh;
    right: 5vh;
    color: #fff;
    font: 12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    background: rgba(0,0,0,0.45);
    padding: 10px;
    border-radius: 8px;
    user-select: none;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 10;
    max-height: 90vh;
    overflow: auto;
    backdrop-filter: blur(6px);
  }
  #ball-simulation .panel.hidden { display: none; }
  #ball-simulation .panel label {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 6px;
    width: 260px;
  }
  #ball-simulation .panel input[type="range"] {
    flex: 1;
  }
  #ball-simulation .panel span.val {
    width: 56px;
    text-align: right;
    font-family: monospace;
  }
  #ball-simulation .panel span.hex-val {
    font-family: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;
    font-size: 10px;
    color: #888;
    background: rgba(0,0,0,0.05);
    padding: 1px 4px;
    border-radius: 2px;
    margin-left: 4px;
    text-transform: uppercase;
    cursor: pointer;
  }
  #ball-simulation .panel code {
    font-family: monospace;
    background: rgba(255,255,255,0.1);
    padding: 2px 4px;
    border-radius: 4px;
  }
  #ball-simulation .panel details { background: rgba(255,255,255,0.04); border-radius: 6px; padding: 6px; }
  #ball-simulation .panel summary { cursor: pointer; list-style: none; outline: none; }
  #ball-simulation .panel summary::-webkit-details-marker { display: none; }
  #ball-simulation .panel summary { display:flex; align-items:center; justify-content:space-between; color:#b8c2c7; }
  #ball-simulation .panel .group { display:flex; flex-direction:column; gap:6px; margin-top:6px; }
  
  /* Centered text collider for testing */
  #ball-simulation #hero-text {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 5;
    color: #ffffff;
    text-align: center;
    pointer-events: none;
    font-weight: 700;
    line-height: 1.1;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    font-size: clamp(12px, 4vw, 40px);
    display: inline-block;
    width: auto;
    max-width: min(45vw, 500px);
    text-wrap: balance;
    text-shadow: 0 2px 8px rgba(0,0,0,0.35);
  }
  
  /* Palette variables (defaults match 'industrialTeal') */
  :root {
    --ball-1: #b7bcb7;
    --ball-2: #e4e9e4;
    --ball-3: #ffffff;
    --ball-4: #00695c;
    --ball-5: #000000;
    --ball-6: #ff4013;
    --ball-7: #0d5cb6;
    --ball-8: #ffa000;
  }
  /* Utility classes for using the palette elsewhere on the page */
  .text-ball-1 { color: var(--ball-1); }
  .text-ball-2 { color: var(--ball-2); }
  .text-ball-3 { color: var(--ball-3); }
  .text-ball-4 { color: var(--ball-4); }
  .text-ball-5 { color: var(--ball-5); }
  .text-ball-6 { color: var(--ball-6); }
  .text-ball-7 { color: var(--ball-7); }
  .text-ball-8 { color: var(--ball-8); }
  .bg-ball-1 { background-color: var(--ball-1); }
  .bg-ball-2 { background-color: var(--ball-2); }
  .bg-ball-3 { background-color: var(--ball-3); }
  .bg-ball-4 { background-color: var(--ball-4); }
  .bg-ball-5 { background-color: var(--ball-5); }
  .bg-ball-6 { background-color: var(--ball-6); }
  .bg-ball-7 { background-color: var(--ball-7); }
  .bg-ball-8 { background-color: var(--ball-8); }
  .border-ball-1 { border-color: var(--ball-1); }
  .border-ball-2 { border-color: var(--ball-2); }
  .border-ball-3 { border-color: var(--ball-3); }
  .border-ball-4 { border-color: var(--ball-4); }
  .border-ball-5 { border-color: var(--ball-5); }
  .border-ball-6 { border-color: var(--ball-6); }
  .border-ball-7 { border-color: var(--ball-7); }
  .border-ball-8 { border-color: var(--ball-8); }
  
  /* Segmented Control Styles */
  .segment-control {
    display: flex;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 2px;
    margin: 8px 0;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }
  
  .segment-button {
    flex: 1;
    padding: 8px 12px;
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    font-size: 11px;
    font-weight: 500;
    border-radius: 6px;
    cursor: pointer;
    transition: all 0.2s ease;
    text-align: center;
  }
  
  .segment-button:hover {
    background: rgba(255, 255, 255, 0.1);
    color: rgba(255, 255, 255, 0.9);
  }
  
  .segment-button.active {
    background: rgba(255, 255, 255, 0.2);
    color: white;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
  }
  
  .behavior-header {
    text-align: center;
    margin: 8px 0 4px 0;
    font-size: 12px;
    font-weight: 600;
    color: rgba(255, 255, 255, 0.9);
  }
</style>
</head>
<body>
<div id="ball-simulation">
  <canvas id="c" aria-label="Bouncy balls simulation" role="img" draggable="false"></canvas>
  <p id="hero-text">Alexander Beck Studio.</p>
  <div class="panel" id="controlPanel">
  <!-- Behavior Selection at Top -->
  <div class="behavior-header">üß† Behavior Mode</div>
  <div class="segment-control">
    <button class="segment-button active" data-behavior="pit">Ball Pit</button>
    <button class="segment-button" data-behavior="flies">Flies to Light</button>
    <button class="segment-button" data-behavior="print">Mouse Trail</button>
  </div>
  
  <!-- Actions (Compact) -->
  <div style="margin: 8px 0; padding: 6px; background: rgba(0,255,0,0.08); border-radius: 4px; text-align: center;">
    <button id="saveConfigBtn" style="background: #4CAF50; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-weight: bold; margin-right: 6px; font-size: 11px;">üíæ Save</button>
    <button id="buildBtn" style="background: #2196F3; color: white; border: none; padding: 6px 12px; border-radius: 3px; cursor: pointer; font-weight: bold; font-size: 11px;">üöÄ Build</button>
    <div id="configOutput" style="margin-top: 8px; font-family: monospace; font-size: 10px; color: #333; max-height: 200px; overflow-y: auto; display: none; text-align: left; background: rgba(255,255,255,0.9); padding: 8px; border-radius: 4px; border: 1px solid #ddd;"></div>
  </div>

  <!-- Mode-Specific Controls (Dynamic) -->
  <details open id="modeControls">
    <summary id="modeControlsTitle">üéØ Ball Pit Controls</summary>
    <div class="group">
      <!-- Ball Pit Mode Controls -->
      <div id="pitControls" class="mode-controls">
        <div style="font-size: 10px; opacity: 0.8; margin-bottom: 8px; font-style: italic;">Continuous ball spawning with physics simulation</div>
        <label>Spawn template: <select id="spawnSelect"></select></label>
        <label>Emit interval (s): <span class="val" id="emitterVal">0.04</span><input type="range" id="emitterSlider" min="0.000" max="1.000" step="0.005" value="0.04"></label>
        <label>Spawn Y (vh): <span class="val" id="spawnYVal">-50</span><input type="range" id="spawnYSlider" min="-100" max="100" step="10" value="-50"></label>
        <label>Spawn Width (vw): <span class="val" id="spawnWidthVal">100</span><input type="range" id="spawnWidthSlider" min="0" max="100" step="10" value="100"></label>
        <label>Spawn X Center (vw): <span class="val" id="spawnCenterVal">50</span><input type="range" id="spawnCenterSlider" min="0" max="100" step="10" value="50"></label>
        <label>Spawn Height (vh): <span class="val" id="spawnHeightVal">50</span><input type="range" id="spawnHeightSlider" min="0" max="100" step="10" value="50"></label>
      </div>
      
      <!-- Flies Mode Controls -->
      <div id="fliesControls" class="mode-controls" style="display: none;">
        <div style="font-size: 10px; opacity: 0.8; margin-bottom: 8px; font-style: italic;">Particles attracted to mouse/touch with swarming behavior</div>
        <label>Speed (%): <span class="val" id="fliesSpeedMulVal">340%</span><input type="range" id="fliesSpeedMulSlider" min="25" max="400" step="5" value="340"></label>
        <label>Max speed (px/s): <span class="val" id="fliesMaxSpeedVal">1910</span><input type="range" id="fliesMaxSpeedSlider" min="100" max="3000" step="10" value="1910"></label>
        <label>Jitter: <span class="val" id="fliesJitterVal">3.0</span><input type="range" id="fliesJitterSlider" min="0" max="10" step="0.1" value="3.0"></label>
        <label>Scatter range (px): <span class="val" id="fliesScatterRadiusVal">490</span><input type="range" id="fliesScatterRadiusSlider" min="0" max="1000" step="5" value="490"></label>
        <label>Scatter variance (%): <span class="val" id="fliesScatterVarVal">100%</span><input type="range" id="fliesScatterVarSlider" min="0" max="100" step="5" value="100"></label>
      </div>
      
      <!-- Trail Mode Controls -->
      <div id="trailControls" class="mode-controls" style="display: none;">
        <div style="font-size: 10px; opacity: 0.8; margin-bottom: 8px; font-style: italic;">Smooth particle trail following mouse movement</div>
        <label>Trail smoothing (%): <span class="val" id="trailSmoothingVal">0%</span><input type="range" id="trailSmoothingSlider" min="-500" max="400" step="10" value="0"></label>
        <label>General smoothing (%): <span class="val" id="generalSmoothingVal">0%</span><input type="range" id="generalSmoothingSlider" min="-500" max="400" step="10" value="0"></label>
        <label>Trail length: <span class="val" id="trailLengthVal">75</span><input type="range" id="trailLengthSlider" min="5" max="200" step="5" value="75"></label>
        <label>Spawn rate (ms): <span class="val" id="trailSpawnRateVal">50</span><input type="range" id="trailSpawnRateSlider" min="10" max="200" step="10" value="50"></label>
        <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
          <label>Motion blur: <span class="val" id="trailFadeVal">0.000</span><input type="range" id="trailFadeSlider" min="0.000" max="1.500" step="0.001" value="0.000"></label>
          <label>Blur subtlety: <span class="val" id="trailSubtletyVal">1.00√ó</span><input type="range" id="trailSubtletySlider" min="0.00" max="3.00" step="0.05" value="1.00"></label>
        </div>
      </div>
    </div>
  </details>

  <!-- Global Physics -->
  <details>
    <summary>‚öôÔ∏è Global Physics</summary>
    <div class="group">
        <label>Physics template: <select id="physicsSelect"></select></label>
        <label>Bounciness: <span class="val" id="restitutionVal">0.78</span><input type="range" id="restitutionSlider" min="0.00" max="1.00" step="0.001" value="0.78"></label>
        <label>Friction: <span class="val" id="frictionVal">0.0025</span><input type="range" id="frictionSlider" min="0.000" max="0.250" step="0.0005" value="0.0025"></label>
        <label>Size: <span class="val" id="sizeVal">2.0</span><input type="range" id="sizeSlider" min="0.1" max="6.0" step="0.1" value="2.0"></label>
        <label>Max balls: <span class="val" id="maxBallsVal">400</span><input type="range" id="maxBallsSlider" min="50" max="1000" step="25" value="400"></label>
        <label>Size variation: <span class="val" id="sizeVariationVal">1.0</span><input type="range" id="sizeVariationSlider" min="0.0" max="3.0" step="0.1" value="1.0"></label>
        <label>Ball weight (kg): <span class="val" id="weightVal">11.20</span><input type="range" id="weightSlider" min="0.10" max="200.00" step="0.10" value="11.20"></label>
    </div>
  </details>

  <!-- Mouse Interaction -->
  <details>
    <summary>üß≤ Mouse Interaction</summary>
    <div class="group">
        <label>Repeller template: <select id="repellerSelect"></select></label>
        <label>Repel size (px): <span class="val" id="repelSizeVal">200</span><input type="range" id="repelSizeSlider" min="0" max="1000" step="5" value="200"></label>
        <label>Responsive repel size: <input type="checkbox" id="repelResponsiveToggle" checked></label>
        <label>Min repel size (px): <span class="val" id="repelMinSizeVal">60</span><input type="range" id="repelMinSizeSlider" min="10" max="400" step="1" value="60"></label>
        <label>Max repel size (px): <span class="val" id="repelMaxSizeVal">200</span><input type="range" id="repelMaxSizeSlider" min="60" max="800" step="1" value="200"></label>
        <label>Repel power: <span class="val" id="repelPowerVal">24000</span><input type="range" id="repelPowerSlider" min="0" max="1000" step="1" value="500"></label>
        <label>Repel softness: <span class="val" id="repelSoftVal">2.0</span><input type="range" id="repelSoftSlider" min="0.1" max="8" step="0.1" value="2.0"></label>
    </div>
  </details>

  <!-- Visual Effects -->
  <details>
    <summary>üñºÔ∏è Visual Effects</summary>
    <div class="group">
        <label>Corner radius (px): <span class="val" id="cornerRadiusVal">0</span><input type="range" id="cornerRadiusSlider" min="0" max="200" step="5" value="0"></label>
    </div>
  </details>

  <!-- Colors -->
  <details>
    <summary>üé® Colors</summary>
    <div class="group">
        <label>Color template: <select id="colorSelect"></select></label>
        <label>Color 1 (50%): <input type="color" id="color1" value="#ffffff"> <span class="hex-val" id="color1Val">#ffffff</span></label>
        <label>Color 2 (25%): <input type="color" id="color2" value="#f8f9fa"> <span class="hex-val" id="color2Val">#f8f9fa</span></label>
        <label>Color 3 (12%): <input type="color" id="color3" value="#e9ecef"> <span class="hex-val" id="color3Val">#e9ecef</span></label>
        <label>Color 4 (6%): <input type="color" id="color4" value="#d90429"> <span class="hex-val" id="color4Val">#d90429</span></label>
        <label>Color 5 (3%): <input type="color" id="color5" value="#000000"> <span class="hex-val" id="color5Val">#000000</span></label>
        <label>Color 6 (2%): <input type="color" id="color6" value="#54d4ff"> <span class="hex-val" id="color6Val">#54d4ff</span></label>
        <label>Color 7 (1%): <input type="color" id="color7" value="#b589ff"> <span class="hex-val" id="color7Val">#b589ff</span></label>
        <label>Color 8 (1%): <input type="color" id="color8" value="#ffc27a"> <span class="hex-val" id="color8Val">#ffc27a</span></label>
        <label>Cursor color:
          <select id="cursorColorSelect">
            <option value="1">Color 1</option>
            <option value="2">Color 2</option>
            <option value="3">Color 3</option>
            <option value="4">Color 4</option>
            <option value="5">Color 5</option>
            <option value="6" selected>Color 6 (highlight)</option>
            <option value="7">Color 7</option>
            <option value="8">Color 8</option>
          </select>
        </label>
        <div style="font-size: 9px; opacity: 0.7; margin-top: 4px;">Colors appear by weight: 1 is most common, 8 is rarest</div>
    </div>
  </details>
    <div style="font-size:10px; opacity:0.8;">Press <code>R</code> to return balls to spawn ‚Ä¢ <code>/</code> toggle panel</div>
  </div>
  
  <!-- FPS Counter -->
  <div id="fps-counter" style="position: fixed; top: 5vh; left: 5vh; background: rgba(0,0,0,0.7); color: white; padding: 8px 12px; border-radius: 4px; font-family: monospace; font-size: 12px; z-index: 1001; backdrop-filter: blur(6px); line-height: 1.4;">
    Render: <span id="render-fps">--</span> fps<br>
    Physics: <span id="physics-fps">--</span> fps<br>
  </div>
</div>
<script>
// Version: 2024-09-20 - Removed 3D rendering, simplified shadows
(() => {
  // Constants for magic numbers
  const CONSTANTS = {
    CANVAS_HEIGHT_VH: 1.5,        // 150vh canvas height
    OFFSCREEN_MOUSE: -1e9,        // Offscreen mouse position
    MIN_DISTANCE_EPSILON: 1e-6,   // Minimum distance for collision calculations
    MIN_REPEL_DISTANCE: 1e-4,     // Minimum repeller distance
    ACCUMULATOR_RESET_THRESHOLD: 3, // Reset accumulator if behind by this many frames
    INITIAL_SEED_BALLS: 200,      // Initial balls to seed
    BALL_SPAWN_OFFSET: 2,         // Offset for ball spawning
    BALL_CLUSTER_SPACING: 8,      // Spacing between clustered balls
    BALL_CLUSTER_Y_OFFSET: 12,    // Y offset for clustered balls
    MAX_PHYSICS_STEPS: 2,         // Maximum physics steps per frame
    FPS_UPDATE_INTERVAL: 1.0,     // FPS counter update interval in seconds
    // Spin & squash tuning
    SPIN_DAMP_PER_S: 2.0,         // angular damping per second
    SPIN_GAIN: 0.25,              // how strongly tangential slip converts to spin
    SPIN_GAIN_TANGENT: 0.18,      // ball‚Äìball tangential slip to spin
    ROLL_FRICTION_PER_S: 1.5,     // rolling friction for horizontal speed per second when grounded
    SQUASH_MAX: 0.20,             // maximum squash amount (moderate, prevents elongated look)
    SQUASH_DECAY_PER_S: 18.0,     // faster relaxation for snappy feel
    WALL_REST_VEL_THRESHOLD: 70,  // below this, wall bounce becomes inelastic (settles)
    GROUND_COUPLING_PER_S: 8.0    // match roll (vx) to spin (omega) when grounded
  };

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });
  const panel = document.getElementById('controlPanel');
  const DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));

  // Spawn area controls (viewport-relative)
  // Defaults: xCenter = 50vw, y = -50vh, width = 100vw, height = 50vh
  let SPAWN_X_CENTER_VW = 50;
  let SPAWN_Y_VH = -50;
  let SPAWN_W_VW = 100;
  let SPAWN_H_VH = 50;

  // Resize canvas to 150vh (with top 50vh hidden above viewport)
  function resize() {
    const simHeight = window.innerHeight * CONSTANTS.CANVAS_HEIGHT_VH;
    canvas.width  = Math.floor(window.innerWidth * DPR);
    canvas.height = Math.floor(simHeight * DPR);
  }
  const setCSSSize = () => {
    // CSS size is handled by CSS (150vh, bottom-aligned)
  };
  setCSSSize(); resize();
  window.addEventListener('resize', () => { setCSSSize(); resize(); updateEffectiveScaleAndBallSizes(); updateTextColliders(); updateRepelRadius(); });

  // Physics parameters (initial)
  const GE = 1960;        // Earth gravity in px/s^2 at our scale
  let gravityMultiplier = 1.10; // 1.1√ó Earth
  let G = GE * gravityMultiplier;
  let REST = 0.88;        // restitution (bounciness) - from screenshot
  let FRICTION = 0.0030;  // air drag per frame - from screenshot
  let EMIT_INTERVAL = 0.030; // seconds between drops - from screenshot
  let MAX_BALLS = 400;    // from screenshot
  const SOLVER_ITERS = 6;    // Optimized for realistic collisions without jitter
  const POS_CORRECT_PERCENT = 0.8; // Reduced for more stable contacts
  const POS_CORRECT_SLOP = 0.5 * DPR; // Slightly more tolerance to prevent jitter
  const REST_VEL_THRESHOLD = 30; // Lower threshold for more realistic settling

  // Base radius values
  const R_MIN_BASE = 6;
  const R_MAX_BASE = 24;
  let sizeScale = 2.0;     // from screenshot
  let sizeVariation = 0.1; // from screenshot
  // Responsive scale: reduce ball size by 60% on mobile breakpoints (‚â§768px)
  let responsiveScale = 1.0;
  let lastEffectiveScale = null; // tracks previous (sizeScale * responsiveScale)
  // Global mass model: all balls share the same mass in kg
  let ballMassKg = 19.80; // from screenshot
  const MASS_BASELINE_KG = 1.0; // reference mass for scaling drag/forces
  // Mass influence tuning
  const MASS_GRAVITY_EXP = 0.35; // how much mass influences gravity (perceptual)
  const MASS_REST_EXP = 0.15;    // how much mass influences bounce restitution
  let gravityScale = 1.0;        // computed from mass
  function recomputeMassDerivedScales() {
    gravityScale = Math.max(0.5, Math.min(3.0, Math.pow(ballMassKg / MASS_BASELINE_KG, MASS_GRAVITY_EXP)));
  }
  recomputeMassDerivedScales();
  let R_MIN = R_MIN_BASE * sizeScale;
  let R_MAX = R_MAX_BASE * sizeScale;

  function computeResponsiveScale() {
    // Use canvas container width for proper embed behavior
    const containerWidth = canvas.clientWidth || window.innerWidth;
    return (containerWidth <= 768) ? 0.4 : 1.0;
  }

  function updateEffectiveScaleAndBallSizes() {
    responsiveScale = computeResponsiveScale();
    const effectiveScale = sizeScale * responsiveScale;
    if (lastEffectiveScale === null) {
      lastEffectiveScale = effectiveScale;
      R_MIN = R_MIN_BASE * effectiveScale;
      R_MAX = R_MAX_BASE * effectiveScale;
      return;
    }
    const ratio = effectiveScale / lastEffectiveScale;
    if (ratio !== 1) {
      for (let i = 0; i < balls.length; i++) {
        balls[i].r *= ratio;
      }
      lastEffectiveScale = effectiveScale;
    }
    R_MIN = R_MIN_BASE * effectiveScale;
    R_MAX = R_MAX_BASE * effectiveScale;
  }

  // Update text collision rectangles by measuring DOM elements
  function updateTextColliders() {
    textColliders = []; // Clear existing colliders
    
    const textElement = document.querySelector(TEXT_SELECTOR);
    if (!textElement) return; // No text element found
    
    const textRect = textElement.getBoundingClientRect();
    const canvasRect = canvas.getBoundingClientRect();
    
    // Calculate cap height (height of capital letters only)
    const capHeight = calculateCapHeight(textElement);
    
    // Center the collision box vertically on the visual text
    const heightDifference = textRect.height - capHeight;
    const verticalOffset = heightDifference * 0.5; // Center the cap height within the full text height
    
    // Convert to canvas coordinates with device pixel ratio
    const collider = {
      x: (textRect.left - canvasRect.left) * DPR,
      y: (textRect.top - canvasRect.top + verticalOffset) * DPR,
      width: textRect.width * DPR,
      height: capHeight * DPR
    };
    
    // Only add collider if it's within canvas bounds and has valid dimensions
    if (collider.width > 0 && collider.height > 0 && 
        collider.x < canvas.width && collider.y < canvas.height &&
        collider.x + collider.width > 0 && collider.y + collider.height > 0) {
      textColliders.push(collider);
    }
  }
  
  // Calculate the cap height of text element (height of capital letters)
  function calculateCapHeight(element) {
    // Create a temporary element with just capital letters to measure cap height
    const tempElement = document.createElement('span');
    tempElement.style.cssText = window.getComputedStyle(element).cssText;
    tempElement.style.position = 'absolute';
    tempElement.style.visibility = 'hidden';
    tempElement.style.whiteSpace = 'nowrap';
    tempElement.textContent = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    
    document.body.appendChild(tempElement);
    const capHeight = tempElement.getBoundingClientRect().height;
    document.body.removeChild(tempElement);
    
    return capHeight;
  }

  // Emitter sweep (natural hand-like motion across the top band)
  let EMITTER_SWEEP_ENABLED = true;
  let emitterPhase = 0;                 // radians
  const EMITTER_SWEEP_HZ = 0.12;        // cycles per second
  const EMITTER_SWEEP_AMPL_VW = 20;     // sweep amplitude in vw
  let emitterSweepDir = 1;              // +1 sweeping right, -1 sweeping left (derived)

  // 8-Color system with weighted distribution (50%, 25%, 12%, 6%, 3%, 2%, 1%, 1%)
  // Color 1 (50%): Dominant/background color
  // Color 2 (25%): Secondary color  
  // Color 3 (15%): Tertiary color
  // Color 4 (7.5%): Accent color
  // Color 5 (2.5%): Rare/special color
  const COLOR_TEMPLATES = {
    industrialTeal: { label: 'Industrial Teal', colors: ['#b7bcb7', '#e4e9e4', '#ffffff', '#00695c', '#000000', '#ff4013', '#0d5cb6', '#ffa000'] },
    modern: { label: 'Modern European', colors: ['#9ca3af', '#d1d5db', '#ffffff', '#ff3b30', '#000000', '#00e5ff', '#1976d2', '#ffc107'] },
    corporate: { label: 'Corporate Modern', colors: ['#a0a8b1', '#d2d8de', '#ffffff', '#1a73e8', '#000000', '#ff5722', '#7b1fa2', '#ffa000'] },
    minimal: { label: 'Helvetica Minimal', colors: ['#bdbdbd', '#e0e0e0', '#ffffff', '#6b7280', '#000000', '#40e0d0', '#303f9f', '#ff9800'] },
    euroBlue: { label: 'European Blue', colors: ['#9aa6b2', '#d4dde5', '#ffffff', '#0a66c2', '#000000', '#ff4081', '#388e3c', '#ffb300'] },
    scandi: { label: 'Scandinavian Bright', colors: ['#aab2b7', '#e6eaee', '#ffffff', '#74b9ff', '#000000', '#e91e63', '#1976d2', '#4caf50'] },
    neonCyan: { label: 'Graphite Neon Cyan', colors: ['#9aa0a6', '#d5d9dd', '#ffffff', '#00e5ff', '#000000', '#ff9800', '#9c27b0', '#4caf50'] },
    coralTech: { label: 'Coral Tech', colors: ['#9da3a9', '#d8dde2', '#ffffff', '#ff6b6b', '#000000', '#00e676', '#3f51b5', '#ff5722'] },
    violetMidnight: { label: 'Violet Midnight', colors: ['#9fa3b1', '#d9dce3', '#ffffff', '#7c3aed', '#000000', '#e91e63', '#388e3c', '#ffb300'] },
    mintSage: { label: 'Mint Sage', colors: ['#a0a7a2', '#dbe0dd', '#ffffff', '#00c896', '#000000', '#ff1744', '#3f51b5', '#ff9800'] },
    slateAzure: { label: 'Slate Azure', colors: ['#9aa3ad', '#d8dee6', '#ffffff', '#3b82f6', '#000000', '#ff4081', '#388e3c', '#ffc107'] },
    vaporPop: { label: 'Vapor Pop', colors: ['#9ea0a8', '#d6d7dc', '#ffffff', '#ff00e5', '#000000', '#00bcd4', '#673ab7', '#ff5722'] },
    cyberMagenta: { label: 'Cyber Magenta', colors: ['#9c9fad', '#d6d9e3', '#ffffff', '#ff007a', '#000000', '#40e0d0', '#1976d2', '#ff9800'] },
    streetLime: { label: 'Street Lime', colors: ['#9aa19a', '#d6dbd6', '#ffffff', '#baff00', '#000000', '#e91e63', '#3f51b5', '#ff6f00'] },
    cmykPop: { label: 'CMYK Pop', colors: ['#9f9f9f', '#d9d9d9', '#ffffff', '#ffd400', '#000000', '#ff1744', '#7b1fa2', '#4caf50'] }
  };

  let currentTemplate = 'industrialTeal';
  let currentColors = COLOR_TEMPLATES.industrialTeal.colors.slice(); // 8 colors
  // Cursor color: default to Color 6 (highlight)
  let cursorBallIndex = 5;
  let cursorBallColor = currentColors[cursorBallIndex] || '#ff4013';

  // Expose palette as CSS variables for use by page elements
  function syncPaletteVars(colors = currentColors) {
    try {
      const root = document.documentElement;
      const list = (colors && colors.length ? colors : currentColors).slice(0, 8);
      for (let i = 0; i < 8; i++) {
        const hex = list[i] || '#ffffff';
        root.style.setProperty(`--ball-${i+1}`, hex);
      }
    } catch (_) { /* no-op */ }
  }

  // Color weights: Color 1: 50%, Color 2: 25%, Color 3: 15%, Color 4: 7.5%, Color 5: 2.5%
  const COLOR_WEIGHTS = [0.50, 0.25, 0.12, 0.06, 0.03, 0.02, 0.01, 0.01];
  
  function pickRandomColor() {
    try {
      if (!currentColors || currentColors.length === 0) {
        console.warn('No colors available, using fallback');
        return '#ffffff'; // Fallback color
      }
      
      // Use weighted random selection
      const random = Math.random();
      let cumulativeWeight = 0;
      
      for (let i = 0; i < Math.min(currentColors.length, COLOR_WEIGHTS.length); i++) {
        cumulativeWeight += COLOR_WEIGHTS[i];
        if (random <= cumulativeWeight) {
          return currentColors[i];
        }
      }
      
      // Fallback to last color if something goes wrong
      return currentColors[Math.min(currentColors.length - 1, 7)];
    } catch (error) {
      console.error('Error picking random color:', error);
      return '#ffffff'; // Fallback color
    }
  }

  // Repeller controls
  let repelRadius = 135;   // px (CSS px) - from screenshot
  let repelPower = 1536000;  // from screenshot (mapped display value)
  let repelSoft = 3.4;     // exponent falloff - from screenshot
  let mouseX = CONSTANTS.OFFSCREEN_MOUSE, mouseY = CONSTANTS.OFFSCREEN_MOUSE; // offscreen until moved
  let repellerEnabled = false; // disabled by default; enabled by preset or sliders
  const REPELLER_GLOBAL_MULTIPLIER = 20.0; // doubled overall repeller strength
  // Responsive repeller sizing
  let repelResponsive = true;
  let repelMinSize = 60;   // CSS px at 375px viewport
  let repelMaxSize = 200;  // CSS px at 1128px+ viewport
  // Unified input handling state (pointer vs mouse)
  const HAS_POINTER_EVENTS = 'PointerEvent' in window;
  let isTouchActive = false;
  let activePointerId = null;
  let lastPointerType = 'mouse';
  // Hide visual cursor ball on mobile-like inputs
  let hideCursorOnMobile = true;
  function isMobileLikeInput() {
    try {
      const coarse = window.matchMedia && window.matchMedia('(pointer: coarse)').matches;
      const noHover = window.matchMedia && window.matchMedia('(hover: none)').matches;
      return coarse || noHover || (responsiveScale < 1.0);
    } catch (_) {
      return (responsiveScale < 1.0);
    }
  }
  function updateRepellerFromClient(clientX, clientY) {
    const rect = canvas.getBoundingClientRect();
    mouseX = (clientX - rect.left) * DPR;
    mouseY = (clientY - rect.top) * DPR;
  }

  // Repeller slider mapping (wide dynamic range; midpoint equals 2√ó previous default)
  const REPEL_BASE_POWER = 12000; // previous default baseline
  const REPEL_SLIDER_MAX = 1000;  // slider range [0..1000]
  const REPEL_CENTER_MULTIPLIER = 2.0; // midpoint = 2√ó base
  const REPEL_N_OCTAVES = 12; // wide range (~1/32x .. 128x around center)
  function repelSliderToPower(sliderValue) {
    const s = Math.max(0, Math.min(REPEL_SLIDER_MAX, Number(sliderValue))) / REPEL_SLIDER_MAX;
    const mult = REPEL_CENTER_MULTIPLIER * Math.pow(2, (s - 0.5) * REPEL_N_OCTAVES);
    return REPEL_BASE_POWER * mult;
  }

  // Compute responsive repel radius based on viewport width, clamped between min/max
  function computeResponsiveRepelRadius() {
    const minW = 375;
    const maxW = 1128;
    const w = canvas.clientWidth || window.innerWidth;
    const t = clamp((w - minW) / (maxW - minW), 0, 1);
    const minR = Math.min(repelMinSize, repelMaxSize);
    const maxR = Math.max(repelMinSize, repelMaxSize);
    return minR + (maxR - minR) * t;
  }
  function updateRepelRadius() {
    if (repelResponsive) {
      repelRadius = computeResponsiveRepelRadius();
    }
    // sync UI label if present
    const lbl = document.getElementById('repelSizeVal');
    if (lbl) lbl.textContent = Math.round(repelRadius).toString();
  }
  function powerToRepelSlider(power) {
    const safe = Math.max(1, Number(power));
    const x = safe / (REPEL_BASE_POWER * REPEL_CENTER_MULTIPLIER);
    const s = 0.5 + (Math.log2(x) / REPEL_N_OCTAVES);
    return Math.round(Math.max(0, Math.min(1, s)) * REPEL_SLIDER_MAX);
  }

  // Shadows removed for better performance and realism
  
  // High refresh mode is now default
  let highRefreshMode = true; // Always enabled for best performance
  
  // Rounded corners for simulation area
  let cornerRadius = 0; // Corner radius in pixels (0 = square corners)
  
  // Text collision system
  const TEXT_SELECTOR = '#hero-text'; // ID selector for the main text element
  let textColliders = []; // Array of text collision rectangles
  
  // Behavior modes
  const BEHAVIOR_MODES = { pit: 'pit', flies: 'flies', print: 'print' };
  let behaviorMode = BEHAVIOR_MODES.pit;
  // Flies tuning
  let fliesSpeedMul = 3.4;       // percentage 0.25..4.0
  let fliesMaxSpeed = 1910;      // px/s cap (base)
  let fliesSeekGain = 360;       // acceleration towards light (base)
  let fliesWanderStrength = 120; // idle wander force (base)
  let fliesJitter = 3.0;         // randomness around light target
  let fliesScatterRadius = 490;  // desired orbit radius around light
  let fliesScatterVarPct = 1.00; // 0..1 radius variance per fly
  let lightActive = false;       // whether the light (pointer/touch) is present
  // Trail tuning (formerly print)
  let trailSmoothing = 0;        // -500% to 400% trail smoothing
  let generalSmoothing = 0;      // -500% to 400% general smoothing
  let trailLength = 75;          // maximum trail particles (3x longer)
  let trailSpawnRate = 50;       // ms between trail particles
  let trailLastTime = 0;         // timestamp of last trail particle
  let trailColorIndex = 0;       // current color index for alternation
  let trailPositions = [];       // array of smoothed trail positions
  let targetMouseX = 0;          // smoothed mouse X position
  let targetMouseY = 0;          // smoothed mouse Y position
  // Temporal trail for simple motion blur (0 = off, up to ~0.25)
  let trailFade = 0.025; // from screenshot
  let trailSubtlety = 1.80; // from screenshot
  
  // Performance optimizations and FPS tracking
  let renderFrameCount = 0;
  let physicsStepCount = 0;
  let lastFPSTime = 0;
  let currentRenderFPS = 0;
  let currentPhysicsFPS = 0;
  const renderFpsElement = document.getElementById('render-fps');
  const physicsFpsElement = document.getElementById('physics-fps');
  // Removed performance mode indicators
  
  // Shadow system removed for better performance

  // Ball model - updated to remove 3D rendering
  class Ball {
    constructor(x, y, r, color) {
      this.x = x;
      this.y = y;
      this.vx = (Math.random()*2 - 1) * 200; // random lateral kick
      this.vy = -Math.random()*200;          // slight upward variation
      this.r = r;
      this.m = ballMassKg;                    // all balls share the same mass
      this.color = color;
      this.t = 0;
      // Entry drift state for natural side-throw effect
      this.age = 0;           // seconds since spawn
      this.driftAx = 0;       // lateral acceleration during entry (px/s^2)
      this.driftTime = 0;     // duration of entry drift (s)
      // Spin & squash state
      this.omega = 0;         // angular velocity (rad/s)
      this.squash = 1.0;      // visual squash factor (1 = round)
      this.squashDirX = 1;    // squash direction components (unit vector)
      this.squashDirY = 0;
      // Improved rotation & world-aligned squash
      this.theta = 0;               // integrated angular position (rad)
      this.squashAmount = 0.0;      // 0 = no squash, up to SQUASH_MAX
      this.squashNormalAngle = 0.0; // world-space normal direction for squash
      // Flies/wander state
      this.wanderAngle = Math.random() * Math.PI * 2;
      this.wanderTimer = 0;
      // Snake chain helpers
      this.prevX = x; this.prevY = y;
    }
    // Integrate motion with simple Euler step
    step(dt) {
      // Advance timers
        this.t += dt;
      this.age += dt;

      // Flies mode uses custom integrator (no gravity/standard drag). Early return.
      if (behaviorMode === BEHAVIOR_MODES.flies) {
        stepFlies(this, dt);
        return;
      }
      

      // Gravity scaled by mass to make weight perceptible without changing G globally
      this.vy += (G * gravityScale) * dt;
      // Mass-aware drag (heavier balls lose proportionally less velocity)
      const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
      const drag = Math.max(0, 1 - (FRICTION / massScale));
      this.vx *= drag;
      this.vy *= drag;
      // Apply short-lived lateral drift to simulate being thrown from the side above
      if (this.driftAx !== 0 && this.age < this.driftTime) {
        this.vx += (this.driftAx * dt) / massScale;
      } else if (this.driftAx !== 0) {
        this.driftAx = 0; // Clear drift when expired to skip future checks
      }
      if (behaviorMode === BEHAVIOR_MODES.pit) {
        applyRepeller(this, dt);
      } else if (behaviorMode === BEHAVIOR_MODES.print) {
        // Print mode uses normal physics with gravity
      }
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      // Angular damping
      const spinDamp = Math.max(0, 1 - CONSTANTS.SPIN_DAMP_PER_S * dt);
      this.omega *= spinDamp;
      // Integrate angular position for visible rotation
      this.theta += this.omega * dt;
      if (this.theta > Math.PI) this.theta -= Math.PI * 2; else if (this.theta < -Math.PI) this.theta += Math.PI * 2;
      // Relax squash amount back to 0 (area-preserving)
      const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
      this.squashAmount += (0 - this.squashAmount) * decay;
      this.squash = 1 - this.squashAmount;
    }
    // Resolve collision with walls (with rounded corners)
    // Skip wall collisions for flies behavior
    walls(w, h, dt) {
      if (behaviorMode === BEHAVIOR_MODES.flies) {
        return; // Flies can move beyond boundaries
      }
      if (cornerRadius === 0) {
        // Standard rectangular collision
      if (this.y + this.r > h) { 
        this.y = h - this.r; 
        // Pre-impact speed for squash amplitude
        const preVy = this.vy;
        // Rolling friction & spin from tangential slip
        const slip = this.vx - this.omega * this.r; // world x is tangential at bottom contact
        const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
        // convert part of slip to spin, reduce horizontal speed (rolling tendency)
        this.omega += (slip / this.r) * CONSTANTS.SPIN_GAIN / massScale;
        const rollDamp = Math.max(0, 1 - CONSTANTS.ROLL_FRICTION_PER_S * dt / massScale);
        this.vx *= rollDamp;
        // Bounce with mass-aware restitution
        const wallRest = Math.abs(preVy) < CONSTANTS.WALL_REST_VEL_THRESHOLD ? 0 : REST;
        this.vy = -this.vy * (wallRest * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash on impact using pre-impact speed
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = -Math.PI / 2; // ground normal upwards
        // Ground coupling: tend towards pure rolling without slipping
        const rollTarget = this.vx / this.r;
        this.omega += (rollTarget - this.omega) * Math.min(1, CONSTANTS.GROUND_COUPLING_PER_S * dt);
      }
      if (this.vy > 0 && this.y - this.r < 0) { 
        this.y = this.r; 
        const preVy = this.vy;
        this.vy = -this.vy * REST; 
        const impact = Math.min(1, Math.abs(preVy) / (this.r * 90));
        this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI / 2; // ceiling normal downwards
      }
      if (this.x + this.r > w) { 
        this.x = w - this.r; 
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * REST; 
        const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
        this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // right wall normal leftwards
      }
        if (this.x - this.r < 0) { 
          this.x = this.r; 
          {
            const slip = this.vy - this.omega * this.r;
            const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
            this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
          }
          this.vx = -this.vx * REST; 
          const impact = Math.min(1, Math.abs(this.vx) / (this.r * 90));
          this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
          this.squash = 1 - this.squashAmount;
          this.squashNormalAngle = 0; // left wall normal rightwards
        }
      } else {
        // Rounded corner collision detection
        this.handleRoundedWallCollision(w, h);
      }
      
      // Text collision detection
      this.checkTextCollisions(dt);
    }
    
    // Check collision with text elements
    checkTextCollisions(dt) {
      for (let i = 0; i < textColliders.length; i++) {
        const rect = textColliders[i];
        
        // Check if ball overlaps with text rectangle
        const closestX = Math.max(rect.x, Math.min(this.x, rect.x + rect.width));
        const closestY = Math.max(rect.y, Math.min(this.y, rect.y + rect.height));
        
        const dx = this.x - closestX;
        const dy = this.y - closestY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < this.r) {
          // Collision detected - resolve it
          if (distance === 0) {
            // Ball center is inside rectangle - push out in shortest direction
            const distToLeft = this.x - rect.x;
            const distToRight = (rect.x + rect.width) - this.x;
            const distToTop = this.y - rect.y;
            const distToBottom = (rect.y + rect.height) - this.y;
            
            const minDist = Math.min(distToLeft, distToRight, distToTop, distToBottom);
            
            if (minDist === distToLeft) {
              this.x = rect.x - this.r;
              this.vx = -Math.abs(this.vx) * REST;
            } else if (minDist === distToRight) {
              this.x = rect.x + rect.width + this.r;
              this.vx = Math.abs(this.vx) * REST;
            } else if (minDist === distToTop) {
              this.y = rect.y - this.r;
              this.vy = -Math.abs(this.vy) * REST;
            } else {
              this.y = rect.y + rect.height + this.r;
              this.vy = Math.abs(this.vy) * REST;
            }
          } else {
            // Normal collision resolution
            const overlap = this.r - distance;
            const nx = dx / distance;
            const ny = dy / distance;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity with restitution
            const dotProduct = this.vx * nx + this.vy * ny;
            if (dotProduct < 0) {
              this.vx -= 2 * dotProduct * nx * REST;
              this.vy -= 2 * dotProduct * ny * REST;
              
              // Add squash effect for visual impact
              const impact = Math.min(1, Math.abs(dotProduct) / (this.r * 70));
              this.squash = 1 - CONSTANTS.SQUASH_MAX * impact;
              this.squashDirX = Math.abs(nx) > Math.abs(ny) ? 1 : 0;
              this.squashDirY = Math.abs(ny) > Math.abs(nx) ? 1 : 0;
            }
          }
        }
      }
    }
    
    // Handle collision with rounded corner boundaries
    handleRoundedWallCollision(w, h) {
      const r = cornerRadius;
      
      // Check collision with each corner circle
      const corners = [
        { x: r, y: r },           // Top-left
        { x: w - r, y: r },       // Top-right
        { x: w - r, y: h - r },   // Bottom-right
        { x: r, y: h - r }        // Bottom-left
      ];
      
      for (let i = 0; i < corners.length; i++) {
        const corner = corners[i];
        const dx = this.x - corner.x;
        const dy = this.y - corner.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // Check if ball is in corner region and colliding with corner circle
        const inCornerRegion = this.isInCornerRegion(corner, w, h, r);
        if (inCornerRegion && dist + this.r > r) {
          // Collision with corner circle
          const overlap = r - (dist - this.r);
          if (overlap > 0 && dist > 0) {
            const nx = dx / dist;
            const ny = dy / dist;
            
            // Move ball out of collision
            this.x += nx * overlap;
            this.y += ny * overlap;
            
            // Reflect velocity
            const dot = this.vx * nx + this.vy * ny;
            this.vx -= 2 * dot * nx * REST;
            this.vy -= 2 * dot * ny * REST;
            // Squash aligned to corner normal, proportional to impact
            const impact = Math.min(1, Math.abs(dot) / (this.r * 90));
            this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
            this.squash = 1 - this.squashAmount;
            this.squashNormalAngle = Math.atan2(ny, nx);
          }
        }
      }
      
      // Handle straight wall collisions (outside corner regions)
      // Bottom wall
      if (this.y + this.r > h && (this.x < r || this.x > w - r)) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      
      // Top wall
      if (this.y - this.r < 0 && (this.x < r || this.x > w - r)) {
        this.y = this.r;
        this.vy = -this.vy * REST;
      }
      
      // Right wall
      if (this.x + this.r > w && (this.y < r || this.y > h - r)) {
        this.x = w - this.r;
        // Wall contact: add spin from tangential slip (vertical normal)
        {
          const slip = this.vy - this.omega * this.r; // approximate tangential along y
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        // Squash aligned to wall normal
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = Math.PI; // normal leftwards
      }
      
      // Left wall
      if (this.x - this.r < 0 && (this.y < r || this.y > h - r)) {
        this.x = this.r;
        {
          const slip = this.vy - this.omega * this.r;
          const massScale = Math.max(0.25, this.m / MASS_BASELINE_KG);
          this.omega += (slip / this.r) * (CONSTANTS.SPIN_GAIN * 0.5) / massScale;
        }
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
        const impact = Math.min(1, Math.abs(this.vx)/(this.r*70));
        this.squashAmount = Math.min(CONSTANTS.SQUASH_MAX, impact);
        this.squash = 1 - this.squashAmount;
        this.squashNormalAngle = 0; // normal rightwards
      }
      
      // Handle straight sections of walls
      if (this.y + this.r > h && this.x >= r && this.x <= w - r) {
        this.y = h - this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.y - this.r < 0 && this.x >= r && this.x <= w - r) {
        this.y = this.r;
        this.vy = -this.vy * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x + this.r > w && this.y >= r && this.y <= h - r) {
        this.x = w - this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
      if (this.x - this.r < 0 && this.y >= r && this.y <= h - r) {
        this.x = this.r;
        this.vx = -this.vx * (REST * Math.pow(MASS_BASELINE_KG / this.m, MASS_REST_EXP));
      }
    }
    
    // Check if ball is in a corner region
    isInCornerRegion(corner, w, h, r) {
      // Top-left corner
      if (corner.x === r && corner.y === r) {
        return this.x <= r && this.y <= r;
      }
      // Top-right corner
      if (corner.x === w - r && corner.y === r) {
        return this.x >= w - r && this.y <= r;
      }
      // Bottom-right corner
      if (corner.x === w - r && corner.y === h - r) {
        return this.x >= w - r && this.y >= h - r;
      }
      // Bottom-left corner
      if (corner.x === r && corner.y === h - r) {
        return this.x <= r && this.y >= h - r;
      }
      return false;
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      // World-aligned squash/stretch only if significant
      const amt = Math.min(CONSTANTS.SQUASH_MAX, Math.max(0, this.squashAmount));
      if (amt > 0.001) {
        // Area-preserving squash: s * (1/s) maintains roundness perception
        const s = 1 + amt;
        const inv = 1 / s;
        ctx.rotate(this.squashNormalAngle);
        ctx.scale(s, inv);
        ctx.rotate(-this.squashNormalAngle);
      }
      // Body
      ctx.beginPath();
      ctx.arc(0, 0, this.r, 0, Math.PI*2);
      ctx.fillStyle = this.color;
      ctx.fill();
      // Spin indicator removed for cleaner visuals and performance
      ctx.restore();
    }
  }

  const balls = [];
  // For snake mode, we treat the balls array as an ordered chain
  function initTrail() {
    balls.length = 0; // Clear existing balls
    trailColorIndex = 0; // Reset color alternation
    trailLastTime = 0; // Reset timer
    trailPositions = []; // Clear trail positions
    targetMouseX = mouseX !== CONSTANTS.OFFSCREEN_MOUSE ? mouseX : canvas.width / 2;
    targetMouseY = mouseY !== CONSTANTS.OFFSCREEN_MOUSE ? mouseY : canvas.height / 2;
  }

  function updateTrail(dt, currentTime) {
    // Update smoothed mouse position with general smoothing
    if (mouseX !== CONSTANTS.OFFSCREEN_MOUSE && mouseY !== CONSTANTS.OFFSCREEN_MOUSE) {
      const generalSmoothFactor = getSmoothingFactor(generalSmoothing);
      const smoothRate = generalSmoothFactor * dt * 60; // 60fps normalized
      targetMouseX += (mouseX - targetMouseX) * smoothRate;
      targetMouseY += (mouseY - targetMouseY) * smoothRate;
    }
    
    // Check if it's time to spawn a new trail particle
    if (currentTime - trailLastTime >= trailSpawnRate) {
      if (mouseX !== CONSTANTS.OFFSCREEN_MOUSE && mouseY !== CONSTANTS.OFFSCREEN_MOUSE) {
        // Remove oldest ball if we've reached the trail length limit
        if (balls.length >= trailLength) {
          balls.shift(); // Remove first (oldest) ball
        }
        
        // Create new ball with alternating color
        const r = (R_MIN + R_MAX) / 2; // consistent size
        const color = currentColors[trailColorIndex % currentColors.length];
        trailColorIndex = (trailColorIndex + 1) % currentColors.length;
        
        const ball = new Ball(targetMouseX, targetMouseY, r, color);
        ball.vx = 0; // No initial velocity for trail mode
        ball.vy = 0;
        balls.push(ball);
        
        trailLastTime = currentTime;
      }
    }
    
    // Update existing trail particles to follow with degrading smoothing
    const trailSmoothFactor = getSmoothingFactor(trailSmoothing);
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      const distanceFromHead = balls.length - 1 - i; // 0 for newest, higher for older
      const smoothingDegradation = Math.pow(0.85, distanceFromHead); // Each segment is 15% less smooth
      const followFactor = trailSmoothFactor * smoothingDegradation * dt * 60;
      
      if (i === balls.length - 1) {
        // Newest ball follows the smoothed mouse position
        ball.x += (targetMouseX - ball.x) * followFactor;
        ball.y += (targetMouseY - ball.y) * followFactor;
      } else {
        // Older balls follow the ball ahead of them in the chain
        const nextBall = balls[i + 1];
        ball.x += (nextBall.x - ball.x) * followFactor;
        ball.y += (nextBall.y - ball.y) * followFactor;
      }
    }
  }

  // Convert smoothing percentage (-500% to 400%) to usable factor
  function getSmoothingFactor(smoothingPercent) {
    if (smoothingPercent === 0) return 1.0; // Default: immediate response
    if (smoothingPercent > 0) {
      // Positive values: slower response (more smoothing)
      return 1.0 / (1.0 + smoothingPercent / 100.0);
    } else {
      // Negative values: faster response (less smoothing, more jittery)
      return Math.min(10.0, 1.0 + Math.abs(smoothingPercent) / 100.0);
    }
  }

  // Helpers
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function randBetween(a, b) { return a + Math.random() * (b - a); }
  // Compute mass from radius using current weight slider as density baseline
  // Removed radius-based mass; shared mass is used instead
  
  // Draw rounded boundary visualization
  function drawRoundedBoundary(ctx, w, h) {
    const r = cornerRadius;
    
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    // Start from top-left corner (after the curve)
    ctx.moveTo(r, 0);
    
    // Top edge
    ctx.lineTo(w - r, 0);
    
    // Top-right corner
    ctx.arcTo(w, 0, w, r, r);
    
    // Right edge
    ctx.lineTo(w, h - r);
    
    // Bottom-right corner
    ctx.arcTo(w, h, w - r, h, r);
    
    // Bottom edge
    ctx.lineTo(r, h);
    
    // Bottom-left corner
    ctx.arcTo(0, h, 0, h - r, r);
    
    // Left edge
    ctx.lineTo(0, r);
    
    // Top-left corner
    ctx.arcTo(0, 0, r, 0, r);
    
    ctx.closePath();
    ctx.stroke();
  }
  
  function spawnBall(x, y, color = pickRandomColor()) {
    // Calculate size range with variation (ensure positive values)
    const baseSize = (R_MIN + R_MAX) / 2;
    
    let r;
    if (sizeVariation === 0) {
      // No variation: all balls exactly the same size
      r = baseSize;
    } else {
      // Apply variation
      const range = (R_MAX - R_MIN) / 2;
      const variedRange = range * sizeVariation;
      const minR = Math.max(1, baseSize - variedRange);
      const maxR = baseSize + variedRange;
      r = randBetween(minR, maxR);
    }
    
    const ball = new Ball(x, y, r, color);

    // Natural entry throw with size-aware impulse and sweep-aware direction
    const centerX = canvas.width * 0.5;
    // Prefer current sweep direction if enabled; otherwise side-based
    const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((x < centerX) ? 1 : -1);
    const sizeInfluence = clamp((r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
    const baseKick = 140 * sizeInfluence;  // scale with size
    const randKick = 180 * sizeInfluence;  // scale with size
    const upwardKick = 120;                // small upward speed to soften entry
    ball.vx = dir * (baseKick + Math.random() * randKick);
    ball.vy = -Math.random() * upwardKick;

    // Short lived lateral acceleration to feel like being pushed from the side (size-aware)
    ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence; // px/s^2
    ball.driftTime = 0.22 + Math.random() * 0.28;                    // 0.22‚Äì0.5s of drift

    balls.push(ball);
    return ball;
  }

  // Continuous emitter within a vw/vh-defined rectangle
  let emitterTimer = 0;
  function pickSpawnPoint() {
    const wCss = canvas.clientWidth;
    const hCss = canvas.clientHeight;
    const widthCss = clamp((SPAWN_W_VW / 100) * wCss, 0, wCss);
    let xCenterCss = clamp((SPAWN_X_CENTER_VW / 100) * wCss, 0, wCss);
    // Apply sweeping emitter motion across the band for natural hand-like movement
    if (EMITTER_SWEEP_ENABLED) {
      const amplPx = (EMITTER_SWEEP_AMPL_VW / 100) * wCss;
      const sweepOffset = Math.sin(emitterPhase) * amplPx;
      const prevX = xCenterCss;
      xCenterCss = clamp(xCenterCss + sweepOffset, 0, wCss);
      emitterSweepDir = (xCenterCss >= prevX) ? 1 : -1;
    }
    // Allow slight offscreen horizontal spawn for natural side entry feel
    const offX = Math.min(40, widthCss * 0.1); // up to 40px or 10% width
    const xLeftCss = clamp(xCenterCss - widthCss / 2 - offX, -offX, wCss);
    const xRightCss = clamp(xCenterCss + widthCss / 2 + offX, -offX, wCss);
    const yTopCss = (SPAWN_Y_VH / 100) * hCss;
    const yBotCss = yTopCss + (SPAWN_H_VH / 100) * hCss;
    // Slight bias along sweep direction to emit closer to the leading edge
    const bias = 0.3; // 0 = uniform, 1 = fully biased to leading edge
    const u = Math.random();
    const biased = bias > 0 ? (emitterSweepDir > 0 ? Math.pow(u, 1 - bias) : 1 - Math.pow(1 - u, 1 - bias)) : u;
    const x = (xLeftCss + (xRightCss - xLeftCss) * biased) * DPR;
    // Add slight upward randomness to spawn height for organic feel
    const y = randBetween(yTopCss * DPR, yBotCss * DPR) - (R_MAX + CONSTANTS.BALL_SPAWN_OFFSET + randBetween(0, 10 * DPR));
    return { x, y };
  }
  function emit(dt) {
    emitterTimer += dt;
    while (emitterTimer >= EMIT_INTERVAL) {
      // Jitter emissions slightly for organic timing
      const jitter = (Math.random() - 0.5) * EMIT_INTERVAL * 0.5; // ¬±25%
      emitterTimer -= (EMIT_INTERVAL + jitter);
      // Advance sweep phase based on elapsed time segment (approx)
      emitterPhase += (2 * Math.PI) * EMITTER_SWEEP_HZ * (EMIT_INTERVAL + jitter);
      const p = pickSpawnPoint();
      // Occasionally emit small clusters to mimic handful tosses
      const drops = (Math.random() < 0.35 ? 3 : 1);
      for (let i=0; i<drops; i++) {
        if (balls.length < MAX_BALLS) {
          // Slight horizontal staggering to suggest sideways motion
          const xOffset = i * CONSTANTS.BALL_CLUSTER_SPACING * (Math.random() < 0.5 ? 1 : -1);
          spawnBall(p.x + xOffset, p.y - i * CONSTANTS.BALL_CLUSTER_Y_OFFSET);
        }
      }
    }
  }

  // Spatial hash grid to accelerate broad-phase (optimized)
  const spatialGrid = new Map();
  
  function collectPairsSorted() {
    const n = balls.length;
    if (n < 2) return []; // Early exit for trivial cases
    const cellSize = Math.max(1, R_MAX * 2); // Optimized cell size
    const gridWidth = Math.ceil(canvas.width / cellSize) + 1; // Dynamic grid width
    spatialGrid.clear(); // Reuse map
    
    // Build grid with numeric keys (faster than string concatenation)
    for (let i = 0; i < n; i++) {
      const b = balls[i];
      const cx = (b.x / cellSize) | 0;
      const cy = (b.y / cellSize) | 0;
      const key = cy * gridWidth + cx; // Numeric key
      let arr = spatialGrid.get(key);
      if (!arr) { arr = []; spatialGrid.set(key, arr); }
      arr.push(i);
    }
    
    const pairs = [];
    for (const [key, arr] of spatialGrid) {
      const cy = (key / gridWidth) | 0;
      const cx = key % gridWidth;
      
      // Check 9 neighboring cells (including self)
      for (let oy = -1; oy <= 1; oy++) {
        for (let ox = -1; ox <= 1; ox++) {
          const neighborKey = (cy + oy) * gridWidth + (cx + ox);
          const nb = spatialGrid.get(neighborKey);
          if (!nb) continue;
          
          for (let ii = 0; ii < arr.length; ii++) {
            const i = arr[ii];
            for (let jj = 0; jj < nb.length; jj++) {
              const j = nb[jj];
              if (j <= i) continue;
              
              const A = balls[i], B = balls[j];
              const dx = B.x - A.x, dy = B.y - A.y;
              const rSum = A.r + B.r;
              const dist2 = dx*dx + dy*dy;
              
              if (dist2 < rSum*rSum) {
                const dist = Math.sqrt(Math.max(dist2, CONSTANTS.MIN_DISTANCE_EPSILON));
                const overlap = rSum - dist;
                pairs.push({ i, j, overlap });
              }
            }
          }
        }
      }
    }
    
    // Sort by overlap (most overlapping first for stability)
    pairs.sort((a, b) => b.overlap - a.overlap);
    return pairs;
  }

  // Circle‚Äìcircle collisions: sequential impulses + Baumgarte positional correction
  function resolveCollisions(iterations = SOLVER_ITERS) {
    const pairs = collectPairsSorted();
    for (let iter = 0; iter < iterations; iter++) {
      for (let k = 0; k < pairs.length; k++) {
        const { i, j } = pairs[k];
        const A = balls[i];
        const B = balls[j];
        const dx = B.x - A.x;
        const dy = B.y - A.y;
        const rSum = A.r + B.r;
        const dist2 = dx * dx + dy * dy;
        // Performance optimization: early exits
        if (dist2 === 0 || dist2 > rSum * rSum) continue;
        // Skip very small overlaps for performance (< 5% overlap)
        if (dist2 > rSum * rSum * 0.95) continue;
        const dist = Math.sqrt(dist2);
        const nx = dx / dist;
        const ny = dy / dist;
        const overlap = rSum - dist;
        const invA = 1 / Math.max(A.m, 0.001);
        const invB = 1 / Math.max(B.m, 0.001);

        // Positional correction
        const correctionMag = POS_CORRECT_PERCENT * Math.max(overlap - POS_CORRECT_SLOP, 0) / (invA + invB);
        const cx = correctionMag * nx;
        const cy = correctionMag * ny;
        A.x -= cx * invA; A.y -= cy * invA;
        B.x += cx * invB; B.y += cy * invB;

        // Velocity impulse along the normal
        const rvx = B.vx - A.vx;
        const rvy = B.vy - A.vy;
        const velAlongNormal = rvx * nx + rvy * ny;
        if (velAlongNormal < 0) {
          const e = Math.abs(velAlongNormal) < REST_VEL_THRESHOLD ? 0 : REST;
          const j = -(1 + e) * velAlongNormal / (invA + invB);
          const ix = j * nx;
          const iy = j * ny;
          A.vx -= ix * invA; A.vy -= iy * invA;
          B.vx += ix * invB; B.vy += iy * invB;

          // Tangential slip to spin (approximate rolling/spin transfer)
          const tvx = rvx - velAlongNormal * nx;
          const tvy = rvy - velAlongNormal * ny;
          const slipMag = Math.hypot(tvx, tvy);
          if (slipMag > 1e-3) {
            const tangentSign = (tvx * -ny + tvy * nx) >= 0 ? 1 : -1; // right-hand tangent
            const gain = CONSTANTS.SPIN_GAIN_TANGENT;
            A.omega -= tangentSign * gain * slipMag / Math.max(A.r, 1);
            B.omega += tangentSign * gain * slipMag / Math.max(B.r, 1);
          }
          // Visual squash aligned to contact normal based on impact
          const impact = Math.min(1, Math.abs(velAlongNormal) / ((A.r + B.r) * 50));
          const sAmt = Math.min(CONSTANTS.SQUASH_MAX, impact * 0.8);
          A.squashAmount = Math.max(A.squashAmount, sAmt * 0.8);
          A.squashNormalAngle = Math.atan2(-ny, -nx);
          B.squashAmount = Math.max(B.squashAmount, sAmt * 0.8);
          B.squashNormalAngle = Math.atan2(ny, nx);
        }
      }
    }
  }

  // Main loop optimized for 120fps
  let last = performance.now() / 1000;
  let acc = 0;
  const DT = 1/120; // Target 120fps physics
  function frame(nowMs) {
    const now = nowMs / 1000;
    let dt = Math.min(0.008, now - last); // Cap at ~120fps for high refresh displays
    last = now;
    acc += dt;

  // FPS counters (render and physics) - only update if elements exist
    renderFrameCount++;
    if ((renderFpsElement || physicsFpsElement) && now - lastFPSTime >= CONSTANTS.FPS_UPDATE_INTERVAL) {
      if (renderFpsElement && renderFrameCount !== currentRenderFPS) {
        currentRenderFPS = renderFrameCount;
        renderFpsElement.textContent = currentRenderFPS.toString();
      }
      if (physicsFpsElement && physicsStepCount !== currentPhysicsFPS) {
        currentPhysicsFPS = physicsStepCount;
        physicsFpsElement.textContent = currentPhysicsFPS.toString();
      }
      
      renderFrameCount = 0;
      physicsStepCount = 0;
      lastFPSTime = now;
    }

    // Emit only for pit/flies (other modes manage their own balls)
    if (behaviorMode !== BEHAVIOR_MODES.print) emit(dt);
    
    // Update text colliders periodically (every ~60 frames for performance)
    if (renderFrameCount % 60 === 0) {
      updateTextColliders();
    }

    // Physics iterations optimized for realistic, stable simulation
    let physicsSteps = 0;
    while (acc >= DT && physicsSteps < CONSTANTS.MAX_PHYSICS_STEPS) {
      if (behaviorMode === BEHAVIOR_MODES.print) {
        updateTrail(DT, now * 1000); // Convert to milliseconds
      } else {
        for (let i=0; i<balls.length; i++) balls[i].step(DT);
        resolveCollisions(3); // Balanced quality vs performance
        for (let i=0; i<balls.length; i++) balls[i].walls(canvas.width, canvas.height, DT);
      }
      acc -= DT;
      physicsSteps++;
      physicsStepCount++; // Count physics steps for FPS measurement
    }
    
    // Reset accumulator if we're falling behind
    if (acc > DT * CONSTANTS.ACCUMULATOR_RESET_THRESHOLD) acc = 0;

    // Clear or fade canvas for motion blur trail
    if (trailFade > 0 && trailSubtlety > 0) {
      // Map sliders to effective fade alpha
      const TRAIL_FADE_UI_MAX = 1.5;      // slider max for trail length
      const TRAIL_SUBTLE_UI_MAX = 3.0;    // slider max for subtlety
      const maxAlpha = 0.35;              // shortest trail (more aggressive clear)
      const minAlpha = 0.0015;            // longest trail (very subtle clear)
      const normLen = Math.max(0, Math.min(1, trailFade / TRAIL_FADE_UI_MAX));
      const baseFade = maxAlpha + (minAlpha - maxAlpha) * normLen; // low slider -> big fade
      const subtleNorm = Math.max(0, Math.min(1, trailSubtlety / TRAIL_SUBTLE_UI_MAX));
      // Blend between full clear (1.0 alpha) at low subtlety and baseFade at high subtlety
      let effectiveFade = 1.0 + (baseFade - 1.0) * subtleNorm;
      // Clamp to safe bounds
      effectiveFade = Math.max(0.001, Math.min(1.0, effectiveFade));
      ctx.fillStyle = `rgba(0,0,0,${effectiveFade})`;
      ctx.globalCompositeOperation = 'destination-out';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.globalCompositeOperation = 'source-over';
    } else {
      ctx.clearRect(0,0,canvas.width,canvas.height);
    }
    
    // Draw rounded boundary if corner radius > 0 (cache boundary path for performance)
    if (cornerRadius > 0) {
      drawRoundedBoundary(ctx, canvas.width, canvas.height);
    }
    
    // Shadow rendering removed for better performance and realism
    
    // Render balls with individual colors
    for (let i=0; i<balls.length; i++) balls[i].draw(ctx);
    // Draw cursor ball last
    drawCursorBall(ctx);

    // Use requestAnimationFrame for proper vsync
    requestAnimationFrame(frame);
  }
  
  // Start the main loop with requestAnimationFrame
  console.log('High refresh mode enabled - using requestAnimationFrame');
  requestAnimationFrame(frame);

  // Reset balls to spawn positions (preserves all settings)
  function resetBallsToSpawn() {
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      const p = pickSpawnPoint();
      ball.x = p.x;
      ball.y = p.y;
      // Re-apply natural entry throw on reset (sweep-aware, size-aware)
      const centerX = canvas.width * 0.5;
      const dir = EMITTER_SWEEP_ENABLED ? (emitterSweepDir >= 0 ? 1 : -1) : ((ball.x < centerX) ? 1 : -1);
      const sizeInfluence = clamp((ball.r / ((R_MIN + R_MAX) * 0.5)), 0.6, 1.4);
      const baseKick = 140 * sizeInfluence;
      const randKick = 180 * sizeInfluence;
      const upwardKick = 120;
      ball.vx = dir * (baseKick + Math.random() * randKick);
      ball.vy = -Math.random() * upwardKick;
      ball.age = 0;
      ball.driftAx = dir * (360 + Math.random() * 420) * sizeInfluence;
      ball.driftTime = 0.22 + Math.random() * 0.28;
    }
  }

  // Keyboard: reset balls to spawn, toggle panel
  window.addEventListener('keydown', e => {
    const k = e.key.toLowerCase();
    if (k === 'r') {
      // Move balls back to spawn area - preserve all parameter settings
      resetBallsToSpawn();
      e.preventDefault(); // Prevent any default browser behavior
    }
    if (k === '/' && panel) {
      e.preventDefault();
      panel.classList.toggle('hidden');
    }
  });

  // Seed initial balls across the spawn area for quicker fill
  function seedArea(n = 160) {
    for (let i=0; i<n && balls.length < MAX_BALLS; i++) {
      const p = pickSpawnPoint();
      spawnBall(p.x, p.y);
    }
  }
  seedArea(CONSTANTS.INITIAL_SEED_BALLS);

  // Initialize panel to show correct controls for default mode
  updatePanelForMode(behaviorMode);

  // Shadow system removed for better performance



  // Pointer-first input for repeller (covers mouse, pen, touch)
  if (HAS_POINTER_EVENTS) {
    canvas.addEventListener('pointerdown', (e) => {
      lastPointerType = e.pointerType || 'mouse';
      if (e.pointerType === 'touch') {
        isTouchActive = true;
        activePointerId = e.pointerId;
        updateRepellerFromClient(e.clientX, e.clientY);
        if (repelPower > 0 && repelRadius > 0) repellerEnabled = true;
        lightActive = true;
        try { canvas.setPointerCapture(e.pointerId); } catch (_) {}
      } else {
        updateRepellerFromClient(e.clientX, e.clientY);
        if (repelPower > 0 && repelRadius > 0) repellerEnabled = true;
        lightActive = true;
      }
    }, { passive: true });

    canvas.addEventListener('pointermove', (e) => {
      lastPointerType = e.pointerType || lastPointerType;
      if (e.pointerType === 'touch') {
        if (isTouchActive && e.pointerId === activePointerId) {
          updateRepellerFromClient(e.clientX, e.clientY);
        }
      } else if (e.pointerType === 'mouse' || e.pointerType === 'pen') {
        updateRepellerFromClient(e.clientX, e.clientY);
        if (repelPower > 0 && repelRadius > 0) repellerEnabled = true;
        lightActive = true;
      }
    }, { passive: true });

    const clearTouch = () => { isTouchActive = false; activePointerId = null; mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE; };
    canvas.addEventListener('pointerup', (e) => { if (e.pointerType === 'touch') { clearTouch(); lightActive = false; } }, { passive: true });
    canvas.addEventListener('pointercancel', (e) => { if (e.pointerType === 'touch') { clearTouch(); lightActive = false; } }, { passive: true });
    canvas.addEventListener('pointerleave', (e) => {
      if (e.pointerType === 'mouse' || e.pointerType === 'pen') { mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE; lightActive = false; }
    }, { passive: true });
  } else {
    // Fallback: mouse + touch events
    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * DPR;
      mouseY = (e.clientY - rect.top) * DPR;
      if (repelPower > 0 && repelRadius > 0) repellerEnabled = true;
      lightActive = true;
    });
    canvas.addEventListener('mouseleave', () => { mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE; lightActive = false; });

    canvas.addEventListener('touchstart', (e) => {
      if (!e.touches || e.touches.length === 0) return;
      isTouchActive = true;
      const t = e.touches[0];
      updateRepellerFromClient(t.clientX, t.clientY);
      if (repelPower > 0 && repelRadius > 0) repellerEnabled = true;
      lightActive = true;
    }, { passive: true });
    canvas.addEventListener('touchmove', (e) => {
      if (!isTouchActive || !e.touches || e.touches.length === 0) return;
      const t = e.touches[0];
      updateRepellerFromClient(t.clientX, t.clientY);
      // prevent page scroll while interacting with the canvas
      if (typeof e.preventDefault === 'function') e.preventDefault();
    }, { passive: false });
    const endTouch = () => { isTouchActive = false; mouseX = CONSTANTS.OFFSCREEN_MOUSE; mouseY = CONSTANTS.OFFSCREEN_MOUSE; lightActive = false; };
    canvas.addEventListener('touchend', endTouch, { passive: true });
    canvas.addEventListener('touchcancel', endTouch, { passive: true });
  }

  // Draw a cursor as a ball matching the simulation style
  function drawCursorBall(ctx) {
    // Hide cursor ball entirely on mobile-like inputs
    if (hideCursorOnMobile && isMobileLikeInput()) return;
    // Hide cursor ball while actively touching (finger occludes)
    if (isTouchActive && lastPointerType === 'touch') return;
    if (mouseX === CONSTANTS.OFFSCREEN_MOUSE || mouseY === CONSTANTS.OFFSCREEN_MOUSE) return;
    const x = mouseX, y = mouseY;
    const baseSize = (R_MIN + R_MAX) / 2;
    const r = baseSize;
    const color = cursorBallColor;
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
  }

  function applyRepeller(b, dt) {
    // Respect "Off" template by treating zero or near-zero params as disabled
    if (!repellerEnabled) return;
    if (repelPower <= 0 || repelRadius <= 0) return;
    const rPx = repelRadius * DPR;
    const dx = b.x - mouseX;
    const dy = b.y - mouseY;
    const d2 = dx*dx + dy*dy;
    const r2 = rPx * rPx;
    if (d2 > r2) return;
    const d = Math.max(Math.sqrt(d2), CONSTANTS.MIN_REPEL_DISTANCE);
    const nx = dx / d;
    const ny = dy / d;
    const q = Math.max(0, 1 - d / rPx);
    const strength = (repelPower * REPELLER_GLOBAL_MULTIPLIER) * Math.pow(q, repelSoft);
    // Heavier balls respond less to the same field
    const massScale = Math.max(0.25, b.m / MASS_BASELINE_KG);
    b.vx += (nx * strength * dt) / massScale;
    b.vy += (ny * strength * dt) / massScale;
  }

  // Flies behavior: boids-like wander + seek with drift; custom integrator
  function stepFlies(b, dt) {
    const massScale = Math.max(0.25, b.m / MASS_BASELINE_KG);
    // Slight air drag only
    const drag = Math.max(0, 1 - (FRICTION * 0.2 / massScale));
    b.vx *= drag; b.vy *= drag;

    // Wander: slowly rotate a unit vector and add as acceleration
    b.wanderTimer += dt;
    if (b.wanderTimer > 0.08) {
      b.wanderTimer = 0;
      b.wanderAngle += (Math.random() - 0.5) * 0.9;
    }
    let ax = Math.cos(b.wanderAngle) * (fliesWanderStrength * fliesSpeedMul);
    let ay = Math.sin(b.wanderAngle) * (fliesWanderStrength * fliesSpeedMul);

    // Seek the light when active: spring-damper towards a moving orbit target with jitter
    if (lightActive && mouseX !== CONSTANTS.OFFSCREEN_MOUSE && mouseY !== CONSTANTS.OFFSCREEN_MOUSE) {
      // Each fly gets a pseudo-stable orbit radius using its inherent random seed
      if (b._scatterPhase === undefined) { b._scatterPhase = Math.random() * Math.PI * 2; }
      if (b._scatterFactor === undefined) { b._scatterFactor = 1 + (Math.random() * 2 - 1) * fliesScatterVarPct; }
      const radius = Math.max(0, fliesScatterRadius * b._scatterFactor) * DPR;
      b._scatterPhase += dt * (0.6 + Math.random() * 0.8) * fliesSpeedMul; // slow orbiting
      // Orbit center around mouse
      let tx = mouseX + Math.cos(b._scatterPhase) * radius;
      let ty = mouseY + Math.sin(b._scatterPhase) * radius;
      // Jitter to avoid lock-step
      tx += (Math.random() - 0.5) * fliesJitter * 20 * DPR;
      ty += (Math.random() - 0.5) * fliesJitter * 20 * DPR;
      const dx = tx - b.x; const dy = ty - b.y;
      // Critical damping approx: a = k*dx - c*v
      const k = (fliesSeekGain * 0.8) * fliesSpeedMul; // slightly lower to keep orbit-y feel
      const c = Math.sqrt(k) * 1.8; // damping term to prevent overshoot
      ax += k * dx - c * b.vx;
      ay += k * dy - c * b.vy;
    }

    // Apply acceleration (mass-aware), integrate
    b.vx += (ax * dt) / massScale;
    b.vy += (ay * dt) / massScale;

    // Clamp speed for lively motion, not slow-mo
    const maxS = Math.max(200, fliesMaxSpeed * fliesSpeedMul);
    const sp = Math.hypot(b.vx, b.vy);
    if (sp > maxS) { const k = maxS / sp; b.vx *= k; b.vy *= k; }

    b.x += b.vx * dt;
    b.y += b.vy * dt;
    
    // Ensure balls remain circular by resetting squash in flies mode
    const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
    b.squashAmount += (0 - b.squashAmount) * decay;
    b.squash = 1 - b.squashAmount;
  }

  // UI elements
  const frictionSlider = document.getElementById('frictionSlider');
  const emitterSlider = document.getElementById('emitterSlider');
    
    // Apply liquid forces
    applyLiquidCohesion(b, dt);
    applyLiquidSurfaceTension(b, dt);
    applyLiquidBuoyancy(b, dt);
    
    // Integrate motion
    b.x += b.vx * dt;
    b.y += b.vy * dt;
    
    // Maintain circular shape (liquid particles stay round)
    const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
    b.squashAmount += (0 - b.squashAmount) * decay;
    b.squash = 1 - b.squashAmount;
  }

  // UI elements
  const frictionSlider = document.getElementById('frictionSlider');
  const emitterSlider = document.getElementById('emitterSlider');
  const sizeSlider = document.getElementById('sizeSlider');
  const maxBallsSlider = document.getElementById('maxBallsSlider');
  const sizeVariationSlider = document.getElementById('sizeVariationSlider');
  const weightSlider = document.getElementById('weightSlider');
  const spawnYSlider = document.getElementById('spawnYSlider');
  const spawnWidthSlider = document.getElementById('spawnWidthSlider');
  const spawnCenterSlider = document.getElementById('spawnCenterSlider');
  const spawnHeightSlider = document.getElementById('spawnHeightSlider');
  const repelSizeSlider = document.getElementById('repelSizeSlider');
  const repelPowerSlider = document.getElementById('repelPowerSlider');
  const repelSoftSlider = document.getElementById('repelSoftSlider');
  // Color controls
  const colorSelect = document.getElementById('colorSelect');
  const color1 = document.getElementById('color1');
  const color2 = document.getElementById('color2');
  const color3 = document.getElementById('color3');
            const dist = Math.sqrt(distSq);
            const strength = liquidCohesion * (1 - dist / cohesionRadius);
            const nx = deltaX / dist;
            const ny = deltaY / dist;
            
            fx += nx * strength;
            fy += ny * strength;
            neighborCount++;
          }
        }
      }
    }
    
    if (neighborCount > 0) {
      ball.vx += (fx * dt) / massScale;
      ball.vy += (fy * dt) / massScale;
    }
  }

  // Apply surface tension: smooth out blob surfaces (optimized with spatial grid)
  function applyLiquidSurfaceTension(ball, dt) {
    const tensionRadius = ball.r * 1.8;
    const massScale = Math.max(0.25, ball.m / MASS_BASELINE_KG);
    let fx = 0, fy = 0;
    let neighborCount = 0;
    
    // Use spatial grid for performance - only check nearby cells
    const cellSize = Math.max(1, R_MAX * 2);
    const gridWidth = Math.ceil(canvas.width / cellSize) + 1;
    const cx = (ball.x / cellSize) | 0;
    const cy = (ball.y / cellSize) | 0;
    
    // Check 3x3 grid around ball
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const key = (cy + dy) * gridWidth + (cx + dx);
        const cellBalls = spatialGrid.get(key);
        if (!cellBalls) continue;
        
        for (let i = 0; i < cellBalls.length; i++) {
          const otherIndex = cellBalls[i];
          const other = balls[otherIndex];
          if (other === ball) continue;
          
          const deltaX = other.x - ball.x;
          const deltaY = other.y - ball.y;
          const distSq = deltaX * deltaX + deltaY * deltaY;
          const tensionRadiusSq = tensionRadius * tensionRadius;
          
          if (distSq < tensionRadiusSq && distSq > 0.01) {
            const dist = Math.sqrt(distSq);
            const desiredDist = (ball.r + other.r) * 1.1;
            const diff = desiredDist - dist;
            const strength = liquidSurfaceTension * diff * 0.5;
            
            const nx = deltaX / dist;
            const ny = deltaY / dist;
            
            fx += nx * strength;
            fy += ny * strength;
            neighborCount++;
          }
        }
      }
    }
    
    if (neighborCount > 0) {
      ball.vx += (fx * dt) / massScale;
      ball.vy += (fy * dt) / massScale;
    }
  }

  // Apply temperature-based buoyancy (lava lamp effect)
  function applyLiquidBuoyancy(ball, dt) {
    const massScale = Math.max(0.25, ball.m / MASS_BASELINE_KG);
    
    // Get temperature at ball position (higher near mouse/touch)
    const temp = getLiquidTemperature(ball.x, ball.y);
    
    // Hot liquid rises, cool liquid sinks
    const buoyancyForce = (temp - 0.5) * liquidBuoyancy * liquidTempSensitivity;
    ball.vy -= (buoyancyForce * dt) / massScale;
    
    // Add slight thermal convection (horizontal movement)
    const convectionForce = Math.sin(ball.x * 0.01 + performance.now() * 0.001) * buoyancyForce * 0.3;
    ball.vx += (convectionForce * dt) / massScale;
  }

  // Get temperature at a position (0 = cold, 1 = hot)
  function getLiquidTemperature(x, y) {
    // Update temperature map periodically for performance
    liquidTempUpdateTimer += 16; // Assume ~60fps
    if (liquidTempUpdateTimer > 100) { // Update every ~6 frames
      updateLiquidTemperatureMap();
      liquidTempUpdateTimer = 0;
    }
    
    // Base temperature (cooler at bottom, warmer at top for lava lamp effect)
    let temp = 0.3 + (canvas.height - y) / canvas.height * 0.2;
    
    // Add heat from mouse/touch interaction
    if (mouseX !== CONSTANTS.OFFSCREEN_MOUSE && mouseY !== CONSTANTS.OFFSCREEN_MOUSE) {
      const dx = x - mouseX;
      const dy = y - mouseY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const heatRadius = 150 * DPR;
      
      if (dist < heatRadius) {
        const heatStrength = (1 - dist / heatRadius) * 0.6;
        temp += heatStrength;
      }
    }
    
    return Math.max(0, Math.min(1, temp));
  }

  // Update temperature map for spatial caching (performance optimization)
  function updateLiquidTemperatureMap() {
    liquidTemperatureMap.clear();
    // Temperature map is computed on-demand in getLiquidTemperature for simplicity
    // This function exists for future spatial caching optimizations
  }

  // Metaball rendering for liquid behavior
  function drawLiquidMetaballs(ctx) {
    if (balls.length === 0) return;
    
    // Performance optimization: use composite operation for metaball effect
    ctx.save();
    
    // First pass: draw all balls with additive blending
    ctx.globalCompositeOperation = 'lighter';
    
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      
      // Get temperature for color variation
      const temp = getLiquidTemperature(ball.x, ball.y);
      
      // Create gradient based on temperature
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, ball.r);
      
      // Hot areas are brighter/more orange, cool areas are darker
      const baseColor = ball.color;
      const rgb = hexToRgb(baseColor);
      if (rgb) {
        const intensity = 0.3 + temp * 0.7;
        const warmth = temp * 0.3;
        
        gradient.addColorStop(0, `rgba(${Math.min(255, rgb.r + warmth * 100)}, ${Math.min(255, rgb.g + warmth * 50)}, ${rgb.b}, ${intensity})`);
        gradient.addColorStop(0.7, `rgba(${Math.min(255, rgb.r + warmth * 50)}, ${Math.min(255, rgb.g + warmth * 25)}, ${rgb.b}, ${intensity * 0.6})`);
        gradient.addColorStop(1, `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0)`);
      } else {
        // Fallback if color parsing fails
        gradient.addColorStop(0, `rgba(255, 255, 255, ${0.3 + temp * 0.7})`);
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
      }
      
      ctx.save();
      ctx.translate(ball.x, ball.y);
      
      // Draw metaball with gradient
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, ball.r * liquidMergeThreshold, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.restore();
    }
    
    ctx.restore();
  }

  // Helper function to convert hex color to RGB
  function hexToRgb(hex) {
    const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return result ? {
      r: parseInt(result[1], 16),
      g: parseInt(result[2], 16),
      b: parseInt(result[3], 16)
    } : null;
  }

  // Magnetic behavior: balls act as magnetic particles with polarity and field interactions
  function stepMagnetic(ball, dt) {
    // Initialize magnetic properties if not set
    if (ball.magneticPolarity === undefined) {
      ball.magneticPolarity = Math.random() < 0.5 ? 1 : -1; // North or South
      ball.magneticCharge = Math.random() * 0.5 + 0.5; // 0.5 to 1.0 charge strength
    }
    
    // Apply standard gravity (reduced)
    ball.vy += (G * gravityScale * 0.3) * dt;
    
    // Apply magnetic forces
    applyMagneticFieldForces(ball, dt);
    applyMagneticInteractions(ball, dt);
    
    // Random polarity flips based on chaos setting
    if (Math.random() < (magnetPolarityChaos / 100) * dt) {
      ball.magneticPolarity *= -1;
      // Chance to switch color on polarity flip
      if (Math.random() < (magnetColorSwitch / 100)) {
        ball.color = pickRandomColor();
      }
    }
    
    // Integrate motion
    ball.x += ball.vx * dt;
    ball.y += ball.vy * dt;
    
    // Maintain circular shape
    const decay = Math.min(1, CONSTANTS.SQUASH_DECAY_PER_S * dt);
    ball.squashAmount += (0 - ball.squashAmount) * decay;
    ball.squash = 1 - ball.squashAmount;
  }

  // Apply magnetic field forces (invisible field lines across the canvas)
  function applyMagneticFieldForces(ball, dt) {
    // Update field directions periodically
    magnetFieldTimer += dt;
    if (magnetFieldTimer > 2.0 || magnetFieldDirections.length === 0) {
      magnetFieldDirections = [];
      for (let i = 0; i < magnetFieldLines; i++) {
        magnetFieldDirections.push({
          angle: (i / magnetFieldLines) * Math.PI * 2,
          strength: 0.5 + Math.random() * 0.5,
          centerX: Math.random() * canvas.width,
          centerY: Math.random() * canvas.height
        });
      }
      magnetFieldTimer = 0;
    }
    
    // Apply forces from each field line
    for (let i = 0; i < magnetFieldDirections.length; i++) {
      const field = magnetFieldDirections[i];
      const dx = ball.x - field.centerX;
      const dy = ball.y - field.centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > magnetRange) continue;
      
      // Field strength decreases with distance
      const fieldInfluence = (1 - dist / magnetRange) * field.strength;
      const force = magnetFieldStrength * ball.magneticCharge * ball.magneticPolarity * fieldInfluence;
      
      // Force perpendicular to field line (like magnetic field)
      const fieldDx = Math.cos(field.angle);
      const fieldDy = Math.sin(field.angle);
      
      // Cross product for perpendicular force
      const perpX = -fieldDy;
      const perpY = fieldDx;
      
      ball.vx += perpX * force * dt;
      ball.vy += perpY * force * dt;
      
      // Add spinning motion around field lines
      if (magnetSpinForce > 0) {
        const spinForce = magnetSpinForce * fieldInfluence * ball.magneticPolarity;
        const spinX = -dy / Math.max(dist, 1);
        const spinY = dx / Math.max(dist, 1);
        
        ball.vx += spinX * spinForce * dt;
        ball.vy += spinY * spinForce * dt;
      }
    }
  }

  // Apply magnetic interactions between balls
  function applyMagneticInteractions(ball, dt) {
    for (let i = 0; i < balls.length; i++) {
      const other = balls[i];
      if (other === ball) continue;
      if (other.magneticPolarity === undefined) continue;
      
      const dx = other.x - ball.x;
      const dy = other.y - ball.y;
      const distSq = dx * dx + dy * dy;
      const maxInteractionDist = magnetRange * 0.8;
      
      if (distSq > maxInteractionDist * maxInteractionDist) continue;
      if (distSq < 1) continue; // Avoid singularity
      
      const dist = Math.sqrt(distSq);
      const nx = dx / dist;
      const ny = dy / dist;
      
      // Magnetic force: opposite polarities attract, same polarities repel
      const polarityProduct = ball.magneticPolarity * other.magneticPolarity;
      const chargeProduct = ball.magneticCharge * other.magneticCharge;
      const force = -polarityProduct * chargeProduct * magnetFieldStrength * 0.5 / distSq;
      
      ball.vx += nx * force * dt;
      ball.vy += ny * force * dt;
    }
  }

  // Initialize magnetic behavior
  function initMagnetic() {
    balls.length = 0; // Clear existing balls
    magnetFieldDirections = []; // Reset field directions
    magnetFieldTimer = 0;
    
    // Create magnetic particles
    const numParticles = Math.min(80, MAX_BALLS);
    for (let i = 0; i < numParticles; i++) {
      const x = Math.random() * canvas.width;
      const y = Math.random() * canvas.height;
      const r = (R_MIN + R_MAX) / 2;
      const color = pickRandomColor();
      
      const ball = new Ball(x, y, r, color);
      ball.magneticPolarity = Math.random() < 0.5 ? 1 : -1;
      ball.magneticCharge = Math.random() * 0.5 + 0.5;
      
      // Small initial velocities
      ball.vx = (Math.random() - 0.5) * 100;
      ball.vy = (Math.random() - 0.5) * 100;
      
      balls.push(ball);
    }
  }

  // UI elements
  const restitutionSlider = document.getElementById('restitutionSlider');
  const frictionSlider = document.getElementById('frictionSlider');
  const emitterSlider = document.getElementById('emitterSlider');
  const sizeSlider = document.getElementById('sizeSlider');
  const maxBallsSlider = document.getElementById('maxBallsSlider');
  const sizeVariationSlider = document.getElementById('sizeVariationSlider');
  const weightSlider = document.getElementById('weightSlider');
  const spawnYSlider = document.getElementById('spawnYSlider');
  const spawnWidthSlider = document.getElementById('spawnWidthSlider');
  const spawnCenterSlider = document.getElementById('spawnCenterSlider');
  const spawnHeightSlider = document.getElementById('spawnHeightSlider');
  const repelSizeSlider = document.getElementById('repelSizeSlider');
  const repelPowerSlider = document.getElementById('repelPowerSlider');
  const repelSoftSlider = document.getElementById('repelSoftSlider');
  // Color controls
  const colorSelect = document.getElementById('colorSelect');
  const color1 = document.getElementById('color1');
  const color2 = document.getElementById('color2');
  const color3 = document.getElementById('color3');
  const color4 = document.getElementById('color4');
  const color5 = document.getElementById('color5');
  const color6 = document.getElementById('color6');
  const color7 = document.getElementById('color7');
  const color8 = document.getElementById('color8');
  const cursorColorSelect = document.getElementById('cursorColorSelect');
  // Hex spans
  const color1Val = document.getElementById('color1Val');
  const color2Val = document.getElementById('color2Val');
  const color3Val = document.getElementById('color3Val');
  const color4Val = document.getElementById('color4Val');
  const color5Val = document.getElementById('color5Val');
  const color6Val = document.getElementById('color6Val');
  const color7Val = document.getElementById('color7Val');
  const color8Val = document.getElementById('color8Val');
  // Tooltip hint for copy action
  [color1Val, color2Val, color3Val, color4Val, color5Val, color6Val, color7Val, color8Val].forEach(el => {
    if (el) el.setAttribute('title', 'Click to copy');
  });
  // Scene controls
  const cornerRadiusSlider = document.getElementById('cornerRadiusSlider');
  const cornerRadiusVal = document.getElementById('cornerRadiusVal');
  const trailFadeSlider = document.getElementById('trailFadeSlider');
  const trailFadeVal = document.getElementById('trailFadeVal');
  const trailSubtletySlider = document.getElementById('trailSubtletySlider');
  const trailSubtletyVal = document.getElementById('trailSubtletyVal');
  
  // Behavior sliders/controls
  const behaviorSelect = document.getElementById('behaviorSelect');
  const fliesMaxSpeedSlider = document.getElementById('fliesMaxSpeedSlider');
  const fliesSeekGainSlider = document.getElementById('fliesSeekGainSlider');
  const fliesWanderSlider = document.getElementById('fliesWanderSlider');
  const fliesJitterSlider = document.getElementById('fliesJitterSlider');
  const fliesSpeedMulSlider = document.getElementById('fliesSpeedMulSlider');
  const fliesScatterRadiusSlider = document.getElementById('fliesScatterRadiusSlider');
  const fliesScatterVarSlider = document.getElementById('fliesScatterVarSlider');
  const fliesMaxSpeedVal = document.getElementById('fliesMaxSpeedVal');
  const fliesSeekGainVal = document.getElementById('fliesSeekGainVal');
  const fliesWanderVal = document.getElementById('fliesWanderVal');
  const fliesJitterVal = document.getElementById('fliesJitterVal');
  const fliesSpeedMulVal = document.getElementById('fliesSpeedMulVal');
  const fliesScatterRadiusVal = document.getElementById('fliesScatterRadiusVal');
  const fliesScatterVarVal = document.getElementById('fliesScatterVarVal');
  const snakeSegmentsSlider = document.getElementById('snakeSegmentsSlider');
  const snakeSpacingSlider = document.getElementById('snakeSpacingSlider');
  // Removed explicit head gain and max speed sliders to simplify UI
  const snakeSpeedMulSlider = document.getElementById('snakeSpeedMulSlider');
  const snakeSegmentsVal = document.getElementById('snakeSegmentsVal');
  const snakeSpacingVal = document.getElementById('snakeSpacingVal');
  // Values are derived from speed multiplier and defaults now
  const snakeSpeedMulVal = document.getElementById('snakeSpeedMulVal');
  const snakeSwayAmpSlider = document.getElementById('snakeSwayAmpSlider');
  const snakeSwayFreqSlider = document.getElementById('snakeSwayFreqSlider');
  const snakeIdleWanderSlider = document.getElementById('snakeIdleWanderSlider');
  const snakeSwayAmpVal = document.getElementById('snakeSwayAmpVal');
  const snakeSwayFreqVal = document.getElementById('snakeSwayFreqVal');
  const snakeIdleWanderVal = document.getElementById('snakeIdleWanderVal');

  const restitutionVal = document.getElementById('restitutionVal');
  const frictionVal = document.getElementById('frictionVal');
  const emitterVal = document.getElementById('emitterVal');
  const sizeVal = document.getElementById('sizeVal');
  const maxBallsVal = document.getElementById('maxBallsVal');
  const sizeVariationVal = document.getElementById('sizeVariationVal');
  const weightVal = document.getElementById('weightVal');
  const spawnYVal = document.getElementById('spawnYVal');
  const spawnWidthVal = document.getElementById('spawnWidthVal');
  const spawnCenterVal = document.getElementById('spawnCenterVal');
  const spawnHeightVal = document.getElementById('spawnHeightVal');
  const repelSizeVal = document.getElementById('repelSizeVal');
  const repelPowerVal = document.getElementById('repelPowerVal');
  const repelSoftVal = document.getElementById('repelSoftVal');
  // Scene controls vals (shadows removed)

  // Config capture and build functionality (restored)
  function captureCurrentConfig() {
    return {
      gravityMultiplier,
      restitution: REST,
      friction: FRICTION,
      ballMass: ballMassKg,
      emitRate: EMIT_INTERVAL,
      maxBalls: MAX_BALLS,
      ballScale: sizeScale,
      ballVariation: sizeVariation,
      spawnX: SPAWN_X_CENTER_VW,
      spawnY: SPAWN_Y_VH,
      spawnWidth: SPAWN_W_VW,
      spawnHeight: SPAWN_H_VH,
      sweepEnabled: EMITTER_SWEEP_ENABLED,
      repelRadius,
      repelPower,
      repelSoftness: repelSoft,
      repelResponsive,
      repelMinSize,
      repelMaxSize,
      trailFade,
      trailSubtlety,
      behaviorMode,
      // Flies
      fliesSpeedMul,
      fliesMaxSpeed,
      fliesSeekGain,
      fliesWanderStrength,
      fliesJitter,
      fliesScatterRadius,
      fliesScatterVarPct,
      // Trail (formerly Print)
      trailSmoothing,
      generalSmoothing,
      trailLength,
      trailSpawnRate,
      colors: currentColors.slice(),
      colorWeights: COLOR_WEIGHTS.slice(),
      currentTemplate,
      cursorColorIndex: cursorBallIndex
    };
  }
  function generateConfigCode(config) {
    return `// Generated configuration from frontend\nconst CONFIG = ${JSON.stringify(config, null, 2)};`;
  }
  const saveConfigBtn = document.getElementById('saveConfigBtn');
  const buildBtn = document.getElementById('buildBtn');
  const configOutput = document.getElementById('configOutput');
  if (saveConfigBtn && buildBtn && configOutput) {
    saveConfigBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      const configJson = JSON.stringify(config, null, 2);
      
      // Show the config and instructions
      configOutput.style.display = 'block';
      configOutput.innerHTML = `
<strong>üíæ Configuration Export</strong><br><br>
<strong>Option 1: Auto-save to file</strong><br>
Copy this command and run in terminal:<br>
<code style="background: #f0f0f0; padding: 2px 4px; border-radius: 2px; font-size: 9px; display: block; margin: 4px 0; word-break: break-all;">echo '${configJson.replace(/'/g, "\\'")}' | npm run save-config</code><br>
<strong>Option 2: Manual download</strong><br>
<button id="downloadConfigBtn" style="background: #FF9800; color: white; border: none; padding: 4px 8px; border-radius: 2px; cursor: pointer; font-size: 10px; margin: 4px 0;">üì• Download JSON</button><br><br>
<strong>Current Configuration:</strong><br>
<pre style="background: #f8f8f8; padding: 6px; border-radius: 3px; font-size: 8px; max-height: 100px; overflow-y: auto; margin: 4px 0;">${configJson}</pre>`;
      
      // Add download functionality
      const downloadBtn = document.getElementById('downloadConfigBtn');
      if (downloadBtn) {
        downloadBtn.addEventListener('click', () => {
          const blob = new Blob([configJson], { type: 'application/json' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = 'current-config.json';
          a.click();
          URL.revokeObjectURL(url);
          
          downloadBtn.textContent = '‚úÖ Downloaded!';
          setTimeout(() => { downloadBtn.textContent = 'üì• Download JSON'; }, 1200);
        });
      }
      
      // Copy the terminal command to clipboard
      const command = `echo '${configJson.replace(/'/g, "\\'")}' | npm run save-config`;
      navigator.clipboard.writeText(command).then(() => {
        const old = saveConfigBtn.textContent;
        saveConfigBtn.textContent = '‚úÖ Command Copied!';
        setTimeout(() => { saveConfigBtn.textContent = old; }, 2000);
      }).catch(() => {
        console.warn('Clipboard copy failed');
        const old = saveConfigBtn.textContent;
        saveConfigBtn.textContent = '‚ö†Ô∏è Copy failed';
        setTimeout(() => { saveConfigBtn.textContent = old; }, 1200);
      });
    });
    buildBtn.addEventListener('click', () => {
      const config = captureCurrentConfig();
      configOutput.style.display = 'block';
      configOutput.innerHTML = `
<strong>üöÄ Build Instructions:</strong><br>
1. Run: <code>npm run build</code><br>
2. Your current config will be baked into <code>public/js/bouncy-balls-embed.js</code>`;
      const blob = new Blob([JSON.stringify(config, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a'); a.href = url; a.download = 'current-config.json'; a.click();
      URL.revokeObjectURL(url);
    });
  }

  // Click-to-copy helper
  function bindCopyOnClick(el, getText) {
    if (!el) return;
    el.addEventListener('click', async () => {
      const text = typeof getText === 'function' ? getText() : String(getText || '').trim();
      try {
        await navigator.clipboard.writeText(text);
        const old = el.textContent;
        el.textContent = 'COPIED';
        el.style.color = '#3ddc84';
        setTimeout(() => { el.textContent = old; el.style.color = '#888'; }, 900);
      } catch (e) {
        console.warn('Clipboard unavailable');
      }
    });
  }

  // Sliders
  restitutionSlider && restitutionSlider.addEventListener('input', () => { REST = parseFloat(restitutionSlider.value); restitutionVal && (restitutionVal.textContent = REST.toFixed(2)); });
  frictionSlider && frictionSlider.addEventListener('input', () => { FRICTION = parseFloat(frictionSlider.value); frictionVal && (frictionVal.textContent = FRICTION.toFixed(4)); });
  emitterSlider && emitterSlider.addEventListener('input', () => { EMIT_INTERVAL = parseFloat(emitterSlider.value); emitterVal && (emitterVal.textContent = EMIT_INTERVAL.toFixed(3)); });
  sizeSlider && sizeSlider.addEventListener('input', () => {
    const newScale = parseFloat(sizeSlider.value);
    sizeVal && (sizeVal.textContent = newScale.toFixed(1));
    sizeScale = newScale;
    // Recompute effective scale and proportionally resize existing balls
    updateEffectiveScaleAndBallSizes();
    // Keep shared mass
    for (let i=0; i<balls.length; i++) { balls[i].m = ballMassKg; }
  });
  maxBallsSlider && maxBallsSlider.addEventListener('input', () => {
    MAX_BALLS = parseInt(maxBallsSlider.value, 10);
    maxBallsVal && (maxBallsVal.textContent = MAX_BALLS.toString());
    // Remove excess balls if current count exceeds new limit (remove from end for better performance)
    if (balls.length > MAX_BALLS) {
      balls.length = MAX_BALLS; // Truncate array efficiently
    }
  });
  sizeVariationSlider && sizeVariationSlider.addEventListener('input', () => {
    sizeVariation = parseFloat(sizeVariationSlider.value);
    sizeVariationVal && (sizeVariationVal.textContent = sizeVariation.toFixed(1));
    
    // Update existing ball sizes to reflect new variation
    updateExistingBallSizes();
  });
  weightSlider && weightSlider.addEventListener('input', () => {
    ballMassKg = parseFloat(weightSlider.value);
    weightVal && (weightVal.textContent = ballMassKg.toFixed(2));
    // Apply shared mass to all balls
    for (let i=0; i<balls.length; i++) { balls[i].m = ballMassKg; }
    // Recompute derived scaling so gravity visibly changes with weight
    recomputeMassDerivedScales();
  });
  
  // Function to update existing ball sizes based on current sizeVariation
  function updateExistingBallSizes() {
    const baseSize = (R_MIN + R_MAX) / 2;
    
    for (let i = 0; i < balls.length; i++) {
      const ball = balls[i];
      
      if (sizeVariation === 0) {
        // No variation: all balls exactly the same size
        ball.r = baseSize;
      } else {
        // Apply variation
        const range = (R_MAX - R_MIN) / 2;
        const variedRange = range * sizeVariation;
        const minR = Math.max(1, baseSize - variedRange);
        const maxR = baseSize + variedRange;
        ball.r = randBetween(minR, maxR);
      }
      
      // Keep shared mass model (no per-ball recompute)
      ball.m = ballMassKg;
    }
  }
  spawnYSlider && spawnYSlider.addEventListener('input', () => {
    SPAWN_Y_VH = parseFloat(spawnYSlider.value);
    spawnYVal && (spawnYVal.textContent = SPAWN_Y_VH.toFixed(0));
    setCSSSize(); resize();
  });
  spawnWidthSlider && spawnWidthSlider.addEventListener('input', () => { SPAWN_W_VW = parseFloat(spawnWidthSlider.value); spawnWidthVal && (spawnWidthVal.textContent = SPAWN_W_VW.toFixed(0)); });
  spawnCenterSlider && spawnCenterSlider.addEventListener('input', () => { SPAWN_X_CENTER_VW = parseFloat(spawnCenterSlider.value); spawnCenterVal && (spawnCenterVal.textContent = SPAWN_X_CENTER_VW.toFixed(0)); });
  spawnHeightSlider && spawnHeightSlider.addEventListener('input', () => { SPAWN_H_VH = parseFloat(spawnHeightSlider.value); spawnHeightVal && (spawnHeightVal.textContent = SPAWN_H_VH.toFixed(0)); });
  repelSizeSlider && repelSizeSlider.addEventListener('input', () => {
    const v = parseFloat(repelSizeSlider.value);
    // When user adjusts explicit size, temporarily disable responsive sizing
    repelResponsive = false;
    repelRadius = v;
    repelSizeVal && (repelSizeVal.textContent = repelRadius.toFixed(0));
    repellerEnabled = repellerEnabled || (repelPower > 0 && repelRadius > 0); 
  });

  // Responsive repel UI controls
  const repelResponsiveToggle = document.getElementById('repelResponsiveToggle');
  const repelMinSizeSlider = document.getElementById('repelMinSizeSlider');
  const repelMaxSizeSlider = document.getElementById('repelMaxSizeSlider');
  const repelMinSizeVal = document.getElementById('repelMinSizeVal');
  const repelMaxSizeVal = document.getElementById('repelMaxSizeVal');
  repelResponsiveToggle && repelResponsiveToggle.addEventListener('change', () => {
    repelResponsive = !!repelResponsiveToggle.checked;
    if (repelResponsive) {
      updateRepelRadius();
    }
  });
  repelMinSizeSlider && repelMinSizeSlider.addEventListener('input', () => {
    repelMinSize = parseFloat(repelMinSizeSlider.value);
    if (repelMinSizeVal) repelMinSizeVal.textContent = Math.round(repelMinSize).toString();
    if (repelResponsive) updateRepelRadius();
  });
  repelMaxSizeSlider && repelMaxSizeSlider.addEventListener('input', () => {
    repelMaxSize = parseFloat(repelMaxSizeSlider.value);
    if (repelMaxSizeVal) repelMaxSizeVal.textContent = Math.round(repelMaxSize).toString();
    if (repelResponsive) updateRepelRadius();
  });
  repelPowerSlider && repelPowerSlider.addEventListener('input', () => {
    repelPower = repelSliderToPower(repelPowerSlider.value);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    // Do not auto-enable when template is Off; only enable via template or size/power explicit >0 with mouse over
    if (repellerSelect && repellerSelect.value !== 'off') {
      repellerEnabled = repelPower > 0 && repelRadius > 0; 
    }
  });
  repelSoftSlider && repelSoftSlider.addEventListener('input', () => {
    repelSoft = parseFloat(repelSoftSlider.value);
    repelSoftVal && (repelSoftVal.textContent = repelSoft.toFixed(1));
  });
  // Shadow event listeners removed
  
  // Color controls
  colorSelect && colorSelect.addEventListener('change', () => {
    const template = COLOR_TEMPLATES[colorSelect.value];
    if (!template) return;
    currentTemplate = colorSelect.value;
    currentColors = template.colors.slice();
    // Keep cursor index and update color
    cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor;
    // Update color pickers + hex spans
    if (color1 && color1Val) { color1.value = currentColors[0]; color1Val.textContent = currentColors[0].toUpperCase(); }
    if (color2 && color2Val) { color2.value = currentColors[1]; color2Val.textContent = currentColors[1].toUpperCase(); }
    if (color3 && color3Val) { color3.value = currentColors[2]; color3Val.textContent = currentColors[2].toUpperCase(); }
    if (color4 && color4Val) { color4.value = currentColors[3]; color4Val.textContent = currentColors[3].toUpperCase(); }
    if (color5 && color5Val) { color5.value = currentColors[4]; color5Val.textContent = currentColors[4].toUpperCase(); }
    if (color6 && color6Val) { color6.value = currentColors[5]; color6Val.textContent = currentColors[5].toUpperCase(); }
    if (color7 && color7Val) { color7.value = currentColors[6]; color7Val.textContent = currentColors[6].toUpperCase(); }
    if (color8 && color8Val) { color8.value = currentColors[7]; color8Val.textContent = currentColors[7].toUpperCase(); }
    // Update existing ball colors
    updateExistingBallColors();
    // Sync CSS variables
    syncPaletteVars();
  });

  // Individual color picker listeners (with existing ball color update)
  function updateExistingBallColors() {
    // Update colors of existing balls to use new color palette
    for (let i = 0; i < balls.length; i++) {
      balls[i].color = pickRandomColor();
    }
  }
  
  color1 && color1.addEventListener('input', () => { currentColors[0] = color1.value; color1Val && (color1Val.textContent = color1.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color2 && color2.addEventListener('input', () => { currentColors[1] = color2.value; color2Val && (color2Val.textContent = color2.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color3 && color3.addEventListener('input', () => { currentColors[2] = color3.value; color3Val && (color3Val.textContent = color3.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color4 && color4.addEventListener('input', () => { currentColors[3] = color4.value; color4Val && (color4Val.textContent = color4.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color5 && color5.addEventListener('input', () => { currentColors[4] = color5.value; color5Val && (color5Val.textContent = color5.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color6 && color6.addEventListener('input', () => { currentColors[5] = color6.value; color6Val && (color6Val.textContent = color6.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color7 && color7.addEventListener('input', () => { currentColors[6] = color7.value; color7Val && (color7Val.textContent = color7.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  color8 && color8.addEventListener('input', () => { currentColors[7] = color8.value; color8Val && (color8Val.textContent = color8.value.toUpperCase()); updateExistingBallColors(); syncPaletteVars(); });
  cursorColorSelect && cursorColorSelect.addEventListener('change', () => { const idx = Math.max(1, Math.min(8, parseInt(cursorColorSelect.value, 10))) - 1; cursorBallIndex = idx; cursorBallColor = currentColors[cursorBallIndex] || cursorBallColor; });

  // Bind click-to-copy on hex badges
  bindCopyOnClick(color1Val, () => color1.value.toUpperCase());
  bindCopyOnClick(color2Val, () => color2.value.toUpperCase());
  bindCopyOnClick(color3Val, () => color3.value.toUpperCase());
  bindCopyOnClick(color4Val, () => color4.value.toUpperCase());
  bindCopyOnClick(color5Val, () => color5.value.toUpperCase());
  bindCopyOnClick(color6Val, () => color6.value.toUpperCase());
  bindCopyOnClick(color7Val, () => color7.value.toUpperCase());
  bindCopyOnClick(color8Val, () => color8.value.toUpperCase());
  // If the user changes any color, keep the cursor color stable unless it was the one changed
  // To keep behavior simple, we do not auto-switch the cursor color here.
  
  // Scene control event listeners
  cornerRadiusSlider && cornerRadiusSlider.addEventListener('input', () => { 
    cornerRadius = parseFloat(cornerRadiusSlider.value); 
    cornerRadiusVal && (cornerRadiusVal.textContent = cornerRadius.toFixed(0)); 
  });
  trailFadeSlider && trailFadeSlider.addEventListener('input', () => { 
    trailFade = parseFloat(trailFadeSlider.value); 
    trailFadeVal && (trailFadeVal.textContent = trailFade.toFixed(3)); 
  });
  trailSubtletySlider && trailSubtletySlider.addEventListener('input', () => {
    trailSubtlety = parseFloat(trailSubtletySlider.value);
    trailSubtletyVal && (trailSubtletyVal.textContent = trailSubtlety.toFixed(2) + '√ó');
  });

  // Segmented behavior control listeners
  const segmentButtons = document.querySelectorAll('.segment-button');
  segmentButtons.forEach(button => {
    button.addEventListener('click', () => {
      // Remove active class from all buttons
      segmentButtons.forEach(btn => btn.classList.remove('active'));
      // Add active class to clicked button
      button.classList.add('active');
      
      // Update behavior mode
      const mode = button.getAttribute('data-behavior');
      behaviorMode = (BEHAVIOR_MODES[mode] || BEHAVIOR_MODES.pit);
      
      // Update panel to show relevant controls
      updatePanelForMode(behaviorMode);
      
      if (behaviorMode === BEHAVIOR_MODES.print) {
        initTrail();
      }
    });
  });
  fliesSpeedMulSlider && fliesSpeedMulSlider.addEventListener('input', () => { fliesSpeedMul = parseFloat(fliesSpeedMulSlider.value) / 100; fliesSpeedMulVal && (fliesSpeedMulVal.textContent = Math.round(parseFloat(fliesSpeedMulSlider.value)) + '%'); });
  fliesMaxSpeedSlider && fliesMaxSpeedSlider.addEventListener('input', () => { fliesMaxSpeed = parseFloat(fliesMaxSpeedSlider.value); fliesMaxSpeedVal && (fliesMaxSpeedVal.textContent = Math.round(fliesMaxSpeed).toString()); });
  fliesSeekGainSlider && fliesSeekGainSlider.addEventListener('input', () => { fliesSeekGain = parseFloat(fliesSeekGainSlider.value); fliesSeekGainVal && (fliesSeekGainVal.textContent = Math.round(fliesSeekGain).toString()); });
  fliesWanderSlider && fliesWanderSlider.addEventListener('input', () => { fliesWanderStrength = parseFloat(fliesWanderSlider.value); fliesWanderVal && (fliesWanderVal.textContent = Math.round(fliesWanderStrength).toString()); });
  fliesJitterSlider && fliesJitterSlider.addEventListener('input', () => { fliesJitter = parseFloat(fliesJitterSlider.value); fliesJitterVal && (fliesJitterVal.textContent = fliesJitter.toFixed(1)); });
  fliesScatterRadiusSlider && fliesScatterRadiusSlider.addEventListener('input', () => { fliesScatterRadius = parseFloat(fliesScatterRadiusSlider.value); fliesScatterRadiusVal && (fliesScatterRadiusVal.textContent = Math.round(fliesScatterRadius).toString()); });
  fliesScatterVarSlider && fliesScatterVarSlider.addEventListener('input', () => { fliesScatterVarPct = parseFloat(fliesScatterVarSlider.value) / 100; fliesScatterVarVal && (fliesScatterVarVal.textContent = Math.round(parseFloat(fliesScatterVarSlider.value)) + '%'); });
  // Trail behavior event listeners
  const trailSmoothingSlider = document.getElementById('trailSmoothingSlider');
  const trailSmoothingVal = document.getElementById('trailSmoothingVal');
  const generalSmoothingSlider = document.getElementById('generalSmoothingSlider');
  const generalSmoothingVal = document.getElementById('generalSmoothingVal');
  const trailLengthSlider = document.getElementById('trailLengthSlider');
  const trailLengthVal = document.getElementById('trailLengthVal');
  const trailSpawnRateSlider = document.getElementById('trailSpawnRateSlider');
  const trailSpawnRateVal = document.getElementById('trailSpawnRateVal');
  
  trailSmoothingSlider && trailSmoothingSlider.addEventListener('input', () => { 
    trailSmoothing = parseInt(trailSmoothingSlider.value, 10); 
    trailSmoothingVal && (trailSmoothingVal.textContent = trailSmoothing + '%'); 
  });
  generalSmoothingSlider && generalSmoothingSlider.addEventListener('input', () => { 
    generalSmoothing = parseInt(generalSmoothingSlider.value, 10); 
    generalSmoothingVal && (generalSmoothingVal.textContent = generalSmoothing + '%'); 
  });
  trailLengthSlider && trailLengthSlider.addEventListener('input', () => { 
    trailLength = parseInt(trailLengthSlider.value, 10); 
    trailLengthVal && (trailLengthVal.textContent = trailLength.toString()); 
  });
  trailSpawnRateSlider && trailSpawnRateSlider.addEventListener('input', () => { 
    trailSpawnRate = parseInt(trailSpawnRateSlider.value, 10); 
    trailSpawnRateVal && (trailSpawnRateVal.textContent = trailSpawnRate.toString()); 
  });

  // Liquid behavior event listeners
  const liquidViscositySlider = document.getElementById('liquidViscositySlider');
  const liquidViscosityVal = document.getElementById('liquidViscosityVal');
  const liquidCohesionSlider = document.getElementById('liquidCohesionSlider');
  const liquidCohesionVal = document.getElementById('liquidCohesionVal');
  const liquidSurfaceTensionSlider = document.getElementById('liquidSurfaceTensionSlider');
  const liquidSurfaceTensionVal = document.getElementById('liquidSurfaceTensionVal');
  const liquidTempSensitivitySlider = document.getElementById('liquidTempSensitivitySlider');
  const liquidTempSensitivityVal = document.getElementById('liquidTempSensitivityVal');
  const liquidMergeThresholdSlider = document.getElementById('liquidMergeThresholdSlider');
  const liquidMergeThresholdVal = document.getElementById('liquidMergeThresholdVal');
  const liquidBuoyancySlider = document.getElementById('liquidBuoyancySlider');
  const liquidBuoyancyVal = document.getElementById('liquidBuoyancyVal');

  liquidViscositySlider && liquidViscositySlider.addEventListener('input', () => { 
    liquidViscosity = parseFloat(liquidViscositySlider.value); 
    liquidViscosityVal && (liquidViscosityVal.textContent = liquidViscosity.toFixed(2)); 
  });
  liquidCohesionSlider && liquidCohesionSlider.addEventListener('input', () => { 
    liquidCohesion = parseFloat(liquidCohesionSlider.value); 
    liquidCohesionVal && (liquidCohesionVal.textContent = Math.round(liquidCohesion).toString()); 
  });
  liquidSurfaceTensionSlider && liquidSurfaceTensionSlider.addEventListener('input', () => { 
    liquidSurfaceTension = parseFloat(liquidSurfaceTensionSlider.value); 
    liquidSurfaceTensionVal && (liquidSurfaceTensionVal.textContent = liquidSurfaceTension.toFixed(2)); 
  });
  liquidTempSensitivitySlider && liquidTempSensitivitySlider.addEventListener('input', () => { 
    liquidTempSensitivity = parseFloat(liquidTempSensitivitySlider.value); 
    liquidTempSensitivityVal && (liquidTempSensitivityVal.textContent = liquidTempSensitivity.toFixed(1)); 
  });
  liquidMergeThresholdSlider && liquidMergeThresholdSlider.addEventListener('input', () => { 
    liquidMergeThreshold = parseFloat(liquidMergeThresholdSlider.value); 
    liquidMergeThresholdVal && (liquidMergeThresholdVal.textContent = liquidMergeThreshold.toFixed(1)); 
  });
  liquidBuoyancySlider && liquidBuoyancySlider.addEventListener('input', () => { 
    liquidBuoyancy = parseFloat(liquidBuoyancySlider.value); 
    liquidBuoyancyVal && (liquidBuoyancyVal.textContent = Math.round(liquidBuoyancy).toString()); 
  });

  // Magnetic behavior event listeners
  const magnetFieldStrengthSlider = document.getElementById('magnetFieldStrengthSlider');
  const magnetFieldStrengthVal = document.getElementById('magnetFieldStrengthVal');
  const magnetPolarityChaosSlider = document.getElementById('magnetPolarityChaosSlider');
  const magnetPolarityChaosVal = document.getElementById('magnetPolarityChaosVal');
  const magnetFieldLinesSlider = document.getElementById('magnetFieldLinesSlider');
  const magnetFieldLinesVal = document.getElementById('magnetFieldLinesVal');
  const magnetSpinForceSlider = document.getElementById('magnetSpinForceSlider');
  const magnetSpinForceVal = document.getElementById('magnetSpinForceVal');
  const magnetRangeSlider = document.getElementById('magnetRangeSlider');
  const magnetRangeVal = document.getElementById('magnetRangeVal');
  const magnetColorSwitchSlider = document.getElementById('magnetColorSwitchSlider');
  const magnetColorSwitchVal = document.getElementById('magnetColorSwitchVal');

  magnetFieldStrengthSlider && magnetFieldStrengthSlider.addEventListener('input', () => { 
    magnetFieldStrength = parseFloat(magnetFieldStrengthSlider.value); 
    magnetFieldStrengthVal && (magnetFieldStrengthVal.textContent = Math.round(magnetFieldStrength).toString()); 
  });
  magnetPolarityChaosSlider && magnetPolarityChaosSlider.addEventListener('input', () => { 
    magnetPolarityChaos = parseFloat(magnetPolarityChaosSlider.value); 
    magnetPolarityChaosVal && (magnetPolarityChaosVal.textContent = Math.round(magnetPolarityChaos) + '%'); 
  });
  magnetFieldLinesSlider && magnetFieldLinesSlider.addEventListener('input', () => { 
    magnetFieldLines = parseInt(magnetFieldLinesSlider.value, 10); 
    magnetFieldLinesVal && (magnetFieldLinesVal.textContent = magnetFieldLines.toString()); 
    magnetFieldDirections = []; // Reset field directions when count changes
  });
  magnetSpinForceSlider && magnetSpinForceSlider.addEventListener('input', () => { 
    magnetSpinForce = parseFloat(magnetSpinForceSlider.value); 
    magnetSpinForceVal && (magnetSpinForceVal.textContent = Math.round(magnetSpinForce).toString()); 
  });
  magnetRangeSlider && magnetRangeSlider.addEventListener('input', () => { 
    magnetRange = parseFloat(magnetRangeSlider.value); 
    magnetRangeVal && (magnetRangeVal.textContent = Math.round(magnetRange).toString()); 
  });
  magnetColorSwitchSlider && magnetColorSwitchSlider.addEventListener('input', () => { 
    magnetColorSwitch = parseFloat(magnetColorSwitchSlider.value); 
    magnetColorSwitchVal && (magnetColorSwitchVal.textContent = Math.round(magnetColorSwitch) + '%'); 
  });

  // Presets (10 each)
  // Rubber-focused physics presets under Earth gravity (‚âà1960 px/s¬≤)
  const PHYSICS_PRESETS = {
    rubberPlayground: { label: 'Rubber ‚Äì Playground', G: 1960, REST: 0.90, FRICTION: 0.0025, sizeScale: 1.8, maxBalls: 450, sizeVariation: 0.20 },
    rubberRacquet:    { label: 'Rubber ‚Äì Racquetball', G: 3320, REST: 0.97, FRICTION: 0.0035, sizeScale: 2.1, maxBalls: 350, sizeVariation: 0.30 },
    rubberSuperball:  { label: 'Rubber ‚Äì Superball', G: 1960, REST: 0.95, FRICTION: 0.0015, sizeScale: 1.2, maxBalls: 450, sizeVariation: 0.05 },
    rubberSoft:       { label: 'Rubber ‚Äì Soft', G: 1960, REST: 0.86, FRICTION: 0.0035, sizeScale: 2.2, maxBalls: 350, sizeVariation: 0.25 },
    rubberHeavy:      { label: 'Rubber ‚Äì Heavy', G: 1960, REST: 0.88, FRICTION: 0.0030, sizeScale: 2.0, maxBalls: 400, sizeVariation: 0.15 }
  };

  const SPAWN_PRESETS = {
    fullRain:       { label: 'Full Rain (top-half)', EMIT_INTERVAL: 0.030, xCenter: 50, y: -50, w: 100, h: 50 },
    narrowStrip:    { label: 'Narrow Strip Top', EMIT_INTERVAL: 0.050, xCenter: 50, y: -40, w: 20,  h: 10 },
    leftGutter:     { label: 'Left Gutter', EMIT_INTERVAL: 0.045, xCenter: 10, y: -60, w: 18,  h: 20 },
    rightGutter:    { label: 'Right Gutter', EMIT_INTERVAL: 0.045, xCenter: 90, y: -60, w: 18,  h: 20 },
    centerFountain: { label: 'Center Fountain', EMIT_INTERVAL: 0.020, xCenter: 50, y: -30, w: 30,  h: 20 },
    stormBurst:     { label: 'Storm Burst', EMIT_INTERVAL: 0.005, xCenter: 50, y: -80, w: 100, h: 30 },
    slowSnow:       { label: 'Slow Snow', EMIT_INTERVAL: 0.200, xCenter: 50, y: -30, w: 100, h: 20 },
    edgeDrizzle:    { label: 'Edge Drizzle', EMIT_INTERVAL: 0.080, xCenter: 15, y: -40, w: 30,  h: 15 },
    twinColumns:    { label: 'Twin Columns', EMIT_INTERVAL: 0.030, xCenter: 30, y: -50, w: 10,  h: 40 },
    focusedBeam:    { label: 'Focused Beam', EMIT_INTERVAL: 0.015, xCenter: 50, y: -70, w: 6,   h: 12 }
  };

  const REPELLER_PRESETS = {
    off:         { label: 'Off', r: 710,   p: 27400 * 10, s: 4.4 },
    gentle:      { label: 'Gentle Breeze', r: 120, p: 2500, s: 2.5 },
    pushField:   { label: 'Push Field', r: 240, p: 8000 * 10, s: 2.0 },
    tractor:     { label: 'Tractor Push', r: 320, p: 14000 * 10, s: 1.6 },
    magnet:      { label: 'Magnet Repel', r: 200, p: 18000 * 10, s: 3.0 },
    pulse:       { label: 'Pulse Strong', r: 280, p: 22000 * 10, s: 1.2 },
    wideSoft:    { label: 'Wide Soft', r: 500, p: 8000 * 10, s: 4.5 },
    needle:      { label: 'Needle Point', r: 80,  p: 26000 * 10, s: 0.8 },
    wall:        { label: 'Invisible Wall', r: 700, p: 16000 * 10, s: 5.0 },
    singularity: { label: 'Singularity', r: 600, p: 30000 * 10, s: 0.5 }
  };

  // Shadow presets removed for better performance


  // Populate selects
  function fillSelect(select, dict, selectedKey) {
    select.innerHTML = '';
    for (const [key, val] of Object.entries(dict)) {
      const opt = document.createElement('option');
      opt.value = key; opt.textContent = val.label || key; if (key === selectedKey) opt.selected = true;
      select.appendChild(opt);
    }
  }

  const physicsSelect = document.getElementById('physicsSelect');
  const spawnSelect = document.getElementById('spawnSelect');
  const repellerSelect = document.getElementById('repellerSelect');

  if (physicsSelect) fillSelect(physicsSelect, PHYSICS_PRESETS, 'rubberHeavy');
  if (spawnSelect) fillSelect(spawnSelect, SPAWN_PRESETS, 'fullRain');
  if (repellerSelect) fillSelect(repellerSelect, REPELLER_PRESETS, 'off');
  // Populate color template dropdown
  if (colorSelect) fillSelect(colorSelect, COLOR_TEMPLATES, 'industrialTeal');

  // Helper function for UI updates
  function updateSliderAndValue(slider, valueElement, value, decimals = 0) {
    if (slider) slider.value = String(value);
    if (valueElement) valueElement.textContent = decimals > 0 ? value.toFixed(decimals) : value.toString();
  }

  // Update panel to show controls relevant to the current mode
  function updatePanelForMode(mode) {
    const modeControlsTitle = document.getElementById('modeControlsTitle');
    const pitControls = document.getElementById('pitControls');
    const fliesControls = document.getElementById('fliesControls');
    const trailControls = document.getElementById('trailControls');
    
    // Hide all mode-specific controls
    if (pitControls) pitControls.style.display = 'none';
    if (fliesControls) fliesControls.style.display = 'none';
    if (trailControls) trailControls.style.display = 'none';
    
    // Show relevant controls and update title
    switch (mode) {
      case BEHAVIOR_MODES.pit:
        if (modeControlsTitle) modeControlsTitle.textContent = 'üéØ Ball Pit Controls';
        if (pitControls) pitControls.style.display = 'block';
        break;
      case BEHAVIOR_MODES.flies:
        if (modeControlsTitle) modeControlsTitle.textContent = 'üïäÔ∏è Flies to Light Controls';
        if (fliesControls) fliesControls.style.display = 'block';
        break;
      case BEHAVIOR_MODES.print:
        if (modeControlsTitle) modeControlsTitle.textContent = 'üñ±Ô∏è Mouse Trail Controls';
        if (trailControls) trailControls.style.display = 'block';
        break;
      default:
        if (modeControlsTitle) modeControlsTitle.textContent = 'üéØ Ball Pit Controls';
        if (pitControls) pitControls.style.display = 'block';
        break;
    }
  }

  // Reusable event listener factory for sliders
  // Removed unused slider listener factory

  // Apply preset helpers
  function applyPhysicsPreset(key) {
    const p = PHYSICS_PRESETS[key]; if (!p) return;
    // Keep gravity constant (1.1x Earth). Only apply REST and FRICTION from preset.
    REST = p.REST; FRICTION = p.FRICTION;
    MAX_BALLS = p.maxBalls; sizeVariation = p.sizeVariation;
    const newScale = p.sizeScale;
    sizeScale = newScale;
    // Recompute effective scale and proportionally resize existing balls
    updateEffectiveScaleAndBallSizes();
    for (let i=0; i<balls.length; i++) { balls[i].m = ballMassKg; }
    
    // Remove excess balls if new limit is lower (truncate efficiently)
    if (balls.length > MAX_BALLS) { balls.length = MAX_BALLS; }
    
    // Update UI efficiently (gravity is fixed; no slider to update)
    updateSliderAndValue(restitutionSlider, restitutionVal, REST, 2);
    updateSliderAndValue(frictionSlider, frictionVal, FRICTION, 4);
    updateSliderAndValue(sizeSlider, sizeVal, sizeScale, 1);
    updateSliderAndValue(maxBallsSlider, maxBallsVal, MAX_BALLS, 0);
    updateSliderAndValue(sizeVariationSlider, sizeVariationVal, sizeVariation, 1);
    
    // Apply the new size variation to existing balls
    updateExistingBallSizes();
  }
  function applySpawnPreset(key) {
    const s = SPAWN_PRESETS[key]; if (!s) return;
    EMIT_INTERVAL = s.EMIT_INTERVAL; SPAWN_X_CENTER_VW = s.xCenter; SPAWN_Y_VH = s.y; SPAWN_W_VW = s.w; SPAWN_H_VH = s.h;
    updateSliderAndValue(emitterSlider, emitterVal, EMIT_INTERVAL, 3);
    updateSliderAndValue(spawnCenterSlider, spawnCenterVal, SPAWN_X_CENTER_VW, 0);
    updateSliderAndValue(spawnYSlider, spawnYVal, SPAWN_Y_VH, 0);
    updateSliderAndValue(spawnWidthSlider, spawnWidthVal, SPAWN_W_VW, 0);
    updateSliderAndValue(spawnHeightSlider, spawnHeightVal, SPAWN_H_VH, 0);
  }
  function applyRepellerPreset(key) {
    const r = REPELLER_PRESETS[key]; if (!r) return;
    repelRadius = r.r; repelPower = r.p * (REPELLER_GLOBAL_MULTIPLIER / 20.0); // keep perceived strength consistent after global doubling
    repellerEnabled = (key !== 'off');
    updateSliderAndValue(repelSizeSlider, repelSizeVal, repelRadius, 0);
    // Sync slider to mapped power and label
    const sliderPos = powerToRepelSlider(repelPower);
    if (repelPowerSlider) repelPowerSlider.value = String(sliderPos);
    if (repelPowerVal) repelPowerVal.textContent = Math.round(repelPower).toString();
    updateSliderAndValue(repelSoftSlider, repelSoftVal, repelSoft, 1);
    if (repelResponsive) updateRepelRadius();
  }
  // Shadow preset function removed

  // Apply sane defaults FIRST (before event listeners to avoid triggering them)
  applyPhysicsPreset('rubberHeavy');
  applySpawnPreset('fullRain');
  applyRepellerPreset('off');
  // Initialize responsive repel radius on load
  updateRepelRadius();
  
  // Initialize color system
  const defaultTemplate = COLOR_TEMPLATES[currentTemplate];
  if (color1 && color1Val) { color1.value = defaultTemplate.colors[0]; color1Val.textContent = defaultTemplate.colors[0].toUpperCase(); }
  if (color2 && color2Val) { color2.value = defaultTemplate.colors[1]; color2Val.textContent = defaultTemplate.colors[1].toUpperCase(); }
  if (color3 && color3Val) { color3.value = defaultTemplate.colors[2]; color3Val.textContent = defaultTemplate.colors[2].toUpperCase(); }
  if (color4 && color4Val) { color4.value = defaultTemplate.colors[3]; color4Val.textContent = defaultTemplate.colors[3].toUpperCase(); }
  if (color5 && color5Val) { color5.value = defaultTemplate.colors[4]; color5Val.textContent = defaultTemplate.colors[4].toUpperCase(); }
  if (color6 && color6Val) { color6.value = defaultTemplate.colors[5]; color6Val.textContent = defaultTemplate.colors[5].toUpperCase(); }
  if (color7 && color7Val) { color7.value = defaultTemplate.colors[6]; color7Val.textContent = defaultTemplate.colors[6].toUpperCase(); }
  if (color8 && color8Val) { color8.value = defaultTemplate.colors[7]; color8Val.textContent = defaultTemplate.colors[7].toUpperCase(); }
  // Sync CSS variables on init
  syncPaletteVars(defaultTemplate.colors);

  // Hook presets to selects AFTER applying defaults
  physicsSelect && physicsSelect.addEventListener('change', () => applyPhysicsPreset(physicsSelect.value));
  spawnSelect && spawnSelect.addEventListener('change', () => applySpawnPreset(spawnSelect.value));
  repellerSelect && repellerSelect.addEventListener('change', () => applyRepellerPreset(repellerSelect.value));

  // Now that sizeScale is set by presets, compute responsive scale once
  updateEffectiveScaleAndBallSizes();
  
  // Initialize text colliders
  updateTextColliders();
})();
</script>
</body>
</html>
